<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>events.t</title></head><body>
<table class=ban><tr><td><h1>events.t</h1><td align=right><a href="../file/events.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library: events
<a name="7"></a> *
<a name="8"></a> *   This module defines the event framework.  An event is a programmed
<a name="9"></a> *   operation that occurs at a particular point in the game; an event can
<a name="10"></a> *   be turn-based, in which case it occurs after a given number of turns
<a name="11"></a> *   has elapsed, or it can occur in real time, which means that it occurs
<a name="12"></a> *   after a particular interval of time has elapsed.
<a name="13"></a> */
<a name="14"></a>
<a name="15"></a>#include "adv3.h"
<a name="16"></a>#include &lt;dict.h&gt;
<a name="17"></a>#include &lt;gramprod.h&gt;
<a name="18"></a>
<a name="19"></a>
<a name="20"></a>/* ------------------------------------------------------------------------ */
<a name="21"></a>/*
<a name="22"></a> *   Run the main scheduling loop.  This continues until we encounter an
<a name="23"></a> *   end-of-file error reading from the console, or a QuitException is
<a name="24"></a> *   thrown to terminate the game.
<a name="25"></a> */
<a name="26"></a>runScheduler()
<a name="27"></a>{
<a name="28"></a>    /* keep going until we quit the game */
<a name="29"></a>    for (;;)
<a name="30"></a>    {
<a name="31"></a>        /* catch the exceptions that terminate the game */
<a name="32"></a>        try
<a name="33"></a>        {
<a name="34"></a>            /* start with an empty list of schedulable items */
<a name="35"></a>            local vec = new Vector(10);
<a name="36"></a>
<a name="37"></a>            /* find the lowest time at which something is ready to run */
<a name="38"></a>            local minTime = nil;
<a name="39"></a>            foreach (local cur in Schedulable.allSchedulables)
<a name="40"></a>            {
<a name="41"></a>                /* get this item's next eligible run time */
<a name="42"></a>                local curTime = cur.getNextRunTime();
<a name="43"></a>
<a name="44"></a>                /*
<a name="45"></a>                 *   if it's not nil, and it's equal to or below the
<a name="46"></a>                 *   lowest we've seen so far, note it
<a name="47"></a>                 */
<a name="48"></a>                if (curTime != nil &amp;&amp; (minTime == nil || curTime &lt;= minTime))
<a name="49"></a>                {
<a name="50"></a>                    /*
<a name="51"></a>                     *   if this is different from the current minimum
<a name="52"></a>                     *   schedulable time, clear out the list of
<a name="53"></a>                     *   schedulables, because the list keeps track of the
<a name="54"></a>                     *   items at the lowest time only
<a name="55"></a>                     */
<a name="56"></a>                    if (minTime != nil &amp;&amp; curTime &lt; minTime)
<a name="57"></a>                        vec.removeRange(1, vec.length());
<a name="58"></a>
<a name="59"></a>                    /* add this item to the list */
<a name="60"></a>                    vec.append(cur);
<a name="61"></a>
<a name="62"></a>                    /* note the new lowest schedulable time */
<a name="63"></a>                    minTime = curTime;
<a name="64"></a>                }
<a name="65"></a>            }
<a name="66"></a>
<a name="67"></a>            /*
<a name="68"></a>             *   if nothing's ready to run, the game is over by default,
<a name="69"></a>             *   since we cannot escape this state - we can't ourselves
<a name="70"></a>             *   change anything's run time, so if nothing's ready to run
<a name="71"></a>             *   now, we won't be able to change that, and so nothing will
<a name="72"></a>             *   ever be ready to run
<a name="73"></a>             */
<a name="74"></a>            if (minTime == nil)
<a name="75"></a>            {
<a name="76"></a>                "\b[Error: nothing is available for scheduling -
<a name="77"></a>                terminating]\b";
<a name="78"></a>                return;
<a name="79"></a>            }
<a name="80"></a>
<a name="81"></a>            /*
<a name="82"></a>             *   Advance the global turn counter by the amount of game
<a name="83"></a>             *   clock time we're consuming now.
<a name="84"></a>             */
<a name="85"></a>            libGlobal.totalTurns += minTime - Schedulable.gameClockTime;
<a name="86"></a>
<a name="87"></a>            /*
<a name="88"></a>             *   advance the game clock to the minimum run time - nothing
<a name="89"></a>             *   interesting happens in game time until then, so we can
<a name="90"></a>             *   skip straight ahead to this time
<a name="91"></a>             */
<a name="92"></a>            Schedulable.gameClockTime = minTime;
<a name="93"></a>
<a name="94"></a>            /* calculate the schedule order for each item */
<a name="95"></a>            vec.forEach({x: x.calcScheduleOrder()});
<a name="96"></a>
<a name="97"></a>            /*
<a name="98"></a>             *   We have a list of everything schedulable at the current
<a name="99"></a>             *   game clock time.  Sort the list in ascending scheduling
<a name="100"></a>             *   order, so that the higher priority items come first in
<a name="101"></a>             *   the list.
<a name="102"></a>             */
<a name="103"></a>            vec = vec.sort(
<a name="104"></a>                SortAsc, {a, b: a.scheduleOrder - b.scheduleOrder});
<a name="105"></a>
<a name="106"></a>            /*
<a name="107"></a>             *   Run through the list and run each item.  Keep running
<a name="108"></a>             *   each item as long as it's ready to run - that is, as long
<a name="109"></a>             *   as its schedulable time equals the game clock time.
<a name="110"></a>             */
<a name="111"></a>        vecLoop:
<a name="112"></a>            foreach (local cur in vec)
<a name="113"></a>            {
<a name="114"></a>                /* run this item for as long as it's ready to run */
<a name="115"></a>                while (cur.getNextRunTime() == minTime)
<a name="116"></a>                {
<a name="117"></a>                    try
<a name="118"></a>                    {
<a name="119"></a>                        /*
<a name="120"></a>                         *   execute this item - if it doesn't want to be
<a name="121"></a>                         *   called again without considering other
<a name="122"></a>                         *   objects, stop looping and refigure the
<a name="123"></a>                         *   scheduling order from scratch
<a name="124"></a>                         */
<a name="125"></a>                        if (!cur.executeTurn())
<a name="126"></a>                            break vecLoop;
<a name="127"></a>                    }
<a name="128"></a>                    catch (Exception exc)
<a name="129"></a>                    {
<a name="130"></a>                        /*
<a name="131"></a>                         *   The scheduled operation threw an exception.
<a name="132"></a>                         *   If the schedulable's next run time didn't get
<a name="133"></a>                         *   updated, then the same schedulable will be
<a name="134"></a>                         *   considered ready to run again immediately on
<a name="135"></a>                         *   the next time through the loop.  It's quite
<a name="136"></a>                         *   possible in this case that we'll simply repeat
<a name="137"></a>                         *   the operation that threw the exception and get
<a name="138"></a>                         *   right back here again.  If this happens, it
<a name="139"></a>                         *   will effectively starve all of the other
<a name="140"></a>                         *   schedulables.  To ensure that other
<a name="141"></a>                         *   schedulables get a chance to run before we try
<a name="142"></a>                         *   this erroneous operation again, advance its
<a name="143"></a>                         *   next run time by one unit if it hasn't already
<a name="144"></a>                         *   been advanced.
<a name="145"></a>                         */
<a name="146"></a>                        if (cur.getNextRunTime() == minTime)
<a name="147"></a>                            cur.incNextRunTime(1);
<a name="148"></a>
<a name="149"></a>                        /* re-throw the exception */
<a name="150"></a>                        throw exc;
<a name="151"></a>                    }
<a name="152"></a>                }
<a name="153"></a>            }
<a name="154"></a>        }
<a name="155"></a>        catch (EndOfFileException eofExc)
<a name="156"></a>        {
<a name="157"></a>            /* end of file reading command input - we're done */
<a name="158"></a>            return;
<a name="159"></a>        }
<a name="160"></a>        catch (QuittingException quitExc)
<a name="161"></a>        {
<a name="162"></a>            /* explicitly quitting - we're done */
<a name="163"></a>            return;
<a name="164"></a>        }
<a name="165"></a>        catch (RestartSignal rsSig)
<a name="166"></a>        {
<a name="167"></a>            /*
<a name="168"></a>             *   Restarting - re-throw the signal for handling in the
<a name="169"></a>             *   system startup code.  Note that we explicitly catch this
<a name="170"></a>             *   signal, only to rethrow it, because we'd otherwise flag it
<a name="171"></a>             *   as an unhandled error in the catch-all Exception handler.
<a name="172"></a>             */
<a name="173"></a>            throw rsSig;
<a name="174"></a>        }
<a name="175"></a>        catch (RuntimeError rtErr)
<a name="176"></a>        {
<a name="177"></a>            /* if this is a debugger error of some kind, re-throw it */
<a name="178"></a>            if (rtErr.isDebuggerSignal)
<a name="179"></a>                throw rtErr;
<a name="180"></a>
<a name="181"></a>            /* display the error, but keep going */
<a name="182"></a>            "\b[&lt;&lt;rtErr.displayException()&gt;&gt;]\b";
<a name="183"></a>        }
<a name="184"></a>        catch (TerminateCommandException tce)
<a name="185"></a>        {
<a name="186"></a>            /*
<a name="187"></a>             *   Aborted command - ignore it.  This is most like to occur
<a name="188"></a>             *   when a fuse, daemon, or the like tries to terminate itself
<a name="189"></a>             *   with this exception, thinking it's operating in a normal
<a name="190"></a>             *   command execution environment.  As a convenience, simply
<a name="191"></a>             *   ignore these exceptions so that any code can use them to
<a name="192"></a>             *   abort everything and return to the main scheduling loop.
<a name="193"></a>             */
<a name="194"></a>        }
<a name="195"></a>        catch (ExitSignal es)
<a name="196"></a>        {
<a name="197"></a>            /* ignore this, just as we ignore TerminateCommandException */
<a name="198"></a>        }
<a name="199"></a>        catch (ExitActionSignal eas)
<a name="200"></a>        {
<a name="201"></a>            /* ignore this, just as we ignore TerminateCommandException */
<a name="202"></a>        }
<a name="203"></a>        catch (Exception exc)
<a name="204"></a>        {
<a name="205"></a>            /* some other unhandled exception - display it and keep going */
<a name="206"></a>            "\b[Unhandled exception: &lt;&lt;exc.displayException()&gt;&gt;]\b";
<a name="207"></a>        }
<a name="208"></a>    }
<a name="209"></a>}
<a name="210"></a>
<a name="211"></a>/* ------------------------------------------------------------------------ */
<a name="212"></a>/*
<a name="213"></a> *   An item that can be scheduled for time-based notifications.  The main
<a name="214"></a> *   scheduler loop in runScheduler() operates on objects of this class.
<a name="215"></a> *
<a name="216"></a> *   Note that we build a list of all Schedulable instances during
<a name="217"></a> *   pre-initialization.  If any Schedulable objects are dynamically
<a name="218"></a> *   created, they must be added to the list explicitly after creation in
<a name="219"></a> *   order for the event manager to schedule them for execution.  The
<a name="220"></a> *   default constructor does this automatically, so subclasses can simply
<a name="221"></a> *   inherit our constructor to be added to the master list.
<a name="222"></a> */
<a name="223"></a>class Schedulable: object
<a name="224"></a>    /* construction - add myself to the Schedulable list */
<a name="225"></a>    construct()
<a name="226"></a>    {
<a name="227"></a>        /*
<a name="228"></a>         *   Add myself to the master list of Schedulable instances.  Note
<a name="229"></a>         *   that we must update the list in the Schedulable class itself.
<a name="230"></a>         */
<a name="231"></a>        Schedulable.allSchedulables += self;
<a name="232"></a>    }
<a name="233"></a>
<a name="234"></a>    /*
<a name="235"></a>     *   Get the next time (on the game clock) at which I'm eligible for
<a name="236"></a>     *   execution.  We won't receive any scheduling notifications until
<a name="237"></a>     *   this time.  If this object doesn't want any scheduling
<a name="238"></a>     *   notifications, return nil.
<a name="239"></a>     */
<a name="240"></a>    getNextRunTime() { return nextRunTime; }
<a name="241"></a>
<a name="242"></a>    /* advance my next run time by the given number of clock units */
<a name="243"></a>    incNextRunTime(amt)
<a name="244"></a>    {
<a name="245"></a>        if (nextRunTime != nil)
<a name="246"></a>            nextRunTime += amt;
<a name="247"></a>    }
<a name="248"></a>
<a name="249"></a>    /*
<a name="250"></a>     *   Notify this object that its scheduled run time has arrived.  This
<a name="251"></a>     *   should perform the scheduled task.  If the scheduled task takes
<a name="252"></a>     *   any game time, the object's internal next run time should be
<a name="253"></a>     *   updated accordingly.
<a name="254"></a>     *
<a name="255"></a>     *   The scheduler will invoke this method of the same object
<a name="256"></a>     *   repeatedly for as long as its nextRunTime remains unchanged AND
<a name="257"></a>     *   this method returns true.  If the object's scheduling priority
<a name="258"></a>     *   changes relative to other schedulable objects, it should return
<a name="259"></a>     *   nil here to tell the scheduler to recalculate scheduling
<a name="260"></a>     *   priorities.
<a name="261"></a>     */
<a name="262"></a>    executeTurn() { return true; }
<a name="263"></a>
<a name="264"></a>    /*
<a name="265"></a>     *   Scheduling order.  This determines which item goes first when
<a name="266"></a>     *   multiple items are schedulable at the same time (i.e., they all
<a name="267"></a>     *   have the same getNextRunTime() values).  The item with the lowest
<a name="268"></a>     *   number here goes first.
<a name="269"></a>     *
<a name="270"></a>     *   This should never be evaluated except immediately after a call to
<a name="271"></a>     *   calcScheduleOrder.
<a name="272"></a>     */
<a name="273"></a>    scheduleOrder = 100
<a name="274"></a>
<a name="275"></a>    /*
<a name="276"></a>     *   Calculate the scheduling order, returning the order value and
<a name="277"></a>     *   storing it in our property scheduleOrder.  This is used to
<a name="278"></a>     *   calculate and cache the value prior to sorting a list of
<a name="279"></a>     *   schedulable items.  We use this two-step approach (first
<a name="280"></a>     *   calculate, then sort) so that we avoid repeatedly evaluating a
<a name="281"></a>     *   complex calculation, if indeed there is a complex calculation to
<a name="282"></a>     *   perform.
<a name="283"></a>     *
<a name="284"></a>     *   By default, we assume that the schedule order is static, so we
<a name="285"></a>     *   simply leave our scheduleOrder property unchanged and return its
<a name="286"></a>     *   present value.
<a name="287"></a>     */
<a name="288"></a>    calcScheduleOrder() { return scheduleOrder; }
<a name="289"></a>
<a name="290"></a>    /* my next running time, in game clock time */
<a name="291"></a>    nextRunTime = nil
<a name="292"></a>
<a name="293"></a>    /*
<a name="294"></a>     *   A class variable giving the current game clock time.  This is a
<a name="295"></a>     *   class variable because there's only one global game clock.  The
<a name="296"></a>     *   game clock starts at zero and increments in game time units; a
<a name="297"></a>     *   game time unit is the arbitrary quantum of time for our event
<a name="298"></a>     *   scheduling system.
<a name="299"></a>     */
<a name="300"></a>    gameClockTime = 0
<a name="301"></a>
<a name="302"></a>    /*
<a name="303"></a>     *   A list of all of the Schedulable objects in the game.  We set this
<a name="304"></a>     *   up during pre-initialization; if any Schedulable instances are
<a name="305"></a>     *   created dynamically, they must be explicitly added to this list
<a name="306"></a>     *   after creation.
<a name="307"></a>     */
<a name="308"></a>    allSchedulables = nil
<a name="309"></a>;
<a name="310"></a>
<a name="311"></a>/*
<a name="312"></a> *   Pre-initializer: build the master list of Schedulable instances
<a name="313"></a> */
<a name="314"></a>PreinitObject
<a name="315"></a>    /*
<a name="316"></a>     *   Execute preinitialization.  Build a list of all of the schedulable
<a name="317"></a>     *   objects in the game, so that we can scan this list quickly during
<a name="318"></a>     *   play.
<a name="319"></a>     */
<a name="320"></a>    execute()
<a name="321"></a>    {
<a name="322"></a>        local vec;
<a name="323"></a>
<a name="324"></a>        /* set up an empty vector to hold the schedulable objects */
<a name="325"></a>        vec = new Vector(32);
<a name="326"></a>
<a name="327"></a>        /* add all of the Schedulable instances to the vector */
<a name="328"></a>        forEachInstance(Schedulable, {s: vec.append(s)});
<a name="329"></a>
<a name="330"></a>        /* save the list of Schedulable instances as an ordinary list */
<a name="331"></a>        Schedulable.allSchedulables = vec.toList();
<a name="332"></a>    }
<a name="333"></a>;
<a name="334"></a>
<a name="335"></a>/* ------------------------------------------------------------------------ */
<a name="336"></a>/*
<a name="337"></a> *   Basic Event Manager.  This is a common base class for the game-time
<a name="338"></a> *   and real-time event managers.  This class handles the details of
<a name="339"></a> *   managing the event queue; the subclasses must define the specifics of
<a name="340"></a> *   event timing.
<a name="341"></a> */
<a name="342"></a>class BasicEventManager: object
<a name="343"></a>    /* add an event */
<a name="344"></a>    addEvent(event)
<a name="345"></a>    {
<a name="346"></a>        /* append the event to our list */
<a name="347"></a>        events_.append(event);
<a name="348"></a>    }
<a name="349"></a>
<a name="350"></a>    /* remove an event */
<a name="351"></a>    removeEvent(event)
<a name="352"></a>    {
<a name="353"></a>        /* remove the event from our list */
<a name="354"></a>        events_.removeElement(event);
<a name="355"></a>    }
<a name="356"></a>
<a name="357"></a>    /*
<a name="358"></a>     *   Remove events matching the given object and property combination.
<a name="359"></a>     *   We remove all events that match both the object and property
<a name="360"></a>     *   (events matching only the object or only the property are not
<a name="361"></a>     *   affected).
<a name="362"></a>     *
<a name="363"></a>     *   This is provided mostly as a convenience for cases where an event
<a name="364"></a>     *   is known to be uniquely identifiable by its object and property
<a name="365"></a>     *   values; this saves the caller the trouble of keeping track of the
<a name="366"></a>     *   Event object created when the event was first registered.
<a name="367"></a>     *
<a name="368"></a>     *   When a particular object/property combination might be used in
<a name="369"></a>     *   several different events, it's better to keep a reference to the
<a name="370"></a>     *   Event object representing each event, and use removeEvent() to
<a name="371"></a>     *   remove the specific Event object of interest.
<a name="372"></a>     *
<a name="373"></a>     *   Returns true if we find any matching events, nil if not.
<a name="374"></a>     */
<a name="375"></a>    removeMatchingEvents(obj, prop)
<a name="376"></a>    {
<a name="377"></a>        local found;
<a name="378"></a>
<a name="379"></a>        /*
<a name="380"></a>         *   Scan our list, and remove each event matching the parameters.
<a name="381"></a>         *   Note that it's safe to remove things from a vector that we're
<a name="382"></a>         *   iterating with foreach(), since foreach() makes a safe copy
<a name="383"></a>         *   of the vector for the iteration.
<a name="384"></a>         */
<a name="385"></a>        found = nil;
<a name="386"></a>        foreach (local cur in events_)
<a name="387"></a>        {
<a name="388"></a>            /* if this one matches, remove it */
<a name="389"></a>            if (cur.eventMatches(obj, prop))
<a name="390"></a>            {
<a name="391"></a>                /* remove the event */
<a name="392"></a>                removeEvent(cur);
<a name="393"></a>
<a name="394"></a>                /* note that we found a match */
<a name="395"></a>                found = true;
<a name="396"></a>            }
<a name="397"></a>        }
<a name="398"></a>
<a name="399"></a>        /* return our 'found' indication */
<a name="400"></a>        return found;
<a name="401"></a>    }
<a name="402"></a>
<a name="403"></a>    /*
<a name="404"></a>     *   Remove the current event - this is provided for convenience so
<a name="405"></a>     *   that an event can cancel itself in the course of its execution.
<a name="406"></a>     *
<a name="407"></a>     *   Note that this has no effect on the current event execution -
<a name="408"></a>     *   this simply prevents the event from receiving additional
<a name="409"></a>     *   notifications in the future.
<a name="410"></a>     */
<a name="411"></a>    removeCurrentEvent()
<a name="412"></a>    {
<a name="413"></a>        /* remove the currently active event from our list */
<a name="414"></a>        removeEvent(curEvent_);
<a name="415"></a>    }
<a name="416"></a>
<a name="417"></a>    /* event list - each instance must initialize this to a vector */
<a name="418"></a>    // events_ = nil
<a name="419"></a>;
<a name="420"></a>
<a name="421"></a>/*
<a name="422"></a> *   Event Manager.  This is a schedulable object that keeps track of
<a name="423"></a> *   fuses and daemons, and schedules their execution.
<a name="424"></a> */
<a name="425"></a>eventManager: BasicEventManager, Schedulable
<a name="426"></a>    /*
<a name="427"></a>     *   Use a scheduling order of 1000 to ensure we go after all actors.
<a name="428"></a>     *   By default, actors use scheduling orders in the range 100 to 400,
<a name="429"></a>     *   so our order of 1000 ensures that fuses and daemons run after all
<a name="430"></a>     *   characters on a given turn.
<a name="431"></a>     */
<a name="432"></a>    scheduleOrder = 1000
<a name="433"></a>
<a name="434"></a>    /*
<a name="435"></a>     *   Get the next run time.  We'll find the lowest run time of our
<a name="436"></a>     *   fuses and daemons and return that.
<a name="437"></a>     */
<a name="438"></a>    getNextRunTime()
<a name="439"></a>    {
<a name="440"></a>        local minTime;
<a name="441"></a>
<a name="442"></a>        /*
<a name="443"></a>         *   run through our list of events, and find the event that is
<a name="444"></a>         *   scheduled to run at the lowest game clock time
<a name="445"></a>         */
<a name="446"></a>        minTime = nil;
<a name="447"></a>        foreach (local cur in events_)
<a name="448"></a>        {
<a name="449"></a>            local curTime;
<a name="450"></a>
<a name="451"></a>            /* get this item's scheduled run time */
<a name="452"></a>            curTime = cur.getNextRunTime();
<a name="453"></a>
<a name="454"></a>            /* if it's not nil and it's the lowest so far, remember it */
<a name="455"></a>            if (curTime != nil &amp;&amp; (minTime == nil || curTime &lt; minTime))
<a name="456"></a>                minTime = curTime;
<a name="457"></a>        }
<a name="458"></a>
<a name="459"></a>        /* return the minimum time we found */
<a name="460"></a>        return minTime;
<a name="461"></a>    }
<a name="462"></a>
<a name="463"></a>    /*
<a name="464"></a>     *   Execute a turn.  We'll execute each fuse and each daemon that is
<a name="465"></a>     *   currently schedulable.
<a name="466"></a>     */
<a name="467"></a>    executeTurn()
<a name="468"></a>    {
<a name="469"></a>        local lst;
<a name="470"></a>
<a name="471"></a>        /*
<a name="472"></a>         *   build a list of all of our events with the current game clock
<a name="473"></a>         *   time - these are the events that are currently schedulable
<a name="474"></a>         */
<a name="475"></a>        lst = events_.subset({x: x.getNextRunTime()
<a name="476"></a>                                 == Schedulable.gameClockTime});
<a name="477"></a>
<a name="478"></a>        /* execute the items in this list */
<a name="479"></a>        executeList(lst);
<a name="480"></a>
<a name="481"></a>        /* no change in scheduling priorities */
<a name="482"></a>        return true;
<a name="483"></a>    }
<a name="484"></a>
<a name="485"></a>    /*
<a name="486"></a>     *   Execute a command prompt turn.  We'll execute each
<a name="487"></a>     *   per-command-prompt daemon.
<a name="488"></a>     */
<a name="489"></a>    executePrompt()
<a name="490"></a>    {
<a name="491"></a>        /* execute all of the per-command-prompt daemons */
<a name="492"></a>        executeList(events_.subset({x: x.isPromptDaemon}));
<a name="493"></a>    }
<a name="494"></a>
<a name="495"></a>    /*
<a name="496"></a>     *   internal service routine - execute the fuses and daemons in the
<a name="497"></a>     *   given list, in eventOrder priority order
<a name="498"></a>     */
<a name="499"></a>    executeList(lst)
<a name="500"></a>    {
<a name="501"></a>        /* sort the list in ascending event order */
<a name="502"></a>        lst = lst.toList()
<a name="503"></a>              .sort(SortAsc, {a, b: a.eventOrder - b.eventOrder});
<a name="504"></a>
<a name="505"></a>        /* run through the list and execute each item ready to run */
<a name="506"></a>        foreach (local cur in lst)
<a name="507"></a>        {
<a name="508"></a>            /* remember our old active event, then establish the new one */
<a name="509"></a>            local oldEvent = curEvent_;
<a name="510"></a>            curEvent_ = cur;
<a name="511"></a>
<a name="512"></a>            /* make sure we restore things on the way out */
<a name="513"></a>            try
<a name="514"></a>            {
<a name="515"></a>                local pc;
<a name="516"></a>
<a name="517"></a>                /* have the player character note the pre-event conditions */
<a name="518"></a>                pc = gPlayerChar;
<a name="519"></a>                pc.noteConditionsBefore();
<a name="520"></a>
<a name="521"></a>                /* cancel any sense caching currently in effect */
<a name="522"></a>                libGlobal.disableSenseCache();
<a name="523"></a>
<a name="524"></a>                /* execute the event */
<a name="525"></a>                cur.executeEvent();
<a name="526"></a>
<a name="527"></a>                /*
<a name="528"></a>                 *   if the player character is the same as it was, ask
<a name="529"></a>                 *   the player character to note any change in conditions
<a name="530"></a>                 */
<a name="531"></a>                if (gPlayerChar == pc)
<a name="532"></a>                    pc.noteConditionsAfter();
<a name="533"></a>            }
<a name="534"></a>            catch (Exception exc)
<a name="535"></a>            {
<a name="536"></a>                /*
<a name="537"></a>                 *   If an event throws an exception out of its handler,
<a name="538"></a>                 *   remove the event from the active list.  If we were to
<a name="539"></a>                 *   leave it active, we'd go back and execute the same
<a name="540"></a>                 *   event again the next time we look for something to
<a name="541"></a>                 *   schedule, and that would in turn probably just
<a name="542"></a>                 *   encounter the same exception - so we'd be stuck in an
<a name="543"></a>                 *   infinite loop executing this erroneous code.  To
<a name="544"></a>                 *   ensure that we don't get stuck, remove the event.
<a name="545"></a>                 */
<a name="546"></a>                removeCurrentEvent();
<a name="547"></a>
<a name="548"></a>                /* re-throw the exception */
<a name="549"></a>                throw exc;
<a name="550"></a>            }
<a name="551"></a>            finally
<a name="552"></a>            {
<a name="553"></a>                /* restore the enclosing current event */
<a name="554"></a>                curEvent_ = oldEvent;
<a name="555"></a>            }
<a name="556"></a>        }
<a name="557"></a>    }
<a name="558"></a>
<a name="559"></a>    /* our list of fuses and daemons */
<a name="560"></a>    events_ = static new Vector(20)
<a name="561"></a>
<a name="562"></a>    /* the event currently being executed */
<a name="563"></a>    curEvent_ = nil
<a name="564"></a>;
<a name="565"></a>
<a name="566"></a>/*
<a name="567"></a> *   Pseudo-action subclass to represent the action environment while
<a name="568"></a> *   processing a daemon, fuse, or other event.
<a name="569"></a> */
<a name="570"></a>class EventAction: Action
<a name="571"></a>    /*
<a name="572"></a>     *   event actions are internal system actions; they don't consume
<a name="573"></a>     *   additional turns themselves, since they run between player turns
<a name="574"></a>     */
<a name="575"></a>    actionTime = 0;
<a name="576"></a>;
<a name="577"></a>
<a name="578"></a>/*
<a name="579"></a> *   A basic event, for game-time and real-time events.
<a name="580"></a> */
<a name="581"></a>class BasicEvent: object
<a name="582"></a>    /* construction */
<a name="583"></a>    construct(obj, prop)
<a name="584"></a>    {
<a name="585"></a>        /* remember the object and property to call at execution */
<a name="586"></a>        obj_ = obj;
<a name="587"></a>        prop_ = prop;
<a name="588"></a>    }
<a name="589"></a>
<a name="590"></a>    /*
<a name="591"></a>     *   Execute the event.  This must be overridden by the subclass to
<a name="592"></a>     *   perform the appropriate operation when executed.  In particular,
<a name="593"></a>     *   the subclass must reschedule or unschedule the event, as
<a name="594"></a>     *   appropriate.
<a name="595"></a>     */
<a name="596"></a>    executeEvent() { }
<a name="597"></a>
<a name="598"></a>    /* does this event match the given object/property combination? */
<a name="599"></a>    eventMatches(obj, prop) { return obj == obj_ &amp;&amp; prop == prop_; }
<a name="600"></a>
<a name="601"></a>    /*
<a name="602"></a>     *   Call our underlying method.  This is an internal routine intended
<a name="603"></a>     *   for use by the executeEvent() implementations.
<a name="604"></a>     */
<a name="605"></a>    callMethod()
<a name="606"></a>    {
<a name="607"></a>        /*
<a name="608"></a>         *   invoke the method in our sensory context, and in a simulated
<a name="609"></a>         *   action environment
<a name="610"></a>         */
<a name="611"></a>        withActionEnv(EventAction, gPlayerChar,
<a name="612"></a>            {: callWithSenseContext(source_, sense_,
<a name="613"></a>                                    {: obj_.(self.prop_)() }) });
<a name="614"></a>    }
<a name="615"></a>
<a name="616"></a>    /* the object and property we invoke */
<a name="617"></a>    obj_ = nil
<a name="618"></a>    prop_ = nil
<a name="619"></a>
<a name="620"></a>    /*
<a name="621"></a>     *   The sensory context of the event.  When the event fires, we'll
<a name="622"></a>     *   execute its method in this sensory context, so that any messages
<a name="623"></a>     *   generated will be displayed only if the player character can
<a name="624"></a>     *   sense the source object in the given sense.
<a name="625"></a>     *
<a name="626"></a>     *   By default, these are nil, which means that the event's messages
<a name="627"></a>     *   will be displayed (or, at least, they won't be suppressed because
<a name="628"></a>     *   of the sensory context).
<a name="629"></a>     */
<a name="630"></a>    source_ = nil
<a name="631"></a>    sense_ = nil
<a name="632"></a>;
<a name="633"></a>
<a name="634"></a>/*
<a name="635"></a> *   Base class for fuses and daemons
<a name="636"></a> */
<a name="637"></a>class Event: BasicEvent
<a name="638"></a>    /* our next run time, in game clock time */
<a name="639"></a>    getNextRunTime() { return nextRunTime; }
<a name="640"></a>
<a name="641"></a>    /* delay our scheduled run time by the given number of turns */
<a name="642"></a>    delayEvent(turns) { nextRunTime += turns; }
<a name="643"></a>
<a name="644"></a>    /* remove this event from the event manager */
<a name="645"></a>    removeEvent() { eventManager.removeEvent(self); }
<a name="646"></a>
<a name="647"></a>    /*
<a name="648"></a>     *   Event order - this establishes the order we run relative to other
<a name="649"></a>     *   events scheduled to run at the same game clock time.  Lowest
<a name="650"></a>     *   number goes first.  By default, we provide an event order of 100,
<a name="651"></a>     *   which should leave plenty of room for custom events before and
<a name="652"></a>     *   after default events.
<a name="653"></a>     */
<a name="654"></a>    eventOrder = 100
<a name="655"></a>
<a name="656"></a>    /* creation */
<a name="657"></a>    construct(obj, prop)
<a name="658"></a>    {
<a name="659"></a>        /* inherit default handling */
<a name="660"></a>        inherited(obj, prop);
<a name="661"></a>
<a name="662"></a>        /* add myself to the event manager's active event list */
<a name="663"></a>        eventManager.addEvent(self);
<a name="664"></a>    }
<a name="665"></a>
<a name="666"></a>    /*
<a name="667"></a>     *   our next execution time, expressed in game clock time; by
<a name="668"></a>     *   default, we'll set this to nil, which means that we are not
<a name="669"></a>     *   scheduled to execute at all
<a name="670"></a>     */
<a name="671"></a>    nextRunTime = nil
<a name="672"></a>
<a name="673"></a>    /* by default, we're not a per-command-prompt daemon */
<a name="674"></a>    isPromptDaemon = nil
<a name="675"></a>;
<a name="676"></a>
<a name="677"></a>/*
<a name="678"></a> *   Fuse.  A fuse is an event that fires once at a given time in the
<a name="679"></a> *   future.  Once a fuse is executed, it is removed from further
<a name="680"></a> *   scheduling.
<a name="681"></a> */
<a name="682"></a>class Fuse: Event
<a name="683"></a>    /*
<a name="684"></a>     *   Creation.  'turns' is the number of turns in the future at which
<a name="685"></a>     *   the fuse is executed; if turns is 0, the fuse will be executed on
<a name="686"></a>     *   the current turn.
<a name="687"></a>     */
<a name="688"></a>    construct(obj, prop, turns)
<a name="689"></a>    {
<a name="690"></a>        /* inherit the base class constructor */
<a name="691"></a>        inherited(obj, prop);
<a name="692"></a>
<a name="693"></a>        /*
<a name="694"></a>         *   set my scheduled time to the current game clock time plus the
<a name="695"></a>         *   number of turns into the future
<a name="696"></a>         */
<a name="697"></a>        nextRunTime = Schedulable.gameClockTime + turns;
<a name="698"></a>    }
<a name="699"></a>
<a name="700"></a>    /* execute the fuse */
<a name="701"></a>    executeEvent()
<a name="702"></a>    {
<a name="703"></a>        /* call my method */
<a name="704"></a>        callMethod();
<a name="705"></a>
<a name="706"></a>        /* a fuse fires only once, so remove myself from further scheduling */
<a name="707"></a>        eventManager.removeEvent(self);
<a name="708"></a>    }
<a name="709"></a>;
<a name="710"></a>
<a name="711"></a>/*
<a name="712"></a> *   Sensory-context-sensitive fuse - this is a fuse with an explicit
<a name="713"></a> *   sensory context.  We'll run the fuse in its sense context, so any
<a name="714"></a> *   messages generated will be visible only if the given source object is
<a name="715"></a> *   reachable by the player character in the given sense.
<a name="716"></a> *
<a name="717"></a> *   Conceptually, the source object is considered the source of any
<a name="718"></a> *   messages that the fuse generates, and the messages pertain to the
<a name="719"></a> *   given sense; so if the player character cannot sense the source
<a name="720"></a> *   object in the given sense, the messages should not be displayed.  For
<a name="721"></a> *   example, if the fuse will describe the noise made by an alarm clock
<a name="722"></a> *   when the alarm goes off, the source object would be the alarm clock
<a name="723"></a> *   and the sense would be sound; this way, if the player character isn't
<a name="724"></a> *   in hearing range of the alarm clock when the alarm goes off, we won't
<a name="725"></a> *   display messages about the alarm noise.
<a name="726"></a> */
<a name="727"></a>class SenseFuse: Fuse
<a name="728"></a>    construct(obj, prop, turns, source, sense)
<a name="729"></a>    {
<a name="730"></a>        /* inherit the base constructor */
<a name="731"></a>        inherited(obj, prop, turns);
<a name="732"></a>
<a name="733"></a>        /* remember our sensory context */
<a name="734"></a>        source_ = source;
<a name="735"></a>        sense_ = sense;
<a name="736"></a>    }
<a name="737"></a>;
<a name="738"></a>
<a name="739"></a>/*
<a name="740"></a> *   Daemon.  A daemon is an event that fires repeatedly at given
<a name="741"></a> *   intervals.  When a daemon is executed, it is scheduled again for
<a name="742"></a> *   execution after its interval elapses again.
<a name="743"></a> */
<a name="744"></a>class Daemon: Event
<a name="745"></a>    /*
<a name="746"></a>     *   Creation.  'interval' is the number of turns between invocations
<a name="747"></a>     *   of the daemon; this should be at least 1, which causes the daemon
<a name="748"></a>     *   to be invoked on each turn.  The first execution will be
<a name="749"></a>     *   (interval-1) turns in the future - so if interval is 1, the
<a name="750"></a>     *   daemon will first be executed on the current turn, and if
<a name="751"></a>     *   interval is 2, the daemon will be executed on the next turn.
<a name="752"></a>     */
<a name="753"></a>    construct(obj, prop, interval)
<a name="754"></a>    {
<a name="755"></a>        /* inherit the base class constructor */
<a name="756"></a>        inherited(obj, prop);
<a name="757"></a>
<a name="758"></a>        /*
<a name="759"></a>         *   an interval of less than 1 is meaningless, so make sure it's
<a name="760"></a>         *   at least 1
<a name="761"></a>         */
<a name="762"></a>        if (interval &lt; 1)
<a name="763"></a>            interval = 1;
<a name="764"></a>
<a name="765"></a>        /* remember my interval */
<a name="766"></a>        interval_ = interval;
<a name="767"></a>
<a name="768"></a>        /*
<a name="769"></a>         *   set my initial execution time, in game clock time - add one
<a name="770"></a>         *   less than the interval to the current game clock time, so
<a name="771"></a>         *   that we count the current turn as yet to elapse for the
<a name="772"></a>         *   purposes of the interval before the daemon's first execution
<a name="773"></a>         */
<a name="774"></a>        nextRunTime = Schedulable.gameClockTime + interval - 1;
<a name="775"></a>    }
<a name="776"></a>
<a name="777"></a>    /* execute the daemon */
<a name="778"></a>    executeEvent()
<a name="779"></a>    {
<a name="780"></a>        /* call my method */
<a name="781"></a>        callMethod();
<a name="782"></a>
<a name="783"></a>        /* advance our next run time by our interval */
<a name="784"></a>        nextRunTime += interval_;
<a name="785"></a>    }
<a name="786"></a>
<a name="787"></a>    /* our execution interval, in turns */
<a name="788"></a>    interval_ = 1
<a name="789"></a>;
<a name="790"></a>
<a name="791"></a>/*
<a name="792"></a> *   Sensory-context-sensitive daemon - this is a daemon with an explicit
<a name="793"></a> *   sensory context.  This is the daemon counterpart of SenseFuse.
<a name="794"></a> */
<a name="795"></a>class SenseDaemon: Daemon
<a name="796"></a>    construct(obj, prop, interval, source, sense)
<a name="797"></a>    {
<a name="798"></a>        /* inherit the base constructor */
<a name="799"></a>        inherited(obj, prop, interval);
<a name="800"></a>
<a name="801"></a>        /* remember our sensory context */
<a name="802"></a>        source_ = source;
<a name="803"></a>        sense_ = sense;
<a name="804"></a>    }
<a name="805"></a>;
<a name="806"></a>
<a name="807"></a>/*
<a name="808"></a> *   Command Prompt Daemon.  This is a special type of daemon that
<a name="809"></a> *   executes not according to the game clock, but rather once per command
<a name="810"></a> *   prompt.  The system executes all of these daemons just before each
<a name="811"></a> *   time it prompts for a command line.
<a name="812"></a> */
<a name="813"></a>class PromptDaemon: Event
<a name="814"></a>    /* execute the daemon */
<a name="815"></a>    executeEvent()
<a name="816"></a>    {
<a name="817"></a>        /*
<a name="818"></a>         *   call my method - there's nothing else to do for this type of
<a name="819"></a>         *   daemon, since our scheduling is not affected by the game
<a name="820"></a>         *   clock
<a name="821"></a>         */
<a name="822"></a>        callMethod();
<a name="823"></a>    }
<a name="824"></a>
<a name="825"></a>    /* flag: we are a special per-command-prompt daemon */
<a name="826"></a>    isPromptDaemon = true
<a name="827"></a>;
<a name="828"></a>
<a name="829"></a>/*
<a name="830"></a> *   A one-time-only prompt daemon is a regular command prompt daemon,
<a name="831"></a> *   except that it fires only once.  After it fires once, the daemon
<a name="832"></a> *   automatically deactivates itself, so that it won't fire again.
<a name="833"></a> *
<a name="834"></a> *   Prompt daemons are occasionally useful for non-recurring processing,
<a name="835"></a> *   when you want to defer some bit of code until a "safe" time between
<a name="836"></a> *   turns.  In these cases, the regular PromptDaemon is inconvenient to
<a name="837"></a> *   use because it automatically recurs.  This subclass is handy for these
<a name="838"></a> *   cases, since it lets you schedule some bit of processing for a single
<a name="839"></a> *   deferred execution.
<a name="840"></a> *
<a name="841"></a> *   One special situation where one-time prompt daemons can be handy is in
<a name="842"></a> *   triggering conversational events - such as initiating a conversation -
<a name="843"></a> *   at the very beginning of the game.  Initiating a conversation can only
<a name="844"></a> *   be done from within an action context, but no action context is in
<a name="845"></a> *   effect during the game's initialization.  An easy way to deal with
<a name="846"></a> *   this is to create a one-time prompt daemon during initialization, and
<a name="847"></a> *   then trigger the event from the daemon's callback method.  The prompt
<a name="848"></a> *   daemon will set up a daemon action environment just before the first
<a name="849"></a> *   command prompt is displayed, at which point the callback will be able
<a name="850"></a> *   to trigger the event as though it were in ordinary action handler
<a name="851"></a> *   code.
<a name="852"></a> */
<a name="853"></a>class OneTimePromptDaemon: PromptDaemon
<a name="854"></a>    executeEvent()
<a name="855"></a>    {
<a name="856"></a>        /* execute as normal */
<a name="857"></a>        inherited();
<a name="858"></a>
<a name="859"></a>        /* remove myself from the event list, so that I don't fire again */
<a name="860"></a>        removeEvent();
<a name="861"></a>    }
<a name="862"></a>;
<a name="863"></a>
<a name="864"></a>/* ------------------------------------------------------------------------ */
<a name="865"></a>/*
<a name="866"></a> *   Real-Time Event Manager.  This object manages all of the game's
<a name="867"></a> *   real-time events, which are events that occur according to elapsed
<a name="868"></a> *   real-world time.
<a name="869"></a> */
<a name="870"></a>realTimeManager: BasicEventManager, InitObject
<a name="871"></a>    /*
<a name="872"></a>     *   Get the elapsed game time at which the next real-time event is
<a name="873"></a>     *   scheduled.  This returns a value which can be compared to that
<a name="874"></a>     *   returned by getElapsedTime(): if this value is less than or equal
<a name="875"></a>     *   to the value from getElapsedTime(), then the next event is reay
<a name="876"></a>     *   for immediate execution; otherwise, the result of subtracting
<a name="877"></a>     *   getElapsedTime() from our return value gives the number of
<a name="878"></a>     *   milliseconds until the next event is schedulable.
<a name="879"></a>     *
<a name="880"></a>     *   Note that we don't calculate the delta to the next event time,
<a name="881"></a>     *   but instead return the absolute time, because the caller might
<a name="882"></a>     *   need to perform extra processing before using our return value.
<a name="883"></a>     *   If we returned a delta, that extra processing time wouldn't be
<a name="884"></a>     *   figured into the caller's determination of event schedulability.
<a name="885"></a>     *
<a name="886"></a>     *   If we return nil, it means that there are no scheduled real-time
<a name="887"></a>     *   events.
<a name="888"></a>     */
<a name="889"></a>    getNextEventTime()
<a name="890"></a>    {
<a name="891"></a>        local tMin;
<a name="892"></a>
<a name="893"></a>        /*
<a name="894"></a>         *   run through our event list and find the event with the lowest
<a name="895"></a>         *   scheduled run time
<a name="896"></a>         */
<a name="897"></a>        tMin = nil;
<a name="898"></a>        foreach (local cur in events_)
<a name="899"></a>        {
<a name="900"></a>            local tCur;
<a name="901"></a>
<a name="902"></a>            /* get the current item's time */
<a name="903"></a>            tCur = cur.getEventTime();
<a name="904"></a>
<a name="905"></a>            /*
<a name="906"></a>             *   if this one has a valid time, and we don't have a valid
<a name="907"></a>             *   time yet or this one is sooner than the soonest one we've
<a name="908"></a>             *   seen so far, note this one as the soonest so far
<a name="909"></a>             */
<a name="910"></a>            if (tMin == nil
<a name="911"></a>                || (tCur != nil &amp;&amp; tCur &lt; tMin))
<a name="912"></a>            {
<a name="913"></a>                /* this is the soonest so far */
<a name="914"></a>                tMin = tCur;
<a name="915"></a>            }
<a name="916"></a>        }
<a name="917"></a>
<a name="918"></a>        /* return the soonest event so far */
<a name="919"></a>        return tMin;
<a name="920"></a>    }
<a name="921"></a>
<a name="922"></a>    /*
<a name="923"></a>     *   Run any real-time events that are ready to execute, then return
<a name="924"></a>     *   the next event time.  The return value has the same meaning as
<a name="925"></a>     *   that of getNextEventTime().
<a name="926"></a>     */
<a name="927"></a>    executeEvents()
<a name="928"></a>    {
<a name="929"></a>        local tMin;
<a name="930"></a>
<a name="931"></a>        /*
<a name="932"></a>         *   Keep checking as long as we find anything to execute.  Each
<a name="933"></a>         *   time we execute an event, we might consume enough time that
<a name="934"></a>         *   an item earlier in our queue that we originally dismissed as
<a name="935"></a>         *   unready has become ready to run.
<a name="936"></a>         */
<a name="937"></a>        for (;;)
<a name="938"></a>        {
<a name="939"></a>            local foundEvent;
<a name="940"></a>
<a name="941"></a>            /* we haven't yet run anything on this pass */
<a name="942"></a>            foundEvent = nil;
<a name="943"></a>
<a name="944"></a>            /* we haven't found anything schedulable on this pass yet */
<a name="945"></a>            tMin = nil;
<a name="946"></a>
<a name="947"></a>            /* run each event whose time is already here */
<a name="948"></a>            foreach (local cur in events_)
<a name="949"></a>            {
<a name="950"></a>                local tCur;
<a name="951"></a>
<a name="952"></a>                /*
<a name="953"></a>                 *   If this event has a non-nil time, and its time is
<a name="954"></a>                 *   less than or equal to the current system clock time,
<a name="955"></a>                 *   run this event.  All event times are in terms of the
<a name="956"></a>                 *   game elapsed time.
<a name="957"></a>                 *
<a name="958"></a>                 *   If this event isn't schedulable, at least check to
<a name="959"></a>                 *   see if it's the soonest schedulable event so far.
<a name="960"></a>                 */
<a name="961"></a>                tCur = cur.getEventTime();
<a name="962"></a>                if (tCur != nil &amp;&amp; tCur &lt;= getElapsedTime())
<a name="963"></a>                {
<a name="964"></a>                    /* cancel any sense caching currently in effect */
<a name="965"></a>                    libGlobal.disableSenseCache();
<a name="966"></a>
<a name="967"></a>                    /* execute this event */
<a name="968"></a>                    cur.executeEvent();
<a name="969"></a>
<a name="970"></a>                    /* note that we executed something */
<a name="971"></a>                    foundEvent = true;
<a name="972"></a>                }
<a name="973"></a>                else if (tMin == nil
<a name="974"></a>                         || (tCur != nil &amp;&amp; tCur &lt; tMin))
<a name="975"></a>                {
<a name="976"></a>                    /* it's the soonest event so far */
<a name="977"></a>                    tMin = tCur;
<a name="978"></a>                }
<a name="979"></a>            }
<a name="980"></a>
<a name="981"></a>            /* if we didn't execute anything on this pass, stop scanning */
<a name="982"></a>            if (!foundEvent)
<a name="983"></a>                break;
<a name="984"></a>        }
<a name="985"></a>
<a name="986"></a>        /* return the time of the next event */
<a name="987"></a>        return tMin;
<a name="988"></a>    }
<a name="989"></a>
<a name="990"></a>    /*
<a name="991"></a>     *   Get the current game elapsed time.  This is the number of
<a name="992"></a>     *   milliseconds that has elapsed since the game was started,
<a name="993"></a>     *   counting only the continuous execution time.  When the game is
<a name="994"></a>     *   saved, we save the elapsed time at that point; when the game is
<a name="995"></a>     *   later restored, we project that saved time backwards from the
<a name="996"></a>     *   current real-world time at restoration to get the real-world time
<a name="997"></a>     *   where the game would have started if it had actually been played
<a name="998"></a>     *   continuously in one session.
<a name="999"></a>     */
<a name="1000"></a>    getElapsedTime()
<a name="1001"></a>    {
<a name="1002"></a>        /*
<a name="1003"></a>         *   return the current system real-time counter minus the virtual
<a name="1004"></a>         *   starting time
<a name="1005"></a>         */
<a name="1006"></a>        return getTime(GetTimeTicks) - startingTime;
<a name="1007"></a>    }
<a name="1008"></a>
<a name="1009"></a>    /*
<a name="1010"></a>     *   Set the current game elapsed time.  This can be used to freeze
<a name="1011"></a>     *   the real-time clock - a caller can note the elapsed game time at
<a name="1012"></a>     *   one point by calling getElapsedTime(), and then pass the same
<a name="1013"></a>     *   value to this routine to ensure that no real time can effectively
<a name="1014"></a>     *   pass between the two calls.
<a name="1015"></a>     */
<a name="1016"></a>    setElapsedTime(t)
<a name="1017"></a>    {
<a name="1018"></a>        /*
<a name="1019"></a>         *   set the virtual starting time to the current system real-time
<a name="1020"></a>         *   counter minus the given game elapsed time
<a name="1021"></a>         */
<a name="1022"></a>        startingTime = getTime(GetTimeTicks) - t;
<a name="1023"></a>    }
<a name="1024"></a>
<a name="1025"></a>    /*
<a name="1026"></a>     *   The imaginary real-world time of the starting point of the game,
<a name="1027"></a>     *   treating the game as having been played from the start in one
<a name="1028"></a>     *   continous session.  Whenever we restore a saved game, we project
<a name="1029"></a>     *   backwards from the current real-world time at restoration by the
<a name="1030"></a>     *   amount of continuous elapsed time in the saved game to find the
<a name="1031"></a>     *   point at which the game would have started if it had been played
<a name="1032"></a>     *   continuously in one session up to the restored point.
<a name="1033"></a>     *
<a name="1034"></a>     *   We set a static initial value for this, using the interpreter's
<a name="1035"></a>     *   real-time clock value at compilation time.  This ensures that
<a name="1036"></a>     *   we'll have a meaningful time base if any real-time events are
<a name="1037"></a>     *   created during pre-initialization.  This static value will only be
<a name="1038"></a>     *   in effect during preinit; we're an InitObject, so our execute()
<a name="1039"></a>     *   method will be invoked at run-time start-up, and at that point
<a name="1040"></a>     *   we'll reset the zero point to the actual run-time start time.
<a name="1041"></a>     */
<a name="1042"></a>    startingTime = static getTime(GetTimeTicks)
<a name="1043"></a>
<a name="1044"></a>    /*
<a name="1045"></a>     *   Initialize at run-time startup.  We want to set the zero point as
<a name="1046"></a>     *   the time when the player actually started playing the game (any
<a name="1047"></a>     *   time we spent in pre-initialization doesn't count on the real-time
<a name="1048"></a>     *   clock, since it's not part of the game per se).
<a name="1049"></a>     */
<a name="1050"></a>    execute()
<a name="1051"></a>    {
<a name="1052"></a>        /*
<a name="1053"></a>         *   note the real-time starting point of the game, so we can
<a name="1054"></a>         *   calculate the elapsed game time later
<a name="1055"></a>         */
<a name="1056"></a>        startingTime = getTime(GetTimeTicks);
<a name="1057"></a>    }
<a name="1058"></a>
<a name="1059"></a>    /*
<a name="1060"></a>     *   save the elapsed time so far - this is called just before we save
<a name="1061"></a>     *   a game so that we can pick up where we left off on the elapsed
<a name="1062"></a>     *   time clock when we restore the saved game
<a name="1063"></a>     */
<a name="1064"></a>    saveElapsedTime()
<a name="1065"></a>    {
<a name="1066"></a>        /* remember the elapsed time so far */
<a name="1067"></a>        elapsedTimeAtSave = getElapsedTime();
<a name="1068"></a>    }
<a name="1069"></a>
<a name="1070"></a>    /*
<a name="1071"></a>     *   Restore the elapsed time - this is called just after we restore a
<a name="1072"></a>     *   game.  We'll project the saved elapsed time backwards to figure
<a name="1073"></a>     *   the imaginary starting time the game would have had if it had
<a name="1074"></a>     *   been played in one continuous session rather than being saved and
<a name="1075"></a>     *   restored.
<a name="1076"></a>     */
<a name="1077"></a>    restoreElapsedTime()
<a name="1078"></a>    {
<a name="1079"></a>        /*
<a name="1080"></a>         *   project backwards from the current time by the saved elapsed
<a name="1081"></a>         *   time to get the virtual starting point that will give us the
<a name="1082"></a>         *   same current elapsed time on the system real-time clock
<a name="1083"></a>         */
<a name="1084"></a>        startingTime = getTime(GetTimeTicks) - elapsedTimeAtSave;
<a name="1085"></a>    }
<a name="1086"></a>
<a name="1087"></a>    /* our event list */
<a name="1088"></a>    events_ = static new Vector(20)
<a name="1089"></a>
<a name="1090"></a>    /* the event currently being executed */
<a name="1091"></a>    curEvent_ = nil
<a name="1092"></a>
<a name="1093"></a>    /*
<a name="1094"></a>     *   saved elapsed time - we use this to figure the virtual starting
<a name="1095"></a>     *   time when we restore a saved game
<a name="1096"></a>     */
<a name="1097"></a>    elapsedTimeAtSave = 0
<a name="1098"></a>;
<a name="1099"></a>
<a name="1100"></a>/*
<a name="1101"></a> *   Real-time manager: pre-save notification receiver.  When we're about
<a name="1102"></a> *   to save the game, we'll note the current elapsed game time, so that
<a name="1103"></a> *   when we later restore the game, we can figure the virtual starting
<a name="1104"></a> *   point that will give us the same effective elapsed time on the system
<a name="1105"></a> *   real-time clock.
<a name="1106"></a> */
<a name="1107"></a>PreSaveObject
<a name="1108"></a>    execute()
<a name="1109"></a>    {
<a name="1110"></a>        /*
<a name="1111"></a>         *   remember the elapsed time at the point we saved the game, so
<a name="1112"></a>         *   that we can restore it later
<a name="1113"></a>         */
<a name="1114"></a>        realTimeManager.saveElapsedTime();
<a name="1115"></a>    }
<a name="1116"></a>;
<a name="1117"></a>
<a name="1118"></a>/*
<a name="1119"></a> *   Real-time manager: post-restore notification receiver.  Immediately
<a name="1120"></a> *   after we restore a game, we'll tell the real-time manager to refigure
<a name="1121"></a> *   the virtual starting point of the game based on the saved elapsed
<a name="1122"></a> *   time.
<a name="1123"></a> */
<a name="1124"></a>PostRestoreObject
<a name="1125"></a>    execute()
<a name="1126"></a>    {
<a name="1127"></a>        /* figure the new virtual starting time */
<a name="1128"></a>        realTimeManager.restoreElapsedTime();
<a name="1129"></a>    }
<a name="1130"></a>;
<a name="1131"></a>
<a name="1132"></a>/*
<a name="1133"></a> *   Real-Time Event.  This is an event that occurs according to elapsed
<a name="1134"></a> *   wall-clock time in the real world.
<a name="1135"></a> */
<a name="1136"></a>class RealTimeEvent: BasicEvent
<a name="1137"></a>    /*
<a name="1138"></a>     *   Get the elapsed real time at which this event is triggered.  This
<a name="1139"></a>     *   is a time value in terms of realTimeManager.getElapsedTime().
<a name="1140"></a>     */
<a name="1141"></a>    getEventTime()
<a name="1142"></a>    {
<a name="1143"></a>        /* by default, simply return our eventTime value */
<a name="1144"></a>        return eventTime;
<a name="1145"></a>    }
<a name="1146"></a>
<a name="1147"></a>    /* construction */
<a name="1148"></a>    construct(obj, prop)
<a name="1149"></a>    {
<a name="1150"></a>        /* inherit default handling */
<a name="1151"></a>        inherited(obj, prop);
<a name="1152"></a>
<a name="1153"></a>        /* add myself to the real-time event manager's active list */
<a name="1154"></a>        realTimeManager.addEvent(self);
<a name="1155"></a>    }
<a name="1156"></a>
<a name="1157"></a>    /* remove this event from the real-time event manager */
<a name="1158"></a>    removeEvent() { realTimeManager.removeEvent(self); }
<a name="1159"></a>
<a name="1160"></a>    /* our scheduled event time */
<a name="1161"></a>    eventTime = 0
<a name="1162"></a>;
<a name="1163"></a>
<a name="1164"></a>/*
<a name="1165"></a> *   Real-time fuse.  This is an event that fires once at a specified
<a name="1166"></a> *   elapsed time into the game.
<a name="1167"></a> */
<a name="1168"></a>class RealTimeFuse: RealTimeEvent
<a name="1169"></a>    /*
<a name="1170"></a>     *   Creation.  'delta' is the amount of real time (in milliseconds)
<a name="1171"></a>     *   that should elapse before the fuse is executed.  If 'delta' is
<a name="1172"></a>     *   zero or negative, the fuse will be schedulable immediately.
<a name="1173"></a>     */
<a name="1174"></a>    construct(obj, prop, delta)
<a name="1175"></a>    {
<a name="1176"></a>        /* inherit default handling */
<a name="1177"></a>        inherited(obj, prop);
<a name="1178"></a>
<a name="1179"></a>        /*
<a name="1180"></a>         *   set my scheduled time to the current game elapsed time plus
<a name="1181"></a>         *   the delta - this will give us the time in terms of elapsed
<a name="1182"></a>         *   game time at which we'll be executed
<a name="1183"></a>         */
<a name="1184"></a>        eventTime = realTimeManager.getElapsedTime() + delta;
<a name="1185"></a>    }
<a name="1186"></a>
<a name="1187"></a>    /* execute the fuse */
<a name="1188"></a>    executeEvent()
<a name="1189"></a>    {
<a name="1190"></a>        /* call my method */
<a name="1191"></a>        callMethod();
<a name="1192"></a>
<a name="1193"></a>        /* a fuse fires only once, so remove myself from further scheduling */
<a name="1194"></a>        realTimeManager.removeEvent(self);
<a name="1195"></a>    }
<a name="1196"></a>;
<a name="1197"></a>
<a name="1198"></a>/*
<a name="1199"></a> *   Sensory-context-sensitive real-time fuse.  This is a real-time fuse
<a name="1200"></a> *   with an explicit sensory context.
<a name="1201"></a> */
<a name="1202"></a>class RealTimeSenseFuse: RealTimeFuse
<a name="1203"></a>    construct(obj, prop, delta, source, sense)
<a name="1204"></a>    {
<a name="1205"></a>        /* inherit the base constructor */
<a name="1206"></a>        inherited(obj, prop, delta);
<a name="1207"></a>
<a name="1208"></a>        /* remember our sensory context */
<a name="1209"></a>        source_ = source;
<a name="1210"></a>        sense_ = sense;
<a name="1211"></a>    }
<a name="1212"></a>;
<a name="1213"></a>
<a name="1214"></a>/*
<a name="1215"></a> *   Real-time daemon.  This is an event that occurs repeatedly at given
<a name="1216"></a> *   real-time intervals.  When a daemon is executed, it is scheduled
<a name="1217"></a> *   again for execution after its real-time interval elapses again.  The
<a name="1218"></a> *   daemon's first execution will occur one interval from the time at
<a name="1219"></a> *   which the daemon is created.
<a name="1220"></a> *
<a name="1221"></a> *   If a daemon is executed late (because other, more pressing tasks had
<a name="1222"></a> *   to be completed first, or because the user was busy editing a command
<a name="1223"></a> *   line and the local platform doesn't support real-time command
<a name="1224"></a> *   interruptions), the interval is applied to the time the daemon
<a name="1225"></a> *   actually executed, not to the originally scheduled execution time.
<a name="1226"></a> *   For example, if the daemon is scheduled to run once every minute, but
<a name="1227"></a> *   can't run at all for five minutes because of command editing on a
<a name="1228"></a> *   non-interrupting platform, once it actually does run, it won't run
<a name="1229"></a> *   again for (at least) another minute after that.  This means that the
<a name="1230"></a> *   daemon will not run five times all at once when it's finally allowed
<a name="1231"></a> *   to run - there's no making up for lost time.
<a name="1232"></a> */
<a name="1233"></a>class RealTimeDaemon: RealTimeEvent
<a name="1234"></a>    /*
<a name="1235"></a>     *   Creation.  'interval' is the number of milliseconds between
<a name="1236"></a>     *   invocations.
<a name="1237"></a>     */
<a name="1238"></a>    construct(obj, prop, interval)
<a name="1239"></a>    {
<a name="1240"></a>        /* inherit the base constructor */
<a name="1241"></a>        inherited(obj, prop);
<a name="1242"></a>
<a name="1243"></a>        /* remember my interval */
<a name="1244"></a>        interval_ = interval;
<a name="1245"></a>
<a name="1246"></a>        /*
<a name="1247"></a>         *   figure my initial execution time - wait for one complete
<a name="1248"></a>         *   interval from the current time
<a name="1249"></a>         */
<a name="1250"></a>        eventTime = realTimeManager.getElapsedTime() + interval;
<a name="1251"></a>    }
<a name="1252"></a>
<a name="1253"></a>    /* execute the daemon */
<a name="1254"></a>    executeEvent()
<a name="1255"></a>    {
<a name="1256"></a>        /* call my method */
<a name="1257"></a>        callMethod();
<a name="1258"></a>
<a name="1259"></a>        /*
<a name="1260"></a>         *   Reschedule for next time.  To ensure that we keep to our
<a name="1261"></a>         *   long-term schedule, reschedule based on our original schedule
<a name="1262"></a>         *   time rather than the current clock time; that way, if there
<a name="1263"></a>         *   was a delay after our original scheduled time in firing us,
<a name="1264"></a>         *   we'll make up for it by shortening the interval until the
<a name="1265"></a>         *   next firing.  If that would make us already schedulable, then
<a name="1266"></a>         *   our interval must be so short we can't keep up with it; in
<a name="1267"></a>         *   that case, add the interval to the current clock time.
<a name="1268"></a>         */
<a name="1269"></a>        eventTime += interval_;
<a name="1270"></a>        if (realTimeManager.getElapsedTime() &lt; eventTime)
<a name="1271"></a>            eventTime = realTimeManager.getElapsedTime() + interval_;
<a name="1272"></a>    }
<a name="1273"></a>
<a name="1274"></a>    /* my execution interval, in milliseconds */
<a name="1275"></a>    interval_ = 1
<a name="1276"></a>;
<a name="1277"></a>
<a name="1278"></a>/*
<a name="1279"></a> *   Sensory-context-sensitive real-time daemon - this is a real-time
<a name="1280"></a> *   daemon with an explicit sensory context.  This is the daemon
<a name="1281"></a> *   counterpart of RealTimeSenseFuse.
<a name="1282"></a> */
<a name="1283"></a>class RealTimeSenseDaemon: RealTimeDaemon
<a name="1284"></a>    construct(obj, prop, interval, source, sense)
<a name="1285"></a>    {
<a name="1286"></a>        /* inherit the base constructor */
<a name="1287"></a>        inherited(obj, prop, interval);
<a name="1288"></a>
<a name="1289"></a>        /* remember our sensory context */
<a name="1290"></a>        source_ = source;
<a name="1291"></a>        sense_ = sense;
<a name="1292"></a>    }
<a name="1293"></a>;
<a name="1294"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
