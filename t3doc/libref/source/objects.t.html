<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>objects.t</title></head><body>
<table class=ban><tr><td><h1>objects.t</h1><td align=right><a href="../file/objects.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *.  Portions based on work by Kevin Forchione, used by permission.
<a name="6"></a> *
<a name="7"></a> *   TADS 3 Library - objects
<a name="8"></a> *
<a name="9"></a> *   This module defines the basic physical simulation objects (apart from
<a name="10"></a> *   Thing, the base class for most game objects, which is so large that
<a name="11"></a> *   it's defined in its own separate module for convenience).  We define
<a name="12"></a> *   such basic classes as containers, surfaces, fixed-in-place objects,
<a name="13"></a> *   openables, and lockables.
<a name="14"></a> */
<a name="15"></a>
<a name="16"></a>/* include the library header */
<a name="17"></a>#include "adv3.h"
<a name="18"></a>
<a name="19"></a>
<a name="20"></a>/* ------------------------------------------------------------------------ */
<a name="21"></a>/*
<a name="22"></a> *   LocateInParent - this is a mix-in superclass that defines the location
<a name="23"></a> *   of the object as the object's lexical parent.  This is useful for
<a name="24"></a> *   nested object definitions where the next object should be located
<a name="25"></a> *   within the enclosing object.
<a name="26"></a> *
<a name="27"></a> *   When this class is mixed with Thing or its subclasses, LocateInParent
<a name="28"></a> *   should go first, so that the location we define here takes precedence.
<a name="29"></a> */
<a name="30"></a>class LocateInParent: object
<a name="31"></a>    location = (lexicalParent)
<a name="32"></a>;
<a name="33"></a>
<a name="34"></a>/* ------------------------------------------------------------------------ */
<a name="35"></a>/*
<a name="36"></a> *   Intangible - this is an object that represents something that can be
<a name="37"></a> *   sensed but which has no tangible existence, such as a ray of light, a
<a name="38"></a> *   sound, or an odor.
<a name="39"></a> */
<a name="40"></a>class Intangible: Thing
<a name="41"></a>    /*
<a name="42"></a>     *   The base intangible object has no presence in any sense,
<a name="43"></a>     *   including sight.  Subclasses should override these as appropriate
<a name="44"></a>     *   for the senses in which the object can be sensed.
<a name="45"></a>     */
<a name="46"></a>    sightPresence = nil
<a name="47"></a>    soundPresence = nil
<a name="48"></a>    smellPresence = nil
<a name="49"></a>    touchPresence = nil
<a name="50"></a>
<a name="51"></a>    /* intangibles aren't included in regular room/inventory/contents lists */
<a name="52"></a>    isListed = nil
<a name="53"></a>    isListedInInventory = nil
<a name="54"></a>    isListedInContents = nil
<a name="55"></a>
<a name="56"></a>    /* hide intangibles from 'all' for all actions by default */
<a name="57"></a>    hideFromAll(action) { return true; }
<a name="58"></a>
<a name="59"></a>    /* don't hide from defaults, though */
<a name="60"></a>    hideFromDefault(action) { return nil; }
<a name="61"></a>
<a name="62"></a>    /*
<a name="63"></a>     *   Essentially all verbs are meaningless on intangibles.  Each
<a name="64"></a>     *   subclass should re-enable verbs that are meaningful for that
<a name="65"></a>     *   specific type of intangible; to re-enable an action, just define
<a name="66"></a>     *   a verify() handler for the action.
<a name="67"></a>     *
<a name="68"></a>     *   Note that the verbs we handle via the Default handlers have no
<a name="69"></a>     *   preconditions; since these verbs don't do anything anyway,
<a name="70"></a>     *   there's no need to apply any preconditions to them.
<a name="71"></a>     */
<a name="72"></a>    dobjFor(Default)
<a name="73"></a>    {
<a name="74"></a>        preCond = []
<a name="75"></a>        verify() { illogical(&amp;notWithIntangibleMsg, self); }
<a name="76"></a>    }
<a name="77"></a>    iobjFor(Default)
<a name="78"></a>    {
<a name="79"></a>        preCond = []
<a name="80"></a>        verify() { illogical(&amp;notWithIntangibleMsg, self); }
<a name="81"></a>    }
<a name="82"></a>;
<a name="83"></a>
<a name="84"></a>/*
<a name="85"></a> *   A "vaporous" object is a visible but intangible object: something
<a name="86"></a> *   visible, and possibly with an odor and a sound, but not something that
<a name="87"></a> *   can be touched or otherwise physically manipulated.  Fire, smoke, and
<a name="88"></a> *   fog are examples of this kind of object.
<a name="89"></a> */
<a name="90"></a>class Vaporous: Intangible
<a name="91"></a>    /* we have a sight presence */
<a name="92"></a>    sightPresence = true
<a name="93"></a>
<a name="94"></a>    /*
<a name="95"></a>     *   EXAMINE ALL, LISTEN TO ALL, and SMELL ALL apply to us, but hide
<a name="96"></a>     *   from ALL for other actions, as not much else makes sense on us
<a name="97"></a>     */
<a name="98"></a>    hideFromAll(action)
<a name="99"></a>    {
<a name="100"></a>        return !(action.ofKind(ExamineAction)
<a name="101"></a>                 || action.ofKind(ListenToAction)
<a name="102"></a>                 || action.ofKind(SmellAction));
<a name="103"></a>    }
<a name="104"></a>
<a name="105"></a>    /*
<a name="106"></a>     *   We can examine, smell, and listen to these objects, as normal for
<a name="107"></a>     *   any Thing.  To make these verbs work as normal for Thing, we need
<a name="108"></a>     *   to explicitly override the corresponding verifiers, so that we
<a name="109"></a>     *   bypass the dobjFor(Default) verifier in Intangible.  We don't need
<a name="110"></a>     *   to do anything special in the overrides, so just inherit the
<a name="111"></a>     *   default handling; what's important is that we do override the
<a name="112"></a>     *   methods at all.
<a name="113"></a>     */
<a name="114"></a>    dobjFor(Examine) { verify() { inherited(); } }
<a name="115"></a>    dobjFor(Smell) { verify() { inherited(); } }
<a name="116"></a>    dobjFor(ListenTo) { verify() { inherited(); } }
<a name="117"></a>
<a name="118"></a>    /*
<a name="119"></a>     *   look in, look through, look behind, look under, search: since
<a name="120"></a>     *   vaporous objects are usually essentially transparent, these
<a name="121"></a>     *   commands reveal nothing interesting
<a name="122"></a>     */
<a name="123"></a>    lookInDesc { mainReport(&amp;lookInVaporousMsg, self); }
<a name="124"></a>
<a name="125"></a>    /*
<a name="126"></a>     *   downgrade the likelihood of these slightly, and map everything to
<a name="127"></a>     *   LOOK IN
<a name="128"></a>     */
<a name="129"></a>    dobjFor(LookIn) { verify() { logicalRank(70, 'look in vaporous'); } }
<a name="130"></a>    dobjFor(LookThrough) asDobjFor(LookIn)
<a name="131"></a>    dobjFor(LookBehind) asDobjFor(LookIn)
<a name="132"></a>    dobjFor(LookUnder) asDobjFor(LookIn)
<a name="133"></a>    dobjFor(Search) asDobjFor(LookIn)
<a name="134"></a>
<a name="135"></a>    /* the message we display for commands we disallow */
<a name="136"></a>    notWithIntangibleMsg = &amp;notWithVaporousMsg
<a name="137"></a>;
<a name="138"></a>
<a name="139"></a>
<a name="140"></a>/*
<a name="141"></a> *   A sensory emanation.  This is an intangible object that represents a
<a name="142"></a> *   sound, odor, or the like.
<a name="143"></a> */
<a name="144"></a>class SensoryEmanation: Intangible
<a name="145"></a>    /*
<a name="146"></a>     *   Are we currently emanating our sensory information?  This can be
<a name="147"></a>     *   used as an on/off switch to control when we're active.
<a name="148"></a>     */
<a name="149"></a>    isEmanating = true
<a name="150"></a>
<a name="151"></a>    /*
<a name="152"></a>     *   The description shown when the *source* is examined (with "listen
<a name="153"></a>     *   to", "smell", or whatever verb is appropriate to the type of sense
<a name="154"></a>     *   the subclass involves).  This will also be appended to the regular
<a name="155"></a>     *   "examine" description, if we're not marked as ambient.
<a name="156"></a>     */
<a name="157"></a>    sourceDesc = ""
<a name="158"></a>
<a name="159"></a>    /* our description, with and without being able to see the source */
<a name="160"></a>    descWithSource = ""
<a name="161"></a>    descWithoutSource = ""
<a name="162"></a>
<a name="163"></a>    /*
<a name="164"></a>     *   Our "I am here" message, with and without being able to see the
<a name="165"></a>     *   source.  These are displayed in room descriptions, inventory
<a name="166"></a>     *   descriptions, and by the daemon that schedules background messages
<a name="167"></a>     *   for sensory emanations.
<a name="168"></a>     *
<a name="169"></a>     *   If different messages are desired as the emanation is mentioned
<a name="170"></a>     *   repeatedly while the emanation remains continuously within sense
<a name="171"></a>     *   range of the player character ("A phone is ringing", "The phone is
<a name="172"></a>     *   still ringing", etc), you can do one of two things.  The easier
<a name="173"></a>     *   way is to use a Script object; each time we need to show a
<a name="174"></a>     *   message, we'll invoke the script.  The other way, which is more
<a name="175"></a>     *   manual but gives you greater control, is to write a method that
<a name="176"></a>     *   checks the displayCount property of self to determine which
<a name="177"></a>     *   iteration of the message is being shown.  displayCount is set to 1
<a name="178"></a>     *   the first time a message is displayed for the object when the
<a name="179"></a>     *   object can first be sensed, and is incremented each we invoke one
<a name="180"></a>     *   of these display routines.  Note that displayCount resets to nil
<a name="181"></a>     *   when the object leaves sense scope, so the sequence of messages
<a name="182"></a>     *   will automatically start over each time the object comes back into
<a name="183"></a>     *   scope.
<a name="184"></a>     *
<a name="185"></a>     *   The manual way (writing a method that checks the displayCount)
<a name="186"></a>     *   might be desirable if you want the emanation to fade into the
<a name="187"></a>     *   background gradually as the player character stays in the same
<a name="188"></a>     *   location repeatedly.  This mimics human perception: we notice a
<a name="189"></a>     *   noise or odor most when we first hear it, but if it continues for
<a name="190"></a>     *   an extended period without changing, we'll eventually stop
<a name="191"></a>     *   noticing it.
<a name="192"></a>     */
<a name="193"></a>    hereWithSource = ""
<a name="194"></a>    hereWithoutSource = ""
<a name="195"></a>
<a name="196"></a>    /*
<a name="197"></a>     *   A message to display when the emanation ceases to be within sense
<a name="198"></a>     *   range.  In most cases, this displays nothing at all, but some
<a name="199"></a>     *   emanations might want to note explicitly when the noise/etc
<a name="200"></a>     *   stops.
<a name="201"></a>     */
<a name="202"></a>    noLongerHere = ""
<a name="203"></a>
<a name="204"></a>    /*
<a name="205"></a>     *   Flag: I'm an "ambient" emanation.  This means we essentially are
<a name="206"></a>     *   part of the background, and are not worth mentioning in our own
<a name="207"></a>     *   right.  If this is set to true, then we won't mention this
<a name="208"></a>     *   emanation at all when it first becomes reachable in its sense.
<a name="209"></a>     *   This should be used for background noises and the like: we won't
<a name="210"></a>     *   ever make an unsolicited mention of them, but they'll still show
<a name="211"></a>     *   up in explicit 'listen' commands and so on.
<a name="212"></a>     */
<a name="213"></a>    isAmbient = nil
<a name="214"></a>
<a name="215"></a>    /*
<a name="216"></a>     *   The schedule for displaying messages about the emanation.  This
<a name="217"></a>     *   is a list of intervals between messages, in game clock times.
<a name="218"></a>     *   When the player character can repeatedly sense this emanation for
<a name="219"></a>     *   multiple consecutive turns, we'll use this schedule to display
<a name="220"></a>     *   messages periodically about the noise/odor/etc.
<a name="221"></a>     *
<a name="222"></a>     *   Human sensory perception tends to be "edge-sensitive," which
<a name="223"></a>     *   means that we tend to perceive sensory input most acutely when
<a name="224"></a>     *   something changes.  When a sound or odor is continually present
<a name="225"></a>     *   without variation for an extended period, it tends to fade into
<a name="226"></a>     *   the background of our awareness, so that even though it remains
<a name="227"></a>     *   audible, we gradually stop noticing it.  This message display
<a name="228"></a>     *   schedule mechanism is meant to approximate this perceptual model
<a name="229"></a>     *   by allowing the sensory emanation to specify how noticeable the
<a name="230"></a>     *   emanation remains during continuous exposure.  Typically, a
<a name="231"></a>     *   continuous emanation would have relatively frequent messages
<a name="232"></a>     *   (every two turns, say) for a couple of iterations, then would
<a name="233"></a>     *   switch to infrequent messages.  Emanations that are analogous to
<a name="234"></a>     *   white noise would probably not be mentioned at all after the
<a name="235"></a>     *   first couple of messages, because the human senses are especially
<a name="236"></a>     *   given to treating such input as background.
<a name="237"></a>     *
<a name="238"></a>     *   We use this list by applying each interval in the list once and
<a name="239"></a>     *   then moving to the next entry in the list.  The first entry in
<a name="240"></a>     *   the list is the interval between first sensing the emanation and
<a name="241"></a>     *   displaying the first "still here" message.  When we reach the end
<a name="242"></a>     *   of the list, we simply repeat the last interval in the list
<a name="243"></a>     *   indefinitely.  If the last entry in the list is nil, though, we
<a name="244"></a>     *   simply never produce another message.
<a name="245"></a>     */
<a name="246"></a>    displaySchedule = [nil]
<a name="247"></a>
<a name="248"></a>    /*
<a name="249"></a>     *   Show our "I am here" description.  This is the description shown
<a name="250"></a>     *   as part of our room's description.  We show our hereWithSource or
<a name="251"></a>     *   hereWithoutSource message, according to whether or not we can see
<a name="252"></a>     *   the source object.
<a name="253"></a>     */
<a name="254"></a>    emanationHereDesc()
<a name="255"></a>    {
<a name="256"></a>        local actor;
<a name="257"></a>        local prop;
<a name="258"></a>
<a name="259"></a>        /* if we're not currently emanating, there's nothing to do */
<a name="260"></a>        if (!isEmanating)
<a name="261"></a>            return;
<a name="262"></a>
<a name="263"></a>        /* note that we're mentioning the emanation */
<a name="264"></a>        noteDisplay();
<a name="265"></a>
<a name="266"></a>        /*
<a name="267"></a>         *   get the actor driving the description - if there's a command
<a name="268"></a>         *   active, use the command's actor; otherwise use the player
<a name="269"></a>         *   character
<a name="270"></a>         */
<a name="271"></a>        if ((actor = gActor) == nil)
<a name="272"></a>            actor = gPlayerChar;
<a name="273"></a>
<a name="274"></a>        /* our display varies according to our source's visibility */
<a name="275"></a>        prop = (canSeeSource(actor) ? &amp;hereWithSource : &amp;hereWithoutSource);
<a name="276"></a>
<a name="277"></a>        /*
<a name="278"></a>         *   if it's a Script object, invoke the script; otherwise, just
<a name="279"></a>         *   invoke the property
<a name="280"></a>         */
<a name="281"></a>        if (propType(prop) == TypeObject &amp;&amp; self.(prop).ofKind(Script))
<a name="282"></a>            self.(prop).doScript();
<a name="283"></a>        else
<a name="284"></a>            self.(prop);
<a name="285"></a>    }
<a name="286"></a>
<a name="287"></a>    /*
<a name="288"></a>     *   Show a message describing that we cannot see the source of this
<a name="289"></a>     *   emanation because the given obstructor is in the way.  This
<a name="290"></a>     *   should be overridden for each subclass.
<a name="291"></a>     */
<a name="292"></a>    cannotSeeSource(obs) { }
<a name="293"></a>
<a name="294"></a>    /*
<a name="295"></a>     *   Get the source of the noise/odor/whatever, as perceived by the
<a name="296"></a>     *   current actor.  This is the object we appear to be coming from.
<a name="297"></a>     *   By default, an emanation is generated by its direct container,
<a name="298"></a>     *   and by default this is apparent to actors, so we'll simply return
<a name="299"></a>     *   our direct container.
<a name="300"></a>     *
<a name="301"></a>     *   If the source is not apparent, this should simply return nil.
<a name="302"></a>     */
<a name="303"></a>    getSource() { return location; }
<a name="304"></a>
<a name="305"></a>    /* determine if our source is apparent and visible */
<a name="306"></a>    canSeeSource(actor)
<a name="307"></a>    {
<a name="308"></a>        local src;
<a name="309"></a>
<a name="310"></a>        /* get our source */
<a name="311"></a>        src = getSource();
<a name="312"></a>
<a name="313"></a>        /*
<a name="314"></a>         *   return true if we have an apparent source, and the apparent
<a name="315"></a>         *   source is visible to the current actor
<a name="316"></a>         */
<a name="317"></a>        return src != nil &amp;&amp; actor.canSee(src);
<a name="318"></a>    }
<a name="319"></a>
<a name="320"></a>    /*
<a name="321"></a>     *   Note that we're displaying a message about the emanation.  This
<a name="322"></a>     *   method should be called any time a message about the emanation is
<a name="323"></a>     *   displayed, either by an explicit action or by our background
<a name="324"></a>     *   daemon.
<a name="325"></a>     *
<a name="326"></a>     *   We'll adjust our next display time so that we wait the full
<a name="327"></a>     *   interval at the current point in the display schedule before we
<a name="328"></a>     *   show any background message about this object.  Note we do not
<a name="329"></a>     *   advance through the schedule list; instead, we merely delay any
<a name="330"></a>     *   further message by the interval at the current point in the
<a name="331"></a>     *   schedule list.
<a name="332"></a>     */
<a name="333"></a>    noteDisplay()
<a name="334"></a>    {
<a name="335"></a>        /* calculate our next display time */
<a name="336"></a>        calcNextDisplayTime();
<a name="337"></a>
<a name="338"></a>        /* count the display */
<a name="339"></a>        if (displayCount == nil)
<a name="340"></a>            displayCount = 1;
<a name="341"></a>        else
<a name="342"></a>            ++displayCount;
<a name="343"></a>    }
<a name="344"></a>
<a name="345"></a>    /*
<a name="346"></a>     *   Note an indirect message about the emanation.  This can be used
<a name="347"></a>     *   when we don't actually display a message ourselves, but another
<a name="348"></a>     *   object (usually our source object) describes the emanation; for
<a name="349"></a>     *   example, if our source object mentions the noise it's making when
<a name="350"></a>     *   it is examined, it should call this method to let us know we have
<a name="351"></a>     *   been described indirectly.  This method advances our next display
<a name="352"></a>     *   time, just as noteDisplay() does, but this method doesn't count
<a name="353"></a>     *   the display as a direct display.
<a name="354"></a>     */
<a name="355"></a>    noteIndirectDisplay()
<a name="356"></a>    {
<a name="357"></a>        /* calculate our next display time */
<a name="358"></a>        calcNextDisplayTime();
<a name="359"></a>    }
<a name="360"></a>
<a name="361"></a>    /*
<a name="362"></a>     *   Begin the emanation.  This is called from the sense change daemon
<a name="363"></a>     *   when the item first becomes noticeable to the player character -
<a name="364"></a>     *   for example, when the player character first enters the room
<a name="365"></a>     *   containing the emanation, or when the emanation is first
<a name="366"></a>     *   activated.
<a name="367"></a>     */
<a name="368"></a>    startEmanation()
<a name="369"></a>    {
<a name="370"></a>        /* if we're an ambient emanation only, don't mention it */
<a name="371"></a>        if (isAmbient)
<a name="372"></a>            return;
<a name="373"></a>
<a name="374"></a>        /*
<a name="375"></a>         *   if we've already initialized our scheduling, we must have
<a name="376"></a>         *   been explicitly mentioned, such as by a room description - in
<a name="377"></a>         *   this case, act as though we're continuing our emanation
<a name="378"></a>         */
<a name="379"></a>        if (scheduleIndex != nil)
<a name="380"></a>        {
<a name="381"></a>            continueEmanation();
<a name="382"></a>            return;
<a name="383"></a>        }
<a name="384"></a>
<a name="385"></a>        /* show our message */
<a name="386"></a>        emanationHereDesc;
<a name="387"></a>    }
<a name="388"></a>
<a name="389"></a>    /*
<a name="390"></a>     *   Continue the emanation.  This is called on each turn in which the
<a name="391"></a>     *   emanation remains continuously within sense range of the player
<a name="392"></a>     *   character.
<a name="393"></a>     */
<a name="394"></a>    continueEmanation()
<a name="395"></a>    {
<a name="396"></a>        /*
<a name="397"></a>         *   if we are not to run again, our next display time will be set
<a name="398"></a>         *   to zero - do nothing in this case
<a name="399"></a>         */
<a name="400"></a>        if (nextDisplayTime == 0 || nextDisplayTime == nil)
<a name="401"></a>            return;
<a name="402"></a>
<a name="403"></a>        /* if we haven't yet reached our next display time, do nothing */
<a name="404"></a>        if (Schedulable.gameClockTime &lt; nextDisplayTime)
<a name="405"></a>            return;
<a name="406"></a>
<a name="407"></a>        /*
<a name="408"></a>         *   Advance to the next schedule interval, if we have one.  If
<a name="409"></a>         *   we're already on the last schedule entry, simply repeat it
<a name="410"></a>         *   forever.
<a name="411"></a>         */
<a name="412"></a>        if (scheduleIndex &lt; displaySchedule.length())
<a name="413"></a>            ++scheduleIndex;
<a name="414"></a>
<a name="415"></a>        /* show our description */
<a name="416"></a>        emanationHereDesc;
<a name="417"></a>    }
<a name="418"></a>
<a name="419"></a>    /*
<a name="420"></a>     *   End the emanation.  This is called when the player character can
<a name="421"></a>     *   no longer sense the emanation.
<a name="422"></a>     */
<a name="423"></a>    endEmanation()
<a name="424"></a>    {
<a name="425"></a>        /* show our "no longer here" message */
<a name="426"></a>        noLongerHere;
<a name="427"></a>
<a name="428"></a>        /* uninitialize the display scheduling */
<a name="429"></a>        scheduleIndex = nil;
<a name="430"></a>        nextDisplayTime = nil;
<a name="431"></a>
<a name="432"></a>        /* reset the display count */
<a name="433"></a>        displayCount = nil;
<a name="434"></a>    }
<a name="435"></a>
<a name="436"></a>    /*
<a name="437"></a>     *   Calculate our next display time.  The caller must set our
<a name="438"></a>     *   scheduleIndex to the correct index prior to calling this.
<a name="439"></a>     */
<a name="440"></a>    calcNextDisplayTime()
<a name="441"></a>    {
<a name="442"></a>        local delta;
<a name="443"></a>
<a name="444"></a>        /* if our scheduling isn't initialized, set it up now */
<a name="445"></a>        if (scheduleIndex == nil)
<a name="446"></a>        {
<a name="447"></a>            /* start at the first display schedule interval */
<a name="448"></a>            scheduleIndex = 1;
<a name="449"></a>        }
<a name="450"></a>
<a name="451"></a>        /* get the next display interval from the schedule list */
<a name="452"></a>        delta = displaySchedule[scheduleIndex];
<a name="453"></a>
<a name="454"></a>        /*
<a name="455"></a>         *   if the current display interval is nil, it means that we're
<a name="456"></a>         *   never to display another message
<a name="457"></a>         */
<a name="458"></a>        if (delta == nil)
<a name="459"></a>        {
<a name="460"></a>            /*
<a name="461"></a>             *   we're not to display again - simply set the next display
<a name="462"></a>             *   time to zero and return
<a name="463"></a>             */
<a name="464"></a>            nextDisplayTime = 0;
<a name="465"></a>            return;
<a name="466"></a>        }
<a name="467"></a>
<a name="468"></a>        /*
<a name="469"></a>         *   our next display time is the current game clock time plus the
<a name="470"></a>         *   interval
<a name="471"></a>         */
<a name="472"></a>        nextDisplayTime = Schedulable.gameClockTime + delta;
<a name="473"></a>    }
<a name="474"></a>
<a name="475"></a>    /*
<a name="476"></a>     *   Internal counters that keep track of our display scheduling.
<a name="477"></a>     *   scheduleIndex is the index in the displaySchedule list of the
<a name="478"></a>     *   interval we're waiting to expire; nextDisplayTime is the game
<a name="479"></a>     *   clock time of our next display.  noiseList and odorList are lists
<a name="480"></a>     *   of senseInfo entries for the sound and smell senses,
<a name="481"></a>     *   respectively, indicating which objects were within sense range on
<a name="482"></a>     *   the last turn.  displayCount is the number of times in a row
<a name="483"></a>     *   we've displayed a message already.
<a name="484"></a>     */
<a name="485"></a>    scheduleIndex = nil
<a name="486"></a>    nextDisplayTime = nil
<a name="487"></a>    noiseList = nil
<a name="488"></a>    odorList = nil
<a name="489"></a>    displayCount = nil
<a name="490"></a>
<a name="491"></a>    /*
<a name="492"></a>     *   Class method implementing the sensory change daemon.  This runs
<a name="493"></a>     *   on each turn to check for changes in the set of objects the
<a name="494"></a>     *   player can hear and smell, and to generate "still here" messages
<a name="495"></a>     *   for objects continuously within sense range for multiple turns.
<a name="496"></a>     */
<a name="497"></a>    noteSenseChanges()
<a name="498"></a>    {
<a name="499"></a>        /* emanations don't change anything, so turn on caching */
<a name="500"></a>        libGlobal.enableSenseCache();
<a name="501"></a>
<a name="502"></a>        /* note sound changes */
<a name="503"></a>        noteSenseChangesFor(sound, &amp;noiseList, Noise);
<a name="504"></a>
<a name="505"></a>        /* note odor changes */
<a name="506"></a>        noteSenseChangesFor(smell, &amp;odorList, Odor);
<a name="507"></a>
<a name="508"></a>        /* done with sense caching */
<a name="509"></a>        libGlobal.disableSenseCache();
<a name="510"></a>    }
<a name="511"></a>
<a name="512"></a>    /*
<a name="513"></a>     *   Note sense changes for a particular sense.  'listProp' is the
<a name="514"></a>     *   property of SensoryEmanation giving the list of SenseInfo entries
<a name="515"></a>     *   for the sense on the previous turn.  'sub' is a subclass of ours
<a name="516"></a>     *   (such as Noise) giving the type of sensory emanation used for
<a name="517"></a>     *   this sense.
<a name="518"></a>     */
<a name="519"></a>    noteSenseChangesFor(sense, listProp, sub)
<a name="520"></a>    {
<a name="521"></a>        local newInfo;
<a name="522"></a>        local oldInfo;
<a name="523"></a>
<a name="524"></a>        /* get the old table of SenseInfo entries for the sense */
<a name="525"></a>        oldInfo = self.(listProp);
<a name="526"></a>
<a name="527"></a>        /*
<a name="528"></a>         *   Get the new table of items we can reach in the given sense,
<a name="529"></a>         *   and reduce it to include only emanations of the subclass of
<a name="530"></a>         *   interest.
<a name="531"></a>         */
<a name="532"></a>        newInfo = gPlayerChar.senseInfoTable(sense);
<a name="533"></a>        newInfo.forEachAssoc(function(obj, info)
<a name="534"></a>        {
<a name="535"></a>            /*
<a name="536"></a>             *   remove this item if it's not of the subclass of interest,
<a name="537"></a>             *   or if it's not currently emanating
<a name="538"></a>             */
<a name="539"></a>            if (!obj.ofKind(sub) || !obj.isEmanating)
<a name="540"></a>                newInfo.removeElement(obj);
<a name="541"></a>        });
<a name="542"></a>
<a name="543"></a>        /* run through the new list and note each change */
<a name="544"></a>        newInfo.forEachAssoc(function(obj, info)
<a name="545"></a>        {
<a name="546"></a>            /* treat this as a new command visually */
<a name="547"></a>            "&lt;.commandsep&gt;";
<a name="548"></a>
<a name="549"></a>            /*
<a name="550"></a>             *   Check to see whether the item is starting anew or was
<a name="551"></a>             *   already here on the last turn.  If the item was in our
<a name="552"></a>             *   list from the previous turn, it was already here.
<a name="553"></a>             */
<a name="554"></a>            if (oldInfo == nil || oldInfo[obj] == nil)
<a name="555"></a>            {
<a name="556"></a>                /*
<a name="557"></a>                 *   the item wasn't in sense range on the last turn, so
<a name="558"></a>                 *   it is becoming newly noticeable
<a name="559"></a>                 */
<a name="560"></a>                obj.startEmanation();
<a name="561"></a>            }
<a name="562"></a>            else
<a name="563"></a>            {
<a name="564"></a>                /* the item was already here - continue its emanation */
<a name="565"></a>                obj.continueEmanation();
<a name="566"></a>            }
<a name="567"></a>        });
<a name="568"></a>
<a name="569"></a>        /* run through the old list and note each item no longer sensed */
<a name="570"></a>        if (oldInfo != nil)
<a name="571"></a>        {
<a name="572"></a>            oldInfo.forEachAssoc(function(obj, info)
<a name="573"></a>            {
<a name="574"></a>                /* if this item isn't in the new list, note its departure */
<a name="575"></a>                if (newInfo[obj] == nil)
<a name="576"></a>                {
<a name="577"></a>                    /* treat this as a new command visually */
<a name="578"></a>                    "&lt;.commandsep&gt;";
<a name="579"></a>
<a name="580"></a>                    /* note the departure */
<a name="581"></a>                    obj.endEmanation();
<a name="582"></a>                }
<a name="583"></a>            });
<a name="584"></a>        }
<a name="585"></a>
<a name="586"></a>        /* store the current list for comparison the next time we run */
<a name="587"></a>        self.(listProp) = newInfo;
<a name="588"></a>    }
<a name="589"></a>
<a name="590"></a>    /*
<a name="591"></a>     *   Examine the sensory emanation.  We'll show our descWithSource or
<a name="592"></a>     *   descWithoutSource, according to whether or not we can see the
<a name="593"></a>     *   source object.
<a name="594"></a>     */
<a name="595"></a>    dobjFor(Examine)
<a name="596"></a>    {
<a name="597"></a>        verify() { inherited(); }
<a name="598"></a>        action()
<a name="599"></a>        {
<a name="600"></a>            /* note that we're displaying a message about us */
<a name="601"></a>            noteDisplay();
<a name="602"></a>
<a name="603"></a>            /* display our sound description */
<a name="604"></a>            if (canSeeSource(gActor))
<a name="605"></a>            {
<a name="606"></a>                /* we can see the source */
<a name="607"></a>                descWithSource;
<a name="608"></a>            }
<a name="609"></a>            else
<a name="610"></a>            {
<a name="611"></a>                local src;
<a name="612"></a>
<a name="613"></a>                /* show the unseen-source version of the description */
<a name="614"></a>                descWithoutSource;
<a name="615"></a>
<a name="616"></a>                /*
<a name="617"></a>                 *   If we have a source, find out what's keeping us from
<a name="618"></a>                 *   seeing the source; in other words, find the opaque
<a name="619"></a>                 *   visual obstructor on the sense path to the source.
<a name="620"></a>                 */
<a name="621"></a>                if ((src = getSource()) != nil)
<a name="622"></a>                {
<a name="623"></a>                    local obs;
<a name="624"></a>
<a name="625"></a>                    /* get the visual obstructor */
<a name="626"></a>                    obs = gActor.findVisualObstructor(src);
<a name="627"></a>
<a name="628"></a>                    /*
<a name="629"></a>                     *   If we found an obstructor, and we can see it, add
<a name="630"></a>                     *   a message describing the obstruction.  If we
<a name="631"></a>                     *   can't see the obstructor, we can't localize the
<a name="632"></a>                     *   sensory emanation at all.
<a name="633"></a>                     */
<a name="634"></a>                    if (obs != nil &amp;&amp; gActor.canSee(obs))
<a name="635"></a>                        cannotSeeSource(obs);
<a name="636"></a>                }
<a name="637"></a>            }
<a name="638"></a>        }
<a name="639"></a>    }
<a name="640"></a>;
<a name="641"></a>
<a name="642"></a>/*
<a name="643"></a> *   Noise - this is an intangible object representing a sound.
<a name="644"></a> *
<a name="645"></a> *   A Noise object is generally placed directly within the object that is
<a name="646"></a> *   generating the noise.  This will ensure that the noise is
<a name="647"></a> *   automatically in scope whenever the object is in scope (or, more
<a name="648"></a> *   precisely, whenever the object's contents are in scope) and with the
<a name="649"></a> *   same sense attributes.
<a name="650"></a> *
<a name="651"></a> *   By default, when a noise is specifically examined via "listen to",
<a name="652"></a> *   and the container is visible, we'll mention that the noise is coming
<a name="653"></a> *   from the container.
<a name="654"></a> */
<a name="655"></a>class Noise: SensoryEmanation
<a name="656"></a>    /*
<a name="657"></a>     *   by default, we have a definite presence in the sound sense if
<a name="658"></a>     *   we're emanating our noise
<a name="659"></a>     */
<a name="660"></a>    soundPresence = (isEmanating)
<a name="661"></a>
<a name="662"></a>    /*
<a name="663"></a>     *   By default, a noise is listed in a room description (i.e., on LOOK
<a name="664"></a>     *   or entry to a room) unless it's an ambient background noise..  Set
<a name="665"></a>     *   this to nil to omit the noise from the room description, while
<a name="666"></a>     *   still allowing it to be heard in an explicit LISTEN command.
<a name="667"></a>     */
<a name="668"></a>    isSoundListedInRoom = (!isAmbient &amp;&amp; isEmanating)
<a name="669"></a>
<a name="670"></a>    /* show our description as part of a room description */
<a name="671"></a>    soundHereDesc() { emanationHereDesc(); }
<a name="672"></a>
<a name="673"></a>    /* explain that we can't see the source because of the obstructor */
<a name="674"></a>    cannotSeeSource(obs) { obs.cannotSeeSoundSource(self); }
<a name="675"></a>
<a name="676"></a>    /* treat "listen to" the same as "examine" */
<a name="677"></a>    dobjFor(ListenTo) asDobjFor(Examine)
<a name="678"></a>
<a name="679"></a>    /* "examine" requires that the object is audible */
<a name="680"></a>    dobjFor(Examine)
<a name="681"></a>    {
<a name="682"></a>        preCond = [objAudible]
<a name="683"></a>    }
<a name="684"></a>;
<a name="685"></a>
<a name="686"></a>/*
<a name="687"></a> *   Odor - this is an intangible object representing an odor.
<a name="688"></a> */
<a name="689"></a>class Odor: SensoryEmanation
<a name="690"></a>    /*
<a name="691"></a>     *   by default, we have a definite presence in the smell sense if
<a name="692"></a>     *   we're currently emanating our odor
<a name="693"></a>     */
<a name="694"></a>    smellPresence = (isEmanating)
<a name="695"></a>
<a name="696"></a>    /*
<a name="697"></a>     *   By default, an odor is listed in a room description (i.e., on LOOK
<a name="698"></a>     *   or entry to a room) unless it's an ambient background odor.  Set
<a name="699"></a>     *   this to nil to omit the odor from the room description, while
<a name="700"></a>     *   still allowing it to be listed in an explicit SMELL command.
<a name="701"></a>     */
<a name="702"></a>    isSmellListedInRoom = (!isAmbient &amp;&amp; isEmanating)
<a name="703"></a>
<a name="704"></a>    /* mention the odor as part of a room description */
<a name="705"></a>    smellHereDesc() { emanationHereDesc(); }
<a name="706"></a>
<a name="707"></a>    /* explain that we can't see the source because of the obstructor */
<a name="708"></a>    cannotSeeSource(obs) { obs.cannotSeeSmellSource(self); }
<a name="709"></a>
<a name="710"></a>    /* handle "smell" using our "examine" handler */
<a name="711"></a>    dobjFor(Smell) asDobjFor(Examine)
<a name="712"></a>
<a name="713"></a>    /* "examine" requires that the object is smellable */
<a name="714"></a>    dobjFor(Examine)
<a name="715"></a>    {
<a name="716"></a>        preCond = [objSmellable]
<a name="717"></a>    }
<a name="718"></a>;
<a name="719"></a>
<a name="720"></a>/*
<a name="721"></a> *   SimpleNoise is for cases where a noise is an ongoing part of a
<a name="722"></a> *   location, so (1) it's not necessary to distinguish source and
<a name="723"></a> *   sourceless versions of the description, and (2) there are no
<a name="724"></a> *   scheduled reports for the noise.  For these cases, all of the
<a name="725"></a> *   messages default to the basic 'desc' property.  Note that we make
<a name="726"></a> *   this type of noise "ambient" by default, which means that we won't
<a name="727"></a> *   automatically include it in room descriptions.
<a name="728"></a> */
<a name="729"></a>class SimpleNoise: Noise
<a name="730"></a>    isAmbient = true
<a name="731"></a>    sourceDesc { desc; }
<a name="732"></a>    descWithSource { desc; }
<a name="733"></a>    descWithoutSource { desc; }
<a name="734"></a>    hereWithSource { desc; }
<a name="735"></a>    hereWithoutSource { desc; }
<a name="736"></a>;
<a name="737"></a>
<a name="738"></a>/* SimpleOdor is the olfactory equivalent of SimpleNoise */
<a name="739"></a>class SimpleOdor: Odor
<a name="740"></a>    isAmbient = true
<a name="741"></a>    sourceDesc { desc; }
<a name="742"></a>    descWithSource { desc; }
<a name="743"></a>    descWithoutSource { desc; }
<a name="744"></a>    hereWithSource { desc; }
<a name="745"></a>    hereWithoutSource { desc; }
<a name="746"></a>;
<a name="747"></a>
<a name="748"></a>/* ------------------------------------------------------------------------ */
<a name="749"></a>/*
<a name="750"></a> *   Sensory Event.  This is an object representing a transient event,
<a name="751"></a> *   such as a sound, visual display, or odor, to which some objects
<a name="752"></a> *   observing the event might react.
<a name="753"></a> *
<a name="754"></a> *   A sensory event differs from a sensory emanation in that an emanation
<a name="755"></a> *   is ongoing and passive, while an event is isolated in time and
<a name="756"></a> *   actively notifies observers.
<a name="757"></a> */
<a name="758"></a>class SensoryEvent: object
<a name="759"></a>    /*
<a name="760"></a>     *   Trigger the event.  This routine must be called at the time when
<a name="761"></a>     *   the event is to occur.  We'll notify every interested observer
<a name="762"></a>     *   capable of sensing the event that the event is occurring, so
<a name="763"></a>     *   observers can take appropriate action in response to the event.
<a name="764"></a>     *
<a name="765"></a>     *   'source' is the source object - this is the physical object in
<a name="766"></a>     *   the simulation that is causing the event.  For example, if the
<a name="767"></a>     *   event is the sound of a phone ringing, the phone would probably
<a name="768"></a>     *   be the source object.  The source is used to determine which
<a name="769"></a>     *   observers are capable of detecting the event: an observer must be
<a name="770"></a>     *   able to sense the source object in the appropriate sense to be
<a name="771"></a>     *   notified of the event.
<a name="772"></a>     */
<a name="773"></a>    triggerEvent(source)
<a name="774"></a>    {
<a name="775"></a>        /*
<a name="776"></a>         *   Run through all objects connected to the source object by
<a name="777"></a>         *   containment, and notify any that are interested and can
<a name="778"></a>         *   detect the event.  Containment is the only way sense
<a name="779"></a>         *   information can propagate, so we can limit our search
<a name="780"></a>         *   accordingly.
<a name="781"></a>         *
<a name="782"></a>         *   Connection by containment is no guarantee of a sense
<a name="783"></a>         *   connection: it's a necessary, but not sufficient, condition.
<a name="784"></a>         *   Because it's a necessary condition, though, we can use it to
<a name="785"></a>         *   limit the number of objects we have to test with a more
<a name="786"></a>         *   expensive sense path calculation.
<a name="787"></a>         */
<a name="788"></a>        source.connectionTable().forEachAssoc(function(cur, val)
<a name="789"></a>        {
<a name="790"></a>            /*
<a name="791"></a>             *   If this object defines the observer notification method,
<a name="792"></a>             *   then it might be interested in the event.  If the object
<a name="793"></a>             *   doesn't define this method, then there's no way it could
<a name="794"></a>             *   be interested.  (We make this test before checking the
<a name="795"></a>             *   sense path because checking to see if an object defines a
<a name="796"></a>             *   property is fast and simple, while the sense path
<a name="797"></a>             *   calculation could be expensive.)
<a name="798"></a>             */
<a name="799"></a>            if (cur.propDefined(notifyProp, PropDefAny))
<a name="800"></a>            {
<a name="801"></a>                local info;
<a name="802"></a>
<a name="803"></a>                /*
<a name="804"></a>                 *   This object might be interested in the event, so
<a name="805"></a>                 *   check to see if the object can sense the event.  If
<a name="806"></a>                 *   this object can sense the source object at all (i.e.,
<a name="807"></a>                 *   the sense path isn't 'opaque'), then notify the
<a name="808"></a>                 *   object of the event.
<a name="809"></a>                 */
<a name="810"></a>                info = cur.senseObj(sense, source);
<a name="811"></a>                if (info.trans != opaque)
<a name="812"></a>                {
<a name="813"></a>                    /*
<a name="814"></a>                     *   this observer object can sense the source of the
<a name="815"></a>                     *   event, so notify it of the event
<a name="816"></a>                     */
<a name="817"></a>                    cur.(notifyProp)(self, source, info);
<a name="818"></a>                }
<a name="819"></a>            }
<a name="820"></a>        });
<a name="821"></a>    }
<a name="822"></a>
<a name="823"></a>    /* the sense in which the event is observable */
<a name="824"></a>    sense = nil
<a name="825"></a>
<a name="826"></a>    /*
<a name="827"></a>     *   the notification property - this is the property we'll invoke on
<a name="828"></a>     *   each observer to notify it of the event
<a name="829"></a>     */
<a name="830"></a>    notifyProp = nil
<a name="831"></a>;
<a name="832"></a>
<a name="833"></a>/*
<a name="834"></a> *   Visual event
<a name="835"></a> */
<a name="836"></a>class SightEvent: SensoryEvent
<a name="837"></a>    sense = sight
<a name="838"></a>    notifyProp = &amp;notifySightEvent
<a name="839"></a>;
<a name="840"></a>
<a name="841"></a>/*
<a name="842"></a> *   Visual event observer.  This is a mix-in that can be added to any
<a name="843"></a> *   other classes.
<a name="844"></a> */
<a name="845"></a>class SightObserver: object
<a name="846"></a>    /*
<a name="847"></a>     *   Receive notification of a sight event.  This routine is called
<a name="848"></a>     *   whenever a SightEvent occurs within view of this object.
<a name="849"></a>     *
<a name="850"></a>     *   'event' is the SightEvent object; 'source' is the physical
<a name="851"></a>     *   simulation object that is making the visual display; and 'info'
<a name="852"></a>     *   is a SenseInfo object describing the viewing conditions from this
<a name="853"></a>     *   object to the source object.
<a name="854"></a>     */
<a name="855"></a>    notifySightEvent(event, source, info) { }
<a name="856"></a>;
<a name="857"></a>
<a name="858"></a>/*
<a name="859"></a> *   Sound event
<a name="860"></a> */
<a name="861"></a>class SoundEvent: SensoryEvent
<a name="862"></a>    sense = sound
<a name="863"></a>    notifyProp = &amp;notifySoundEvent
<a name="864"></a>;
<a name="865"></a>
<a name="866"></a>/*
<a name="867"></a> *   Sound event observer.  This is a mix-in that can be added to any
<a name="868"></a> *   other classes.
<a name="869"></a> */
<a name="870"></a>class SoundObserver: object
<a name="871"></a>    /*
<a name="872"></a>     *   Receive notification of a sound event.  This routine is called
<a name="873"></a>     *   whenever a SoundEvent occurs within hearing range of this object.
<a name="874"></a>     */
<a name="875"></a>    notifySoundEvent(event, source, info) { }
<a name="876"></a>;
<a name="877"></a>
<a name="878"></a>/*
<a name="879"></a> *   Smell event
<a name="880"></a> */
<a name="881"></a>class SmellEvent: SensoryEvent
<a name="882"></a>    sense = smell
<a name="883"></a>    notifyProp = &amp;notifySmellEvent
<a name="884"></a>;
<a name="885"></a>
<a name="886"></a>/*
<a name="887"></a> *   Smell event observer.  This is a mix-in that can be added to any
<a name="888"></a> *   other classes.
<a name="889"></a> */
<a name="890"></a>class SmellObserver: object
<a name="891"></a>    /*
<a name="892"></a>     *   Receive notification of a smell event.  This routine is called
<a name="893"></a>     *   whenever a SmellEvent occurs within smelling range of this
<a name="894"></a>     *   object.
<a name="895"></a>     */
<a name="896"></a>    notifySmellEvent(event, source, info) { }
<a name="897"></a>;
<a name="898"></a>
<a name="899"></a>
<a name="900"></a>/* ------------------------------------------------------------------------ */
<a name="901"></a>/*
<a name="902"></a> *   Hidden - this is an object that's present but not visible to any
<a name="903"></a> *   actors.  The object will simply not be visible in the 'sight' sense
<a name="904"></a> *   until discovered.
<a name="905"></a> */
<a name="906"></a>class Hidden: Thing
<a name="907"></a>    /* we can't be seen until discovered */
<a name="908"></a>    canBeSensed(sense, trans, ambient)
<a name="909"></a>    {
<a name="910"></a>        /*
<a name="911"></a>         *   If the sense is sight, and we haven't been discovered yet, we
<a name="912"></a>         *   cannot be sensed.  Otherwise, inherit the normal handling.
<a name="913"></a>         */
<a name="914"></a>        if (sense == sight &amp;&amp; !discovered)
<a name="915"></a>            return nil;
<a name="916"></a>        else
<a name="917"></a>            return inherited(sense, trans, ambient);
<a name="918"></a>    }
<a name="919"></a>
<a name="920"></a>    /*
<a name="921"></a>     *   Have we been discovered yet?
<a name="922"></a>     *
<a name="923"></a>     *   Note that this should be a simple property value, not a method.
<a name="924"></a>     *   It's risky to make this a method because it's evaluated from
<a name="925"></a>     *   within some of the low-level scope/sense calculations, and those
<a name="926"></a>     *   calculations depend upon certain global variables.  If you make
<a name="927"></a>     *   this property into a method, you could indirectly call another
<a name="928"></a>     *   method that changes some of the same globals, which could disrupt
<a name="929"></a>     *   the main scope/sense calculations and cause other, seemingly
<a name="930"></a>     *   unrelated objects to mysteriously appear or disappear at the wrong
<a name="931"></a>     *   times.  If you need to calculate this value dynamically, you could
<a name="932"></a>     *   explicitly assign the property a new value in something like a
<a name="933"></a>     *   daemon or an afterAction() method.
<a name="934"></a>     *
<a name="935"></a>     *   (The warning above is a bit more conservative than is strictly
<a name="936"></a>     *   necessary.  It actually is safe to make 'discovered' a method,
<a name="937"></a>     *   *provided* that the method doesn't ever call anything that's
<a name="938"></a>     *   involved in the scope/sense calculations.  For example, never call
<a name="939"></a>     *   methods like senseObj(), senseAmbientMax(), or
<a name="940"></a>     *   sensePresenceList(), or anything that calls those.  In most cases,
<a name="941"></a>     *   it's safe to call non-sense-related methods, like isOpen() or
<a name="942"></a>     *   isIn().)
<a name="943"></a>     */
<a name="944"></a>    discovered = nil
<a name="945"></a>
<a name="946"></a>    /* mark the object as discovered */
<a name="947"></a>    discover()
<a name="948"></a>    {
<a name="949"></a>        local pc;
<a name="950"></a>
<a name="951"></a>        /* note that we've been discovered */
<a name="952"></a>        discovered = true;
<a name="953"></a>
<a name="954"></a>        /* mark me and my contents as having been seen */
<a name="955"></a>        if ((pc = gPlayerChar).canSee(self))
<a name="956"></a>        {
<a name="957"></a>            /* mark me as seen */
<a name="958"></a>            pc.setHasSeen(self);
<a name="959"></a>
<a name="960"></a>            /* mark my visible contents as see */
<a name="961"></a>            setContentsSeenBy(pc.visibleInfoTable(), pc);
<a name="962"></a>        }
<a name="963"></a>    }
<a name="964"></a>;
<a name="965"></a>
<a name="966"></a>
<a name="967"></a>/* ------------------------------------------------------------------------ */
<a name="968"></a>/*
<a name="969"></a> *   Collective - this is an object that can be used to refer to a group of
<a name="970"></a> *   other (usually equivalent) objects collectively.  In most cases, this
<a name="971"></a> *   object will be a separate game object that contains or can contain the
<a name="972"></a> *   individuals: a bag of marbles can be a collective for the marbles, or
<a name="973"></a> *   a book of matches can be a collective for the matchsticks.
<a name="974"></a> *
<a name="975"></a> *   A collective object is usually given the same plural vocabulary as its
<a name="976"></a> *   individuals.  When we use that plural vocabulary, we will filter for
<a name="977"></a> *   or against the collective, as determined by the noun phrase
<a name="978"></a> *   production, when the player uses the collective term.
<a name="979"></a> *
<a name="980"></a> *   This is a mix-in class, intended to be used along with other (usually
<a name="981"></a> *   Thing-derived) superclasses.
<a name="982"></a> */
<a name="983"></a>class Collective: object
<a name="984"></a>    filterResolveList(lst, action, whichObj, np, requiredNum)
<a name="985"></a>    {
<a name="986"></a>        /* scan for my matching individuals */
<a name="987"></a>        foreach (local cur in lst)
<a name="988"></a>        {
<a name="989"></a>            /* if this one's a matching individual, decide what to do */
<a name="990"></a>            if (isCollectiveFor(cur.obj_))
<a name="991"></a>            {
<a name="992"></a>                /*
<a name="993"></a>                 *   We're a collective for this object.  If the noun
<a name="994"></a>                 *   phrase production wants us to filter for collectives,
<a name="995"></a>                 *   remove the individual and keep me (the collective);
<a name="996"></a>                 *   otherwise, keep the individual and remove me.
<a name="997"></a>                 */
<a name="998"></a>                if (np.filterForCollectives)
<a name="999"></a>                {
<a name="1000"></a>                    /*
<a name="1001"></a>                     *   we want to keep the collective, so remove this
<a name="1002"></a>                     *   individual item
<a name="1003"></a>                     */
<a name="1004"></a>                    lst -= cur;
<a name="1005"></a>                }
<a name="1006"></a>                else
<a name="1007"></a>                {
<a name="1008"></a>                    /*
<a name="1009"></a>                     *   we want to keep individuals, so remove the
<a name="1010"></a>                     *   collective (i.e., myself)
<a name="1011"></a>                     */
<a name="1012"></a>                    lst -= lst.valWhich({x: x.obj_ == self});
<a name="1013"></a>
<a name="1014"></a>                    /*
<a name="1015"></a>                     *   we can only be in the list once, so there's no
<a name="1016"></a>                     *   need to keep looking - if we found another item
<a name="1017"></a>                     *   for which we're a collective, all we'd do is try
<a name="1018"></a>                     *   to remove myself again, which would be pointless
<a name="1019"></a>                     *   since I'm already gone
<a name="1020"></a>                     */
<a name="1021"></a>                    break;
<a name="1022"></a>                }
<a name="1023"></a>            }
<a name="1024"></a>        }
<a name="1025"></a>
<a name="1026"></a>        /* return the result */
<a name="1027"></a>        return lst;
<a name="1028"></a>    }
<a name="1029"></a>
<a name="1030"></a>    /*
<a name="1031"></a>     *   Determine if I'm a collective object for the given object.
<a name="1032"></a>     *
<a name="1033"></a>     *   In order to be a collective for some objects, an object must have
<a name="1034"></a>     *   vocubulary for the plural name, and must return true from this
<a name="1035"></a>     *   method for the collected objects.
<a name="1036"></a>     */
<a name="1037"></a>    isCollectiveFor(obj) { return nil; }
<a name="1038"></a>;
<a name="1039"></a>
<a name="1040"></a>/*
<a name="1041"></a> *   A "collective group" object.  This is an abstract object: the player
<a name="1042"></a> *   doesn't think of this as a physically separate object, but rather as a
<a name="1043"></a> *   collection of a bunch of individual objects.  For example, if you had
<a name="1044"></a> *   a group of floor-number buttons in an elevator, you might create a
<a name="1045"></a> *   CollectiveGroup to represent the buttons as a collection - from the
<a name="1046"></a> *   player's perspective, there's not a separate physical object called
<a name="1047"></a> *   "the buttons," but it might nonetheless be handy to refer to "the
<a name="1048"></a> *   buttons" collectively as a single entity in commands.  CollectiveGroup
<a name="1049"></a> *   is designed for such situations.
<a name="1050"></a> *
<a name="1051"></a> *   There are two ways to use CollectiveGroup: as a non-physical,
<a name="1052"></a> *   non-simulation object whose only purpose is to field a few specific
<a name="1053"></a> *   commands; or as a physical simulation object that shows up separately
<a name="1054"></a> *   as an object in its own right.
<a name="1055"></a> *
<a name="1056"></a> *   First: you can use a CollectiveGroup as a non-physical object, which
<a name="1057"></a> *   essentially means it has a nil 'location'.  The group object doesn't
<a name="1058"></a> *   actually appear in any location.  Instead, it'll be brought into the
<a name="1059"></a> *   sensory system automatically by its individuals, and it'll have the
<a name="1060"></a> *   same effective sensory status as the most visible/audible/etc of its
<a name="1061"></a> *   individuals.  This choice is appropriate when the individuals are
<a name="1062"></a> *   mobile, so they might be scattered around the game map, hence the
<a name="1063"></a> *   group object might need to be invoked anywhere.  With this option, you
<a name="1064"></a> *   normally won't want to make the CollectiveGroup handle very many
<a name="1065"></a> *   commands, because you'll have to completely customize each command you
<a name="1066"></a> *   want it to handle, in order to properly account for the possible
<a name="1067"></a> *   scattering of the individuals.  For example, if you want the group
<a name="1068"></a> *   object to handle the TAKE command, you'll have to figure out which
<a name="1069"></a> *   individuals are in reach, and specially program the procedure for
<a name="1070"></a> *   taking each of the available individuals.
<a name="1071"></a> *
<a name="1072"></a> *   Second: you can use CollectiveGroup as a simulation object, and
<a name="1073"></a> *   actually set its 'location' to the location of its individuals.  The
<a name="1074"></a> *   group object in this case shows up in the simulation alongside its
<a name="1075"></a> *   individuals.  This is a good choice if the individuals are fixed in
<a name="1076"></a> *   place, all in one place, because you can simply put the group object
<a name="1077"></a> *   in the same location as the individuals without worrying that the
<a name="1078"></a> *   individuals will move around the game later on.  This is much easier
<a name="1079"></a> *   to handle than the first case above, mostly because commands that
<a name="1080"></a> *   physically manipulate the individuals (such as TAKE) aren't a factor.
<a name="1081"></a> *   In this set-up, you can easily let the group object handle many
<a name="1082"></a> *   actions, since it won't have to do much apart from showing the default
<a name="1083"></a> *   failure messages that a Fixed would generate in any other situation.
<a name="1084"></a> *   Note that if you use this approach, the CollectiveGroup should *also*
<a name="1085"></a> *   inherit from Fixture or the like, so that the group object is fixed in
<a name="1086"></a> *   place just like its corresponding individuals.
<a name="1087"></a> *
<a name="1088"></a> *   The parser will substitute a CollectiveGroup object for its
<a name="1089"></a> *   individuals when (1) any of the individuals are in scope, (2) the
<a name="1090"></a> *   CollectiveGroup has vocabulary that matches a noun phrase in the
<a name="1091"></a> *   player's input, and (3) the conditions for substitution, defined by
<a name="1092"></a> *   isCollectiveQuant and isCollectiveAction, are met.
<a name="1093"></a> *
<a name="1094"></a> *   (The substitution itself is handled in two steps.  First, an
<a name="1095"></a> *   individual will add the group object to the sense connection list
<a name="1096"></a> *   whenever the individual is in the connection list, which will bring
<a name="1097"></a> *   the object into scope, so the parser will be able to match the
<a name="1098"></a> *   vocabulary from the group object any time an individual is in scope.
<a name="1099"></a> *   Once the group object is matched, its filterResolveList method will
<a name="1100"></a> *   throw out either the group object or all of the individuals, depending
<a name="1101"></a> *   on whether or not the isCollectiveQuant and isCollectiveAction tests
<a name="1102"></a> *   are met.)
<a name="1103"></a> *
<a name="1104"></a> *   For example, we might have a bunch of coins and paper bills in a game,
<a name="1105"></a> *   and give them all a plural word 'money'.  We then also create a
<a name="1106"></a> *   collective group object with plural word 'money'.  We set the
<a name="1107"></a> *   collectiveGroup property of each coin and bill object to refer to the
<a name="1108"></a> *   collective group object.  Whenever the player uses 'money' in a
<a name="1109"></a> *   command, the individual coins and bills will initially match, and the
<a name="1110"></a> *   group object will also match.  The group object will then either throw
<a name="1111"></a> *   itself out, keeping only the individuals, or will throw out the
<a name="1112"></a> *   individuals.  If the group object decides to field the command, it
<a name="1113"></a> *   will be the only matching object, so a command like "examine money"
<a name="1114"></a> *   will be directed to the single collective group object, rather than
<a name="1115"></a> *   directed to the matching individuals one at a time.  This allows the
<a name="1116"></a> *   game to present simpler, more elegant responses to commands on the
<a name="1117"></a> *   individuals as a group.
<a name="1118"></a> *
<a name="1119"></a> *   By default, the only action we handle is Examine.  Each instance must
<a name="1120"></a> *   provide a suitable description so that when the collective is
<a name="1121"></a> *   examined, we describe the group of individuals appropriately.
<a name="1122"></a> */
<a name="1123"></a>class CollectiveGroup: Thing
<a name="1124"></a>    /* collective group objects are usually named in plural terms */
<a name="1125"></a>    isPlural = true
<a name="1126"></a>
<a name="1127"></a>    /*
<a name="1128"></a>     *   Filter a noun phrase resolution list.
<a name="1129"></a>     *
<a name="1130"></a>     *   If there are any objects in the resolution list for which we're a
<a name="1131"></a>     *   collective, we'll check to see whether we want to the collective
<a name="1132"></a>     *   or keep the individuals.  We want to keep the collective if the
<a name="1133"></a>     *   action is one we can handle collectively; otherwise, we want to
<a name="1134"></a>     *   drop the collective and let the individuals handle the action
<a name="1135"></a>     *   instead.
<a name="1136"></a>     *
<a name="1137"></a>     *   Note that, when any of our individuals are in scope, we're in
<a name="1138"></a>     *   scope.  This means that the collective is always in the
<a name="1139"></a>     *   resolution list, along with the individuals, if (1) any
<a name="1140"></a>     *   individuals are in scope, and (2) the vocabulary used in the noun
<a name="1141"></a>     *   phrase matches the collective object.  If the vocabulary doesn't
<a name="1142"></a>     *   match the collective, the parser simply won't include the
<a name="1143"></a>     *   collective in the resolution list by virtue of the normal
<a name="1144"></a>     *   vocabulary selection mechanism, so we'll never reach this point.
<a name="1145"></a>     *
<a name="1146"></a>     *   By default, the collective object will be ignored if a specific
<a name="1147"></a>     *   number of objects is required.  When the player explicitly
<a name="1148"></a>     *   specifies a quantity (by a phrase like "the five coins" or "both
<a name="1149"></a>     *   coins"), we'll assume they want to iterate over individuals
<a name="1150"></a>     *   rather than operate on the collection.
<a name="1151"></a>     */
<a name="1152"></a>    filterResolveList(lst, action, whichObj, np, requiredNum)
<a name="1153"></a>    {
<a name="1154"></a>        /*
<a name="1155"></a>         *   If we want to use the collective for the current action and
<a name="1156"></a>         *   the required quantity, keep the collective; otherwise, if
<a name="1157"></a>         *   there are any individuals, keep the individuals and filter
<a name="1158"></a>         *   out the collective group.  If there are no matching
<a name="1159"></a>         *   individuals, keep the collective group object, since there's
<a name="1160"></a>         *   nothing to replace it.
<a name="1161"></a>         */
<a name="1162"></a>        if (isCollectiveQuant(np, requiredNum)
<a name="1163"></a>            &amp;&amp; isCollectiveAction(action, whichObj))
<a name="1164"></a>        {
<a name="1165"></a>            /*
<a name="1166"></a>             *   We can handle the action collectively, so keep myself, and
<a name="1167"></a>             *   get rid of the individuals.  We want to discard the
<a name="1168"></a>             *   individuals because we want the entire action to be
<a name="1169"></a>             *   handled by the collective object, rather than iterating
<a name="1170"></a>             *   over the individuals.  So, discard each object that has
<a name="1171"></a>             *   'self' as a collectiveGroup (which is to say, keep each
<a name="1172"></a>             *   object that *doesn't* have collectiveGroup 'self').
<a name="1173"></a>             */
<a name="1174"></a>            lst = lst.subset({x: !x.obj_.hasCollectiveGroup(self)});
<a name="1175"></a>        }
<a name="1176"></a>        else if (lst.indexWhich({x: x.obj_.hasCollectiveGroup(self)}) != nil)
<a name="1177"></a>        {
<a name="1178"></a>            /*
<a name="1179"></a>             *   We can't handle the action collectively, and the list
<a name="1180"></a>             *   includes at least one of our individuals, so let the
<a name="1181"></a>             *   individuals handle it.  Simply remove myself from the
<a name="1182"></a>             *   list.
<a name="1183"></a>             */
<a name="1184"></a>            lst = lst.removeElementAt(lst.indexWhich({x: x.obj_ == self}));
<a name="1185"></a>        }
<a name="1186"></a>
<a name="1187"></a>        /* return the updated list */
<a name="1188"></a>        return lst;
<a name="1189"></a>    }
<a name="1190"></a>
<a name="1191"></a>    /*
<a name="1192"></a>     *   "Unfilter" a pronoun antecedent list.  We'll restore the
<a name="1193"></a>     *   individuals to the list so that we can choose anew, for the new
<a name="1194"></a>     *   command, whether to select the group object or the individuals.
<a name="1195"></a>     *
<a name="1196"></a>     *   For example, suppose there's a CollectiveGroup for a set of
<a name="1197"></a>     *   elevator buttons that handles the Examine command, but no other
<a name="1198"></a>     *   commands.  Now suppose the player types in these commands:
<a name="1199"></a>     *
<a name="1200"></a>     *.  &gt;examine buttons
<a name="1201"></a>     *.  &gt;push them
<a name="1202"></a>     *
<a name="1203"></a>     *   On the first command, the CollectiveGroup object will filter out
<a name="1204"></a>     *   the individual buttons in filterResolveList, because the group
<a name="1205"></a>     *   object handles the Examine command on behalf of the individuals.
<a name="1206"></a>     *   This will set the pronoun antecedent for IT and THEM to the group
<a name="1207"></a>     *   object, because that's the program object that handled the
<a name="1208"></a>     *   action.  On the second command, if the player had typed simply
<a name="1209"></a>     *   PUSH BUTTONS, the collective group object would have filtered
<a name="1210"></a>     *   *itself* out, keeping the individuals.  However, the raw pronoun
<a name="1211"></a>     *   binding for THEM is the group object; if we did nothing to change
<a name="1212"></a>     *   this, we'd get a different response for PUSH THEM than we'd get
<a name="1213"></a>     *   for PUSH BUTTONS.  That's where this routine comes in: by
<a name="1214"></a>     *   restoring the individuals, we let filterResolveList() make the
<a name="1215"></a>     *   decision about what to keep anew for the pronoun.
<a name="1216"></a>     */
<a name="1217"></a>    expandPronounList(typ, lst)
<a name="1218"></a>    {
<a name="1219"></a>        /* restore our individuals to the list */
<a name="1220"></a>        forEachInstance(Thing, function(obj) {
<a name="1221"></a>            if (obj.hasCollectiveGroup(self))
<a name="1222"></a>                lst += obj;
<a name="1223"></a>        });
<a name="1224"></a>
<a name="1225"></a>        /* return the list */
<a name="1226"></a>        return lst;
<a name="1227"></a>    }
<a name="1228"></a>
<a name="1229"></a>    /*
<a name="1230"></a>     *   Check the action to determine if it's one that we want to handle
<a name="1231"></a>     *   collectively.  If so, return true; if not, return nil.
<a name="1232"></a>     */
<a name="1233"></a>    isCollectiveAction(action, whichObj)
<a name="1234"></a>    {
<a name="1235"></a>        /* we handle 'Examine' */
<a name="1236"></a>        if (action.ofKind(ExamineAction))
<a name="1237"></a>            return true;
<a name="1238"></a>
<a name="1239"></a>        /* it's not one of ours */
<a name="1240"></a>        return nil;
<a name="1241"></a>    }
<a name="1242"></a>
<a name="1243"></a>    /*
<a name="1244"></a>     *   Check to see if we're a collective for the given quantity.  By
<a name="1245"></a>     *   default, we return true only when no quantity is specified.
<a name="1246"></a>     */
<a name="1247"></a>    isCollectiveQuant(np, requiredNum)
<a name="1248"></a>    {
<a name="1249"></a>        /* if no quantity was specified, use the collective */
<a name="1250"></a>        return (requiredNum == nil);
<a name="1251"></a>    }
<a name="1252"></a>
<a name="1253"></a>    /*
<a name="1254"></a>     *   Get a list of the individuals that can be sensed, given the
<a name="1255"></a>     *   information table for the desired sense (for visible items, this
<a name="1256"></a>     *   can be obtained by calling gActor.visibleInfoTable()).  This is a
<a name="1257"></a>     *   service routine that can be useful for purposes such as writing a
<a name="1258"></a>     *   description routine for the collective.  For example, a "money"
<a name="1259"></a>     *   collective object might want to count up the sum of money visible
<a name="1260"></a>     *   and show that.
<a name="1261"></a>     *
<a name="1262"></a>     *   Note that it's possible for this to return an empty list.  The
<a name="1263"></a>     *   caller can deal with this in a description, for example, by
<a name="1264"></a>     *   indicating that the collection cannot be seen.
<a name="1265"></a>     */
<a name="1266"></a>    getVisibleIndividuals(tab)
<a name="1267"></a>    {
<a name="1268"></a>        /* keep only those items that are individuals of this collective */
<a name="1269"></a>        tab.forEachAssoc(function(key, val)
<a name="1270"></a>        {
<a name="1271"></a>            /* remove this item if it's not an individual of mine */
<a name="1272"></a>            if (!key.hasCollectiveGroup(self))
<a name="1273"></a>                tab.removeElement(key);
<a name="1274"></a>        });
<a name="1275"></a>
<a name="1276"></a>        /* return a list of the objects (i.e., the table's keys) */
<a name="1277"></a>        return tab.keysToList();
<a name="1278"></a>    }
<a name="1279"></a>
<a name="1280"></a>    /*
<a name="1281"></a>     *   When we have no location, we're an abstract object without any
<a name="1282"></a>     *   physical presence in the game world.  However, we still want to
<a name="1283"></a>     *   show up in the senses to the same extent our individuals do.  To
<a name="1284"></a>     *   do this, we override this method so that we use the same sense
<a name="1285"></a>     *   data as the most visible (or whatever) of our individuals.
<a name="1286"></a>     */
<a name="1287"></a>    addToSenseInfoTable(sense, tab)
<a name="1288"></a>    {
<a name="1289"></a>        /* if we have no location, mimic our best individual */
<a name="1290"></a>        if (location == nil &amp;&amp; !ofKind(BaseMultiLoc))
<a name="1291"></a>        {
<a name="1292"></a>            /* check everything in the connection table */
<a name="1293"></a>            tab.forEachAssoc(function(cur, val) {
<a name="1294"></a>                /* if this is one of our individuals, check it */
<a name="1295"></a>                if (cur.hasCollectiveGroup(self))
<a name="1296"></a>                {
<a name="1297"></a>                    local t;
<a name="1298"></a>
<a name="1299"></a>                    /*
<a name="1300"></a>                     *   If it's the best or only one so far, adopt its
<a name="1301"></a>                     *   sense status.  Consider it the best if it has a
<a name="1302"></a>                     *   more transparent transparency than the best so
<a name="1303"></a>                     *   far, or its transparency is the same and it has a
<a name="1304"></a>                     *   high ambient level.
<a name="1305"></a>                     */
<a name="1306"></a>                    t = transparencyCompare(cur.tmpTrans_, tmpTrans_);
<a name="1307"></a>                    if (t &gt; 0 || (t == 0 &amp;&amp; cur.tmpAmbient_ &gt; tmpAmbient_))
<a name="1308"></a>                    {
<a name="1309"></a>                        /* it's better than our settings; mimic it */
<a name="1310"></a>                        tmpTrans_ = cur.tmpTrans_;
<a name="1311"></a>                        tmpAmbient_ = cur.tmpAmbient_;
<a name="1312"></a>                        tmpObstructor_ = cur.tmpObstructor_;
<a name="1313"></a>                    }
<a name="1314"></a>                }
<a name="1315"></a>            });
<a name="1316"></a>        }
<a name="1317"></a>
<a name="1318"></a>        /* inherit the standard handling */
<a name="1319"></a>        inherited(sense, tab);
<a name="1320"></a>    }
<a name="1321"></a>
<a name="1322"></a>    /*
<a name="1323"></a>     *   When we have no location, we want to create our own special
<a name="1324"></a>     *   containment path, just as we create our own special SenseInfo.
<a name="1325"></a>     */
<a name="1326"></a>    specialPathFrom(src, vec)
<a name="1327"></a>    {
<a name="1328"></a>        /* if we have a location, use the normal handling */
<a name="1329"></a>        if (location != nil || ofKind(BaseMultiLoc))
<a name="1330"></a>            inherited(src, vec);
<a name="1331"></a>
<a name="1332"></a>        /* look for an individual among the source object's connections */
<a name="1333"></a>        src.connectionTable().forEachAssoc(function(cur, val) {
<a name="1334"></a>            /* if this is one of our individuals, check it */
<a name="1335"></a>            if (cur.hasCollectiveGroup(self))
<a name="1336"></a>            {
<a name="1337"></a>                /* add this individual's paths to the vector */
<a name="1338"></a>                vec.appendAll(src.getAllPathsTo(cur));
<a name="1339"></a>            }
<a name="1340"></a>        });
<a name="1341"></a>    }
<a name="1342"></a>
<a name="1343"></a>    /*
<a name="1344"></a>     *   CollectiveGroup objects are not normally listable in any
<a name="1345"></a>     *   situations.  Since a collective group is merely a parser stand-in
<a name="1346"></a>     *   for its individuals, we don't want it to appear as a separate
<a name="1347"></a>     *   object in the game.
<a name="1348"></a>     */
<a name="1349"></a>    isListedInContents = nil
<a name="1350"></a>    isListedInInventory = nil
<a name="1351"></a>;
<a name="1352"></a>
<a name="1353"></a>/*
<a name="1354"></a> *   An "itemizing" collective group is like a regular collective group,
<a name="1355"></a> *   but the Examine action itemizes the individual visible items making up
<a name="1356"></a> *   the group.  We itemize the individuals instead of showing the 'desc'
<a name="1357"></a> *   for the overall group object, as the basic collective group class
<a name="1358"></a> *   does.
<a name="1359"></a> */
<a name="1360"></a>class ItemizingCollectiveGroup: CollectiveGroup
<a name="1361"></a>    /*
<a name="1362"></a>     *   Override the main Examine handling.  By default, we'll list the
<a name="1363"></a>     *   individuals that are visible, and separately list those that are
<a name="1364"></a>     *   being carried by the actor.  If none of our individuals are
<a name="1365"></a>     *   visible, simply say so.
<a name="1366"></a>     */
<a name="1367"></a>    mainExamine()
<a name="1368"></a>    {
<a name="1369"></a>        local info;
<a name="1370"></a>        local vis;
<a name="1371"></a>        local carried, here;
<a name="1372"></a>
<a name="1373"></a>        /* get the visible info table */
<a name="1374"></a>        info = gActor.visibleInfoTable();
<a name="1375"></a>
<a name="1376"></a>        /* get the list of visible individuals */
<a name="1377"></a>        vis = getVisibleIndividuals(info);
<a name="1378"></a>
<a name="1379"></a>        /* if any individuals are visible, list them */
<a name="1380"></a>        if (vis.length() != 0)
<a name="1381"></a>        {
<a name="1382"></a>            /* separate out the individuals being carried */
<a name="1383"></a>            carried = vis.subset({x: x.isIn(gActor)});
<a name="1384"></a>            here = vis - carried;
<a name="1385"></a>
<a name="1386"></a>            /* show the items that are here but not being carried, if any */
<a name="1387"></a>            if (here.length() != 0)
<a name="1388"></a>            {
<a name="1389"></a>                /* get the room contents lister */
<a name="1390"></a>                local lister = gActor.location.roomContentsLister;
<a name="1391"></a>
<a name="1392"></a>                /* get the subset that the room contents lister won't list */
<a name="1393"></a>                local xlist = here.subset({x: !lister.isListed(x)});
<a name="1394"></a>
<a name="1395"></a>                /* show the list through the room contents lister */
<a name="1396"></a>                lister.showList(gActor, nil, here, 0, 0, info, nil);
<a name="1397"></a>
<a name="1398"></a>                /* Examine any objects not part of the room description */
<a name="1399"></a>                foreach (local x in xlist)
<a name="1400"></a>                    examineUnlisted(x);
<a name="1401"></a>
<a name="1402"></a>                /*
<a name="1403"></a>                 *   if that showed anything, add a paragraph break before
<a name="1404"></a>                 *   the carried list
<a name="1405"></a>                 */
<a name="1406"></a>                if (xlist.length() != 0 &amp;&amp; carried.length() != 0)
<a name="1407"></a>                    "&lt;.p&gt;";
<a name="1408"></a>            }
<a name="1409"></a>
<a name="1410"></a>            /* separately, show the items being carried, if any */
<a name="1411"></a>            if (carried.length() != 0)
<a name="1412"></a>                gActor.inventoryLister.showList(
<a name="1413"></a>                    gActor, gActor, carried, 0, 0, info, nil);
<a name="1414"></a>        }
<a name="1415"></a>        else
<a name="1416"></a>        {
<a name="1417"></a>            /*
<a name="1418"></a>             *   None are visible.  If it's dark in the location, simply
<a name="1419"></a>             *   say so; otherwise, say that we can't see any of me.
<a name="1420"></a>             */
<a name="1421"></a>            if (!gActor.isLocationLit())
<a name="1422"></a>                reportFailure(&amp;tooDarkMsg);
<a name="1423"></a>            else
<a name="1424"></a>                reportFailure(&amp;mustBeVisibleMsg, self);
<a name="1425"></a>        }
<a name="1426"></a>    }
<a name="1427"></a>
<a name="1428"></a>    /*
<a name="1429"></a>     *   Examine an unlisted individual object.  This will be called for
<a name="1430"></a>     *   each object in the room that's not listable via the room contents
<a name="1431"></a>     *   lister.
<a name="1432"></a>     */
<a name="1433"></a>    examineUnlisted(x)
<a name="1434"></a>    {
<a name="1435"></a>        "&lt;.p&gt;";
<a name="1436"></a>        nestedAction(Examine, x);
<a name="1437"></a>    }
<a name="1438"></a>;
<a name="1439"></a>
<a name="1440"></a>/* ------------------------------------------------------------------------ */
<a name="1441"></a>/*
<a name="1442"></a> *   A readable object.  Any ordinary object will show its normal full
<a name="1443"></a> *   description when read, but an object that is explicitly readable will
<a name="1444"></a> *   have elevated logicalness for the "read" action, and can optionally
<a name="1445"></a> *   show a separate description when read.
<a name="1446"></a> */
<a name="1447"></a>class Readable: Thing
<a name="1448"></a>    /*
<a name="1449"></a>     *   Show my special reading desription.  By default, we set this to
<a name="1450"></a>     *   nil to indicate that we should use our default "examine"
<a name="1451"></a>     *   description; objects can override this to show a special message
<a name="1452"></a>     *   for reading the object as desired.
<a name="1453"></a>     */
<a name="1454"></a>    readDesc = nil
<a name="1455"></a>
<a name="1456"></a>    /* our reading description when obscured */
<a name="1457"></a>    obscuredReadDesc() { gLibMessages.obscuredReadDesc(self); }
<a name="1458"></a>
<a name="1459"></a>    /* our reading description in dim light */
<a name="1460"></a>    dimReadDesc() { gLibMessages.dimReadDesc(self); }
<a name="1461"></a>
<a name="1462"></a>    /* "Read" action */
<a name="1463"></a>    dobjFor(Read)
<a name="1464"></a>    {
<a name="1465"></a>        verify()
<a name="1466"></a>        {
<a name="1467"></a>            /* give slight preference to an object being held */
<a name="1468"></a>            if (!isIn(gActor))
<a name="1469"></a>                logicalRank(80, 'not held');
<a name="1470"></a>        }
<a name="1471"></a>        action()
<a name="1472"></a>        {
<a name="1473"></a>            /*
<a name="1474"></a>             *   if we have a special reading description defined, show
<a name="1475"></a>             *   it; otherwise, use the same handling as "examine"
<a name="1476"></a>             */
<a name="1477"></a>            if (propType(&amp;readDesc) != TypeNil)
<a name="1478"></a>            {
<a name="1479"></a>                local info;
<a name="1480"></a>
<a name="1481"></a>                /*
<a name="1482"></a>                 *   Reading requires a transparent sight path and plenty
<a name="1483"></a>                 *   of light; in the absence of either of these, we can't
<a name="1484"></a>                 *   make out the details.
<a name="1485"></a>                 */
<a name="1486"></a>                info = gActor.bestVisualInfo(self);
<a name="1487"></a>                if (info.trans != transparent)
<a name="1488"></a>                    obscuredReadDesc;
<a name="1489"></a>                else if (info.ambient &lt; 3)
<a name="1490"></a>                    dimReadDesc;
<a name="1491"></a>                else
<a name="1492"></a>                    readDesc;
<a name="1493"></a>            }
<a name="1494"></a>            else
<a name="1495"></a>            {
<a name="1496"></a>                /*
<a name="1497"></a>                 *   we have no special reading description, so use the
<a name="1498"></a>                 *   default "examine" handling
<a name="1499"></a>                 */
<a name="1500"></a>                actionDobjExamine();
<a name="1501"></a>            }
<a name="1502"></a>        }
<a name="1503"></a>    }
<a name="1504"></a>;
<a name="1505"></a>
<a name="1506"></a>
<a name="1507"></a>/* ------------------------------------------------------------------------ */
<a name="1508"></a>/*
<a name="1509"></a> *   A "consultable" object.  This is an inanimate object that can be
<a name="1510"></a> *   consulted about various topics, almost the way an actor can be asked
<a name="1511"></a> *   about topics.  Examples include individual objects that contain
<a name="1512"></a> *   voluminous information, such as books, phone directories, and maps, as
<a name="1513"></a> *   well as collections of individual information-carrying objects, such
<a name="1514"></a> *   as file cabinets or bookcases.
<a name="1515"></a> *
<a name="1516"></a> *   A consultable keeps a database of TopicEntry objects; this works in
<a name="1517"></a> *   much the same way as the topic database system that actors use.
<a name="1518"></a> *   Create one or more ConsultTopic objects and place them inside the
<a name="1519"></a> *   Consultable (using the 'location' property, or using the '+' syntax).
<a name="1520"></a> *   When an actor consults the object about a topic, we'll search our
<a name="1521"></a> *   database for a ConsultTopic object that matches the topic and is
<a name="1522"></a> *   currently active, and show the response for the best one we can find.
<a name="1523"></a> *
<a name="1524"></a> *   From an IF design perspective, consultables have two nice properties.
<a name="1525"></a> *
<a name="1526"></a> *   First, they hide the boundaries of implementation, by letting the game
<a name="1527"></a> *   *suggest* that there's an untold wealth of information in a particular
<a name="1528"></a> *   book (or whatever) without the need to actually implement all of it.
<a name="1529"></a> *   We only have to show the entries the player specifically asks for, so
<a name="1530"></a> *   the game never has to admit when it's run out of things to show, and
<a name="1531"></a> *   the player can never know for sure that there's not more to find.  Be
<a name="1532"></a> *   careful, though, because this is a double-edge sword, design-wise;
<a name="1533"></a> *   it's easy to abuse this property to hide information gratuitously from
<a name="1534"></a> *   the player.
<a name="1535"></a> *
<a name="1536"></a> *   Second, consultables help "match impedances" between the narrative
<a name="1537"></a> *   level of detail and the underlying world model.  At the narrative
<a name="1538"></a> *   level, we paint in fairly broad strokes: when we visit a new location,
<a name="1539"></a> *   we describe the *important* features of the setting, not every last
<a name="1540"></a> *   detail.  If the player wants to examine something in closer detail, we
<a name="1541"></a> *   zoom in on that detail, assuming we've implemented it, but it's up to
<a name="1542"></a> *   the player to determine where the attention is focused.  Consultable
<a name="1543"></a> *   objects give us the same capability for books and the like.  With a
<a name="1544"></a> *   consultable, we can describe the way a book looks without immediately
<a name="1545"></a> *   dumping the literal contents of the book onto the screen; but when the
<a name="1546"></a> *   player chooses some aspect of the book to read in detail, we can zoom
<a name="1547"></a> *   in on that page or chapter and show that literal content, if we
<a name="1548"></a> *   choose.
<a name="1549"></a> *
<a name="1550"></a> *   Also, note that we assume that consultables convey their information
<a name="1551"></a> *   through visual information, such as printed text or a display screen.
<a name="1552"></a> *   Because of this, we by default require that the object be visible to
<a name="1553"></a> *   be consulted.  This might not be appropriate in some cases, such as
<a name="1554"></a> *   Braille books or talking PDA's; to remove the visual condition,
<a name="1555"></a> *   override the pre-condition for the Consult action.
<a name="1556"></a> */
<a name="1557"></a>class Consultable: Thing, TopicDatabase
<a name="1558"></a>    /*
<a name="1559"></a>     *   If they consult us without a topic, just ask for a topic.  Treat
<a name="1560"></a>     *   it as logical, but rank it as improbable, in case there's
<a name="1561"></a>     *   anything else around that can be consulted without any topic
<a name="1562"></a>     *   specified.
<a name="1563"></a>     */
<a name="1564"></a>    dobjFor(Consult)
<a name="1565"></a>    {
<a name="1566"></a>        preCond = [touchObj, objVisible]
<a name="1567"></a>        verify() { logicalRank(50, 'need a topic'); }
<a name="1568"></a>        action() { askForTopic(ConsultAbout); }
<a name="1569"></a>    }
<a name="1570"></a>
<a name="1571"></a>    /* consult about a topic */
<a name="1572"></a>    dobjFor(ConsultAbout)
<a name="1573"></a>    {
<a name="1574"></a>        verify() { }
<a name="1575"></a>        action()
<a name="1576"></a>        {
<a name="1577"></a>            /* remember that we're the last object the actor consulted */
<a name="1578"></a>            gActor.noteConsultation(self);
<a name="1579"></a>
<a name="1580"></a>            /* try handling the topic through our topic database */
<a name="1581"></a>            if (!handleTopic(gActor, gTopic, consultConvType, nil))
<a name="1582"></a>                topicNotFound();
<a name="1583"></a>        }
<a name="1584"></a>    }
<a name="1585"></a>
<a name="1586"></a>    /* show the default response for a topic we couldn't find */
<a name="1587"></a>    topicNotFound()
<a name="1588"></a>    {
<a name="1589"></a>        /*
<a name="1590"></a>         *   Report the absence of the topic.  Note that we use an
<a name="1591"></a>         *   ordinary, successful report, not a failure report, because
<a name="1592"></a>         *   the consultation really did succeed in the sense of the
<a name="1593"></a>         *   physical action of consulting: we successfully flipped
<a name="1594"></a>         *   through the book, scanned the file cabinet, or whatever.  We
<a name="1595"></a>         *   didn't find what we were looking for, but in terms of the
<a name="1596"></a>         *   physical action undertaken, we successfully did exactly what
<a name="1597"></a>         *   we were asked to do.
<a name="1598"></a>         */
<a name="1599"></a>        mainReport(&amp;cannotFindTopicMsg);
<a name="1600"></a>    }
<a name="1601"></a>
<a name="1602"></a>    /*
<a name="1603"></a>     *   Resolve the topic phrase for a CONSULT ABOUT command.  The CONSULT
<a name="1604"></a>     *   ABOUT action refers this to the direct object of the action, so
<a name="1605"></a>     *   that the direct object can filter the topic match according to
<a name="1606"></a>     *   what makes sense for the consultable.
<a name="1607"></a>     *
<a name="1608"></a>     *   By default, we resolve the topic phrase a little differently than
<a name="1609"></a>     *   we would for conversational commands, such as ASK ABOUT.  By
<a name="1610"></a>     *   default, we don't differentiate objects at all based on physical
<a name="1611"></a>     *   scope or actor knowledge when deciding on a match for a topic
<a name="1612"></a>     *   phrase.  For example, if you create a Consultable representing a
<a name="1613"></a>     *   phone book, and the player enters a command like FIND BOB IN PHONE
<a name="1614"></a>     *   BOOK, the topic BOB will be found even if the 'bob' object isn't
<a name="1615"></a>     *   known to the player character.  The reason for this difference
<a name="1616"></a>     *   from ASK ABOUT et al is that consultables are generally the kinds
<a name="1617"></a>     *   of objects where, in real life, a person could browse through the
<a name="1618"></a>     *   object and come across entries whether or not the person knew
<a name="1619"></a>     *   enough to look for them.  For example, you could go through a
<a name="1620"></a>     *   phone book and find an entry for "Bob" even if you didn't know
<a name="1621"></a>     *   anyone named Bob.
<a name="1622"></a>     *
<a name="1623"></a>     *   'lst' is the list of ResolveInfo objects giving the full set of
<a name="1624"></a>     *   matches for the vocabulary words; 'np' is the grammar production
<a name="1625"></a>     *   object for the topic phrase; and 'resolver' is the TopicResolver
<a name="1626"></a>     *   that's resolving the topic phrase.  Note that 'lst' contains
<a name="1627"></a>     *   ResolveInfo objects, so to get the game-world object for a given
<a name="1628"></a>     *   list entry, use lst[i].obj_.
<a name="1629"></a>     *
<a name="1630"></a>     *   We return a ResolvedTopic object that encapsulates the matching
<a name="1631"></a>     *   objects.
<a name="1632"></a>     *
<a name="1633"></a>     *   Note that the resolver object can be used to get certain useful
<a name="1634"></a>     *   information.  The resolver's getAction() method returns the action
<a name="1635"></a>     *   (which you should use instead of gAction, since this routine is
<a name="1636"></a>     *   called during the resolution process, not during command
<a name="1637"></a>     *   execution); its getTargetActor() method returns the actor
<a name="1638"></a>     *   performing the action; and its objInPhysicalScope(obj) method lets
<a name="1639"></a>     *   you determine if an object is in physical scope for the actor.
<a name="1640"></a>     */
<a name="1641"></a>    resolveConsultTopic(lst, np, resolver)
<a name="1642"></a>    {
<a name="1643"></a>        /*
<a name="1644"></a>         *   by default, simply return an undifferentiated list with
<a name="1645"></a>         *   everything given equal weight, whether known or not, and
<a name="1646"></a>         *   whether in scope or not
<a name="1647"></a>         */
<a name="1648"></a>        return new ResolvedTopic(lst, [], [], np);
<a name="1649"></a>    }
<a name="1650"></a>
<a name="1651"></a>    /*
<a name="1652"></a>     *   Our topic entry database for consultatation topics.  This will be
<a name="1653"></a>     *   automatically built during initialization from the set of
<a name="1654"></a>     *   ConsultTopic objects located within me, so there's usually no
<a name="1655"></a>     *   need to initialize this manually.
<a name="1656"></a>     */
<a name="1657"></a>    consultTopics = nil
<a name="1658"></a>;
<a name="1659"></a>
<a name="1660"></a>/*
<a name="1661"></a> *   A consultation topic.  You can place one or more of these inside a
<a name="1662"></a> *   Consultable object (using the 'location' property, or the '+'
<a name="1663"></a> *   notation), to create a database of topics that can be looked up in
<a name="1664"></a> *   the consultable.
<a name="1665"></a> */
<a name="1666"></a>class ConsultTopic: TopicMatchTopic
<a name="1667"></a>    /* include in the consultation list */
<a name="1668"></a>    includeInList = [&amp;consultTopics]
<a name="1669"></a>
<a name="1670"></a>    /*
<a name="1671"></a>     *   don't set any pronouns for the topic - the consultable itself
<a name="1672"></a>     *   should be the pronoun antecedent
<a name="1673"></a>     */
<a name="1674"></a>    setTopicPronouns(fromActor, obj) { }
<a name="1675"></a>;
<a name="1676"></a>
<a name="1677"></a>/*
<a name="1678"></a> *   A default topic entry for a consultable.  You can include one (or
<a name="1679"></a> *   more) of these in a consultable's database to provide a topic of last
<a name="1680"></a> *   resort that answers to any topics that aren't in the database
<a name="1681"></a> *   themselves.
<a name="1682"></a> */
<a name="1683"></a>class DefaultConsultTopic: DefaultTopic
<a name="1684"></a>    includeInList = [&amp;consultTopics]
<a name="1685"></a>    setTopicPronouns(fromActor, obj) { }
<a name="1686"></a>;
<a name="1687"></a>
<a name="1688"></a>
<a name="1689"></a>/* ------------------------------------------------------------------------ */
<a name="1690"></a>/*
<a name="1691"></a> *   A common, abstract base class for things that cannot be moved.  You
<a name="1692"></a> *   shouldn't use this class to create game objects directly; you should
<a name="1693"></a> *   always use one of the concrete subclasses, such as Fixture or
<a name="1694"></a> *   Immovable.  This base class doesn't provide the full behavior
<a name="1695"></a> *   necessary to make an object immovable; it's just here as a
<a name="1696"></a> *   programming abstraction for the common elements of all immovable
<a name="1697"></a> *   objects.
<a name="1698"></a> *
<a name="1699"></a> *   This class has two purposes.  First, it defines some behavior common
<a name="1700"></a> *   to all non-portable objects.  Second, you can test an object to see
<a name="1701"></a> *   if it's based on this class to determine whether it's a portable or
<a name="1702"></a> *   unportable type of Thing.
<a name="1703"></a> */
<a name="1704"></a>class NonPortable: Thing
<a name="1705"></a>    /*
<a name="1706"></a>     *   An immovable objects is not listed in room or container contents
<a name="1707"></a>     *   listings.  Since the object is immovable, it's in effect a
<a name="1708"></a>     *   permanent feature of its location, so it should be described as
<a name="1709"></a>     *   such: either directly as part of its location's description text,
<a name="1710"></a>     *   or via its own specialDesc.
<a name="1711"></a>     */
<a name="1712"></a>    isListed = nil
<a name="1713"></a>    isListedInContents = nil
<a name="1714"></a>    isListedInInventory = nil
<a name="1715"></a>
<a name="1716"></a>    /*
<a name="1717"></a>     *   By default, if the object's contents would be listed in a direct
<a name="1718"></a>     *   examination, then also list them when showing an inventory list,
<a name="1719"></a>     *   or describing the enclosing room or an enclosing object.
<a name="1720"></a>     */
<a name="1721"></a>    contentsListed = (contentsListedInExamine)
<a name="1722"></a>
<a name="1723"></a>    /*
<a name="1724"></a>     *   Are my contents within a fixed item that is within the given
<a name="1725"></a>     *   location?  Since we're fixed in place, our contents are certainly
<a name="1726"></a>     *   within a fixed item, so we merely need to check if we're fixed in
<a name="1727"></a>     *   place within the given location.  We are if we're in the given
<a name="1728"></a>     *   location or we ourselves are fixed in place in the given location.
<a name="1729"></a>     */
<a name="1730"></a>    contentsInFixedIn(loc)
<a name="1731"></a>    {
<a name="1732"></a>        return isDirectlyIn(loc) || isInFixedIn(loc);
<a name="1733"></a>    }
<a name="1734"></a>
<a name="1735"></a>    /*
<a name="1736"></a>     *   Since non-portables aren't carried, their weight and bulk are
<a name="1737"></a>     *   largely irrelevant.  Even so, when a non-portable is a component
<a name="1738"></a>     *   of another object, or otherwise contained in another object, its
<a name="1739"></a>     *   weight and/or bulk can affect the behavior of the parent object.
<a name="1740"></a>     *   So, it's simplest to use a default of zero for these so that there
<a name="1741"></a>     *   are no surprises about the parent's behavior.
<a name="1742"></a>     */
<a name="1743"></a>    weight = 0
<a name="1744"></a>    bulk = 0
<a name="1745"></a>
<a name="1746"></a>    /*
<a name="1747"></a>     *   Non-portable objects can't be held, since they can't be carried.
<a name="1748"></a>     *   However, in some cases, it's useful to include non-portable
<a name="1749"></a>     *   objects within an actor, such as when creating component parts of
<a name="1750"></a>     *   an actor (hands, say).  In these cases, the non-portables aren't
<a name="1751"></a>     *   held, but rather are components or similar.
<a name="1752"></a>     */
<a name="1753"></a>    isHeldBy(actor) { return nil; }
<a name="1754"></a>
<a name="1755"></a>    /*
<a name="1756"></a>     *   We're not being held, but if our location is an actor, then we're
<a name="1757"></a>     *   as good as held because we're effectively part of the actor.
<a name="1758"></a>     */
<a name="1759"></a>    meetsObjHeld(actor) { return actor == location; }
<a name="1760"></a>
<a name="1761"></a>    /*
<a name="1762"></a>     *   showing an immovable to someone simply requires that it be in
<a name="1763"></a>     *   sight: we're not holding it up to show it, we're simply pointing
<a name="1764"></a>     *   it out
<a name="1765"></a>     */
<a name="1766"></a>    dobjFor(ShowTo) { preCond = [objVisible] }
<a name="1767"></a>
<a name="1768"></a>    /*
<a name="1769"></a>     *   Thing decreases the likelihood that we want to examine an object
<a name="1770"></a>     *   when the object isn't being held.  That's fine for portable
<a name="1771"></a>     *   objects, but nonportables can never be held, so we don't want that
<a name="1772"></a>     *   decrease in logicalness.
<a name="1773"></a>     */
<a name="1774"></a>    dobjFor(Examine)
<a name="1775"></a>    {
<a name="1776"></a>        /* override Thing's likelihood downgrade for un-held items */
<a name="1777"></a>        verify() { }
<a name="1778"></a>    }
<a name="1779"></a>;
<a name="1780"></a>
<a name="1781"></a>
<a name="1782"></a>/* ------------------------------------------------------------------------ */
<a name="1783"></a>/*
<a name="1784"></a> *   A "fixture," which is something that's obviously a part of the room.
<a name="1785"></a> *   These objects cannot be removed from their containers.  This class is
<a name="1786"></a> *   meant for permanent features of rooms that obviously cannot be moved
<a name="1787"></a> *   to a new container, such as walls, floors, doors, built-in bookcases,
<a name="1788"></a> *   light switches, buildings, and the like.
<a name="1789"></a> *
<a name="1790"></a> *   The important feature of a Fixture is that it's *obvious* that it's
<a name="1791"></a> *   part of its container, so it should be safe to assume that a character
<a name="1792"></a> *   normally wouldn't even try to take it or move it.  For objects that
<a name="1793"></a> *   might appear portable but turn out to be immovable, other classes are
<a name="1794"></a> *   more appropriate: use Heavy for objects that are immovable simply
<a name="1795"></a> *   because they're very heavy, for example, or Immovable for objects that
<a name="1796"></a> *   are immovable for some non-obvious reason.
<a name="1797"></a> */
<a name="1798"></a>class Fixture: NonPortable
<a name="1799"></a>    /*
<a name="1800"></a>     *   Hide fixtures from "all" for certain commands.  Fixtures are
<a name="1801"></a>     *   obviously part of the location, so a reaonable person wouldn't
<a name="1802"></a>     *   even consider trying to do things like take them or move them.
<a name="1803"></a>     */
<a name="1804"></a>    hideFromAll(action)
<a name="1805"></a>    {
<a name="1806"></a>        return (action.ofKind(TakeAction)
<a name="1807"></a>                || action.ofKind(DropAction)
<a name="1808"></a>                || action.ofKind(PutInAction)
<a name="1809"></a>                || action.ofKind(PutOnAction));
<a name="1810"></a>    }
<a name="1811"></a>
<a name="1812"></a>    /* don't hide from defaults, though */
<a name="1813"></a>    hideFromDefault(action) { return nil; }
<a name="1814"></a>
<a name="1815"></a>    /* a fixed item can't be moved by an actor action */
<a name="1816"></a>    verifyMoveTo(newLoc)
<a name="1817"></a>    {
<a name="1818"></a>        /* it's never possible to do this */
<a name="1819"></a>        illogical(cannotMoveMsg);
<a name="1820"></a>    }
<a name="1821"></a>
<a name="1822"></a>    /*
<a name="1823"></a>     *   a fixed item can't be taken - this would be caught by
<a name="1824"></a>     *   verifyMoveTo anyway, but provide a more explicit message when a
<a name="1825"></a>     *   fixed item is explicitly taken
<a name="1826"></a>     */
<a name="1827"></a>    dobjFor(Take) { verify() { illogical(cannotTakeMsg); }}
<a name="1828"></a>    dobjFor(TakeFrom) { verify() { illogical(cannotTakeMsg); }}
<a name="1829"></a>
<a name="1830"></a>    /* fixed objects can't be put anywhere */
<a name="1831"></a>    dobjFor(PutIn) { verify() { illogical(cannotPutMsg); }}
<a name="1832"></a>    dobjFor(PutOn) { verify() { illogical(cannotPutMsg); }}
<a name="1833"></a>    dobjFor(PutUnder) { verify() { illogical(cannotPutMsg); }}
<a name="1834"></a>    dobjFor(PutBehind) { verify() { illogical(cannotPutMsg); }}
<a name="1835"></a>
<a name="1836"></a>    /* fixed objects can't be pushed, pulled, or moved */
<a name="1837"></a>    dobjFor(Push) { verify() { illogical(cannotMoveMsg); }}
<a name="1838"></a>    dobjFor(Pull) { verify() { illogical(cannotMoveMsg); }}
<a name="1839"></a>    dobjFor(Move) { verify() { illogical(cannotMoveMsg); }}
<a name="1840"></a>    dobjFor(MoveWith) { verify() { illogical(cannotMoveMsg); }}
<a name="1841"></a>    dobjFor(MoveTo) { verify() { illogical(cannotMoveMsg); }}
<a name="1842"></a>    dobjFor(PushTravel) { verify() { illogical(cannotMoveMsg); }}
<a name="1843"></a>    dobjFor(ThrowAt) { verify() { illogical(cannotMoveMsg); }}
<a name="1844"></a>    dobjFor(ThrowDir) { verify() { illogical(cannotMoveMsg); }}
<a name="1845"></a>
<a name="1846"></a>    /*
<a name="1847"></a>     *   The messages to use for illogical messages.  These can be
<a name="1848"></a>     *   overridden with new properties (of playerActionMessages and the
<a name="1849"></a>     *   like), or simply with single-quoted strings to display.
<a name="1850"></a>     */
<a name="1851"></a>    cannotTakeMsg = &amp;cannotTakeFixtureMsg
<a name="1852"></a>    cannotMoveMsg = &amp;cannotMoveFixtureMsg
<a name="1853"></a>    cannotPutMsg = &amp;cannotPutFixtureMsg
<a name="1854"></a>
<a name="1855"></a>    /*
<a name="1856"></a>     *   A component can be said to be owned by its location's owner or by
<a name="1857"></a>     *   its location.
<a name="1858"></a>     */
<a name="1859"></a>    isOwnedBy(obj)
<a name="1860"></a>    {
<a name="1861"></a>        /*
<a name="1862"></a>         *   if I'm owned by the object under the normal rules, then we
<a name="1863"></a>         *   won't say otherwise
<a name="1864"></a>         */
<a name="1865"></a>        if (inherited(obj))
<a name="1866"></a>            return true;
<a name="1867"></a>
<a name="1868"></a>        /*
<a name="1869"></a>         *   we can be said to be owned by our location, since we're a
<a name="1870"></a>         *   direct and permanent part of the location
<a name="1871"></a>         */
<a name="1872"></a>        if (obj == location)
<a name="1873"></a>            return true;
<a name="1874"></a>
<a name="1875"></a>        /*
<a name="1876"></a>         *   if my location is owned by the given object, consider
<a name="1877"></a>         *   ourselves owned by it as well, as we're an extension of our
<a name="1878"></a>         *   location
<a name="1879"></a>         */
<a name="1880"></a>        if (location != nil &amp;&amp; location.isOwnedBy(obj))
<a name="1881"></a>            return true;
<a name="1882"></a>
<a name="1883"></a>        /* we didn't find anything that establishes ownership */
<a name="1884"></a>        return nil;
<a name="1885"></a>    }
<a name="1886"></a>;
<a name="1887"></a>
<a name="1888"></a>/*
<a name="1889"></a> *   A component object.  These objects cannot be removed from their
<a name="1890"></a> *   containers because they are permanent features of other objects, which
<a name="1891"></a> *   may themselves be portable: the hands of a watch, a tuning dial on a
<a name="1892"></a> *   radio.  This class behaves essentially the same way as Fixture, but
<a name="1893"></a> *   its messages are more suitable for objects that are component parts of
<a name="1894"></a> *   other objects rather than fixed features of rooms.
<a name="1895"></a> */
<a name="1896"></a>class Component: Fixture
<a name="1897"></a>    /* a component cannot be removed from its container by an actor action */
<a name="1898"></a>    verifyMoveTo(newLoc)
<a name="1899"></a>    {
<a name="1900"></a>        /* it's never possible to do this */
<a name="1901"></a>        illogical(&amp;cannotMoveComponentMsg, location);
<a name="1902"></a>    }
<a name="1903"></a>
<a name="1904"></a>    /*
<a name="1905"></a>     *   Hide components from EXAMINE ALL, as well as any commands hidden
<a name="1906"></a>     *   from ALL for ordinary fixtures.  Components are small parts of
<a name="1907"></a>     *   larger objects, so when we EXAMINE ALL, it's enough to examine the
<a name="1908"></a>     *   larger objects of which we're a part; we don't want components to
<a name="1909"></a>     *   show up separately in these cases.
<a name="1910"></a>     */
<a name="1911"></a>    hideFromAll(action)
<a name="1912"></a>    {
<a name="1913"></a>        /* hide from EXAMINE ALL, plus anything the base class hides */
<a name="1914"></a>        return (action.ofKind(ExamineAction)
<a name="1915"></a>                || inherited(action));
<a name="1916"></a>    }
<a name="1917"></a>
<a name="1918"></a>    /*
<a name="1919"></a>     *   We are a component of our direct cotnainer, and we're indirectly a
<a name="1920"></a>     *   component of anything that it's a component of.
<a name="1921"></a>     */
<a name="1922"></a>    isComponentOf(obj)
<a name="1923"></a>    {
<a name="1924"></a>        return (obj == location
<a name="1925"></a>                || (location != nil &amp;&amp; location.isComponentOf(obj)));
<a name="1926"></a>    }
<a name="1927"></a>
<a name="1928"></a>    /*
<a name="1929"></a>     *   Consider ourself to be held by the given actor if we're a
<a name="1930"></a>     *   component of the actor.
<a name="1931"></a>     */
<a name="1932"></a>    meetsObjHeld(actor) { return isComponentOf(actor); }
<a name="1933"></a>
<a name="1934"></a>    /* a component cannot be taken separately */
<a name="1935"></a>    dobjFor(Take)
<a name="1936"></a>        { verify() { illogical(&amp;cannotTakeComponentMsg, location); }}
<a name="1937"></a>    dobjFor(TakeFrom)
<a name="1938"></a>        { verify() { illogical(&amp;cannotTakeComponentMsg, location); }}
<a name="1939"></a>
<a name="1940"></a>    /* a component cannot be separately put somewhere */
<a name="1941"></a>    dobjFor(PutIn)
<a name="1942"></a>        { verify() { illogical(&amp;cannotPutComponentMsg, location); }}
<a name="1943"></a>    dobjFor(PutOn)
<a name="1944"></a>        { verify() { illogical(&amp;cannotPutComponentMsg, location); }}
<a name="1945"></a>    dobjFor(PutUnder)
<a name="1946"></a>        { verify() { illogical(&amp;cannotPutComponentMsg, location); }}
<a name="1947"></a>    dobjFor(PutBehind)
<a name="1948"></a>        { verify() { illogical(&amp;cannotPutComponentMsg, location); }}
<a name="1949"></a>;
<a name="1950"></a>
<a name="1951"></a>/*
<a name="1952"></a> *   A "secret fixture" is a kind of fixture that we use for internal
<a name="1953"></a> *   implementation purposes, and which we don't intend to be visible to
<a name="1954"></a> *   the player.  Objects of this type usually have no vocabulary, since we
<a name="1955"></a> *   don't want the player to be able to refer to them.
<a name="1956"></a> */
<a name="1957"></a>class SecretFixture: Fixture
<a name="1958"></a>    /*
<a name="1959"></a>     *   this kind of object is internal to the game's implementation, so
<a name="1960"></a>     *   we don't want it to show up in "all" lists
<a name="1961"></a>     */
<a name="1962"></a>    hideFromAll(action) { return true; }
<a name="1963"></a>;
<a name="1964"></a>
<a name="1965"></a>/*
<a name="1966"></a> *   A fixture that uses the same custom message for taking, moving, and
<a name="1967"></a> *   putting.  In many cases, it's useful to customize the message for a
<a name="1968"></a> *   fixture, using the same custom message for all sorts of moving.  Just
<a name="1969"></a> *   override cannotTakeMsg, and the other messages will copy it.
<a name="1970"></a> */
<a name="1971"></a>class CustomFixture: Fixture
<a name="1972"></a>    cannotMoveMsg = (cannotTakeMsg)
<a name="1973"></a>    cannotPutMsg = (cannotTakeMsg)
<a name="1974"></a>;
<a name="1975"></a>
<a name="1976"></a>/* ------------------------------------------------------------------------ */
<a name="1977"></a>/*
<a name="1978"></a> *   An Immovable is an object that can't be moved, but not because it's
<a name="1979"></a> *   obviously a fixture or component of another object.  This class is
<a name="1980"></a> *   suitable for things like furniture, which are in principle portable
<a name="1981"></a> *   but which actors aren't actually allowed to pick up or move around.
<a name="1982"></a> *
<a name="1983"></a> *   Note that Immovable is a lot like Fixture.  The difference is that
<a name="1984"></a> *   Fixture is for objects that are *obviously* fixed in place by their
<a name="1985"></a> *   very nature, whereas Immovable is for objects that common sense would
<a name="1986"></a> *   tell us are portable, but which the game doesn't in fact allow the
<a name="1987"></a> *   player to move.
<a name="1988"></a> *
<a name="1989"></a> *   The practical difference between Immovable and Fixture is that Fixture
<a name="1990"></a> *   considers taking or moving to be illogical actions, whereas Immovable
<a name="1991"></a> *   considers these actions logical but simply doesn't allow them.  To be
<a name="1992"></a> *   more specific, Fixture disallows taking and moving in the verify()
<a name="1993"></a> *   methods for those actions, while Immovable disallows the actions in
<a name="1994"></a> *   the check() methods.  This means, for example, that Fixture objects
<a name="1995"></a> *   will be removed from consideration during the noun resolution phase
<a name="1996"></a> *   when there are more logical choices.
<a name="1997"></a> */
<a name="1998"></a>class Immovable: NonPortable
<a name="1999"></a>    /* an Immovable can't be taken */
<a name="2000"></a>    dobjFor(Take) { check() { failCheck(cannotTakeMsg); }}
<a name="2001"></a>
<a name="2002"></a>    /* Immovables can't be put anywhere */
<a name="2003"></a>    dobjFor(PutIn) { check() { failCheck(cannotPutMsg); }}
<a name="2004"></a>    dobjFor(PutOn) { check() { failCheck(cannotPutMsg); }}
<a name="2005"></a>    dobjFor(PutUnder) { check() { failCheck(cannotPutMsg); }}
<a name="2006"></a>    dobjFor(PutBehind) { check() { failCheck(cannotPutMsg); }}
<a name="2007"></a>
<a name="2008"></a>    /* Immovables can't be pushed, pulled, or otherwise moved */
<a name="2009"></a>    dobjFor(Drop) { action() { reportFailure(cannotMoveMsg); }}
<a name="2010"></a>    dobjFor(Push) { action() { reportFailure(cannotMoveMsg); }}
<a name="2011"></a>    dobjFor(Pull) { action() { reportFailure(cannotMoveMsg); }}
<a name="2012"></a>    dobjFor(Move) { action() { reportFailure(cannotMoveMsg); }}
<a name="2013"></a>    dobjFor(MoveWith) { check() { failCheck(cannotMoveMsg); }}
<a name="2014"></a>    dobjFor(MoveTo) { check() { failCheck(cannotMoveMsg); }}
<a name="2015"></a>    dobjFor(PushTravel) { action() { reportFailure(cannotMoveMsg); }}
<a name="2016"></a>    dobjFor(ThrowAt) { verify() { illogical(cannotMoveMsg); }}
<a name="2017"></a>    dobjFor(ThrowDir) { verify() { illogical(cannotMoveMsg); }}
<a name="2018"></a>    dobjFor(Turn)
<a name="2019"></a>    {
<a name="2020"></a>        verify() { logicalRank(50, 'turn heavy'); }
<a name="2021"></a>        action() { reportFailure(cannotMoveMsg); }
<a name="2022"></a>    }
<a name="2023"></a>
<a name="2024"></a>    /*
<a name="2025"></a>     *   The messages to use for the failure messages.  These can be
<a name="2026"></a>     *   overridden with new properties (of playerActionMessages and the
<a name="2027"></a>     *   like), or simply with single-quoted strings to display.
<a name="2028"></a>     */
<a name="2029"></a>    cannotTakeMsg = &amp;cannotTakeImmovableMsg
<a name="2030"></a>    cannotMoveMsg = &amp;cannotMoveImmovableMsg
<a name="2031"></a>    cannotPutMsg = &amp;cannotPutImmovableMsg
<a name="2032"></a>;
<a name="2033"></a>
<a name="2034"></a>/*
<a name="2035"></a> *   An immovable that uses the same custom message for taking, moving, and
<a name="2036"></a> *   putting.  In many cases, it's useful to customize the message for an
<a name="2037"></a> *   immovable, using the same custom message for all sorts of moving.
<a name="2038"></a> *   Just override cannotTakeMsg, and the other messages will copy it.
<a name="2039"></a> */
<a name="2040"></a>class CustomImmovable: Immovable
<a name="2041"></a>    cannotMoveMsg = (cannotTakeMsg)
<a name="2042"></a>    cannotPutMsg = (cannotTakeMsg)
<a name="2043"></a>;
<a name="2044"></a>
<a name="2045"></a>/*
<a name="2046"></a> *   Heavy: an object that's immovable because it's very heavy.  This is
<a name="2047"></a> *   suitable for things like large boulders, heavy furniture, or the like:
<a name="2048"></a> *   things that aren't nailed down, but nonetheless are too heavy to be
<a name="2049"></a> *   carried or otherwise move.
<a name="2050"></a> *
<a name="2051"></a> *   This is a simple specialization of Immovable; the only thing we change
<a name="2052"></a> *   is the messages we use to describe why the object can't be moved.
<a name="2053"></a> */
<a name="2054"></a>class Heavy: Immovable
<a name="2055"></a>    cannotTakeMsg = &amp;cannotTakeHeavyMsg
<a name="2056"></a>    cannotMoveMsg = &amp;cannotMoveHeavyMsg
<a name="2057"></a>    cannotPutMsg = &amp;cannotPutHeavyMsg
<a name="2058"></a>;
<a name="2059"></a>
<a name="2060"></a>
<a name="2061"></a>/* ------------------------------------------------------------------------ */
<a name="2062"></a>/*
<a name="2063"></a> *   Decoration.  This is an object that is included for scenery value but
<a name="2064"></a> *   which has no other purpose, and which the author wants to make clear
<a name="2065"></a> *   is not important.  We use the catch-all action routine to respond to
<a name="2066"></a> *   any command on this object with a flat "that's not important"
<a name="2067"></a> *   message, so that the player can plainly see that there's no point
<a name="2068"></a> *   wasting any time trying to manipulate this object.
<a name="2069"></a> *
<a name="2070"></a> *   We use the "default" catch-all verb verify handling to report our
<a name="2071"></a> *   "that's not important" message, so a decoration can be made
<a name="2072"></a> *   responsive to specific verbs simply by defining an action handler for
<a name="2073"></a> *   those verbs.
<a name="2074"></a> */
<a name="2075"></a>class Decoration: Fixture
<a name="2076"></a>    /* don't include decorations in 'all' */
<a name="2077"></a>    hideFromAll(action) { return true; }
<a name="2078"></a>
<a name="2079"></a>    /* don't hide from defaults */
<a name="2080"></a>    hideFromDefault(action) { return nil; }
<a name="2081"></a>
<a name="2082"></a>    /*
<a name="2083"></a>     *   use the default response "this object isn't important" when we're
<a name="2084"></a>     *   used as either a direct or indirect object
<a name="2085"></a>     */
<a name="2086"></a>    dobjFor(Default)
<a name="2087"></a>    {
<a name="2088"></a>        verify() { illogical(notImportantMsg, self); }
<a name="2089"></a>    }
<a name="2090"></a>    iobjFor(Default)
<a name="2091"></a>    {
<a name="2092"></a>        verify() { illogical(notImportantMsg, self); }
<a name="2093"></a>    }
<a name="2094"></a>
<a name="2095"></a>    /* use the standard not-important message for decorations */
<a name="2096"></a>    notImportantMsg = &amp;decorationNotImportantMsg
<a name="2097"></a>
<a name="2098"></a>    /*
<a name="2099"></a>     *   The catch-all Default verifier makes all actions illogical, but we
<a name="2100"></a>     *   can override this to allow specific actions by explicitly defining
<a name="2101"></a>     *   them here so that they hide the Default verify handlers.  In
<a name="2102"></a>     *   addition, give decorations a reduced logical rank, so that any
<a name="2103"></a>     *   in-scope non-decoration object with similar vocabulary will be
<a name="2104"></a>     *   matched for an Examine command ahead of a decoration.
<a name="2105"></a>     */
<a name="2106"></a>    dobjFor(Examine)
<a name="2107"></a>        { verify() { inherited(); logicalRank(70, 'decoration'); } }
<a name="2108"></a>
<a name="2109"></a>    /*
<a name="2110"></a>     *   likewise for LISTEN TO and SMELL, which are the auditory and
<a name="2111"></a>     *   olfactory equivalents of EXAMINE
<a name="2112"></a>     */
<a name="2113"></a>    dobjFor(ListenTo)
<a name="2114"></a>        { verify() { inherited(); logicalRank(70, 'decoration'); } }
<a name="2115"></a>    dobjFor(Smell)
<a name="2116"></a>        { verify() { inherited(); logicalRank(70, 'decoration'); } }
<a name="2117"></a>
<a name="2118"></a>    /* likewise for READ */
<a name="2119"></a>    dobjFor(Read)
<a name="2120"></a>        { verify() { inherited(); logicalRank(70, 'decoration'); } }
<a name="2121"></a>
<a name="2122"></a>    /* likewise for LOOK IN and SEARCH */
<a name="2123"></a>    dobjFor(LookIn)
<a name="2124"></a>        { verify() { inherited(); logicalRank(70, 'decoration'); } }
<a name="2125"></a>    dobjFor(Search)
<a name="2126"></a>        { verify() { inherited(); logicalRank(70, 'decoration'); } }
<a name="2127"></a>
<a name="2128"></a>    /* the default LOOK IN response is our standard "that's not important" */
<a name="2129"></a>    lookInDesc { mainReport(&amp;notImportantMsg, self); }
<a name="2130"></a>;
<a name="2131"></a>
<a name="2132"></a>/* ------------------------------------------------------------------------ */
<a name="2133"></a>/*
<a name="2134"></a> *   An "unthing" is an object that represents the *absence* of an object.
<a name="2135"></a> *   It's occasionally useful to respond specially when the player mentions
<a name="2136"></a> *   an object that isn't present, especially when the player is likely to
<a name="2137"></a> *   assume that something is present.
<a name="2138"></a> *
<a name="2139"></a> *   An unthing is essentially a decoration, but we use a customized
<a name="2140"></a> *   message that says "that isn't here" rather than "that isn't
<a name="2141"></a> *   important".
<a name="2142"></a> */
<a name="2143"></a>class Unthing: Decoration
<a name="2144"></a>    /*
<a name="2145"></a>     *   The message to display when the player refers to this object.
<a name="2146"></a>     *   This can be a library message property, or a single-quoted string.
<a name="2147"></a>     *   This message will probably always be overridden in practice, since
<a name="2148"></a>     *   the point of this class is to provide a more specific explanation
<a name="2149"></a>     *   of why the object isn't here.
<a name="2150"></a>     */
<a name="2151"></a>    notHereMsg = &amp;unthingNotHereMsg
<a name="2152"></a>
<a name="2153"></a>    /* an Unthing shouldn't be picked as a default */
<a name="2154"></a>    hideFromDefault(action) { return true; }
<a name="2155"></a>
<a name="2156"></a>    /*
<a name="2157"></a>     *   by default, use our 'not here' message for our descriptions (in
<a name="2158"></a>     *   all of the standard senses)
<a name="2159"></a>     */
<a name="2160"></a>    basicExamine() { mainReport(notHereMsg, self); }
<a name="2161"></a>    basicExamineListen(explicit)
<a name="2162"></a>    {
<a name="2163"></a>        if (explicit)
<a name="2164"></a>            mainReport(notHereMsg, self);
<a name="2165"></a>    }
<a name="2166"></a>    basicExamineSmell(explicit)
<a name="2167"></a>    {
<a name="2168"></a>        if (explicit)
<a name="2169"></a>            mainReport(notHereMsg, self);
<a name="2170"></a>    }
<a name="2171"></a>
<a name="2172"></a>    /* use our custom message for the inherited Decoration responses */
<a name="2173"></a>    notImportantMsg = (notHereMsg)
<a name="2174"></a>
<a name="2175"></a>    /*
<a name="2176"></a>     *   Because we're not actually here, use custom error messages when
<a name="2177"></a>     *   we're used as a possessive or locational qualifier.  The standard
<a name="2178"></a>     *   messages say things like "Bob doesn't appear to have that" or "You
<a name="2179"></a>     *   don't see that in the box," but these don't make sense for an
<a name="2180"></a>     *   Unthing - we're not actually here, so we can't "appear" or "seem"
<a name="2181"></a>     *   to own or contain anything.  Instead, we need to indicate that the
<a name="2182"></a>     *   qualifying object itself (i.e., 'self') isn't here at all.
<a name="2183"></a>     */
<a name="2184"></a>    throwNoMatchForPossessive(txt) { throwUnthingAsQualifier(); }
<a name="2185"></a>    throwNoMatchForLocation(txt) { throwUnthingAsQualifier(); }
<a name="2186"></a>    throwNothingInLocation() { throwUnthingAsQualifier(); }
<a name="2187"></a>
<a name="2188"></a>    /*
<a name="2189"></a>     *   throw a generic message when we're used as a qualifier - we'll
<a name="2190"></a>     *   simply get our "not here" message and display that
<a name="2191"></a>     */
<a name="2192"></a>    throwUnthingAsQualifier()
<a name="2193"></a>    {
<a name="2194"></a>        local msg;
<a name="2195"></a>
<a name="2196"></a>        /*
<a name="2197"></a>         *   resolve our "not here" message to a string - we need to do
<a name="2198"></a>         *   this here, since we're too early in the parsing sequence for
<a name="2199"></a>         *   the normal "mainResult" type of processing
<a name="2200"></a>         */
<a name="2201"></a>        msg = MessageResult.resolveMessageText([self], &amp;notHereMsg, [self]);
<a name="2202"></a>
<a name="2203"></a>        /* throw a parser exception that will display this literal text */
<a name="2204"></a>        throw new ParseFailureException(&amp;parserErrorString, msg);
<a name="2205"></a>    }
<a name="2206"></a>
<a name="2207"></a>    /*
<a name="2208"></a>     *   if there's anything at all in a resolve list other than me, always
<a name="2209"></a>     *   remove me
<a name="2210"></a>     */
<a name="2211"></a>    filterResolveList(lst, action, whichObj, np, requiredNum)
<a name="2212"></a>    {
<a name="2213"></a>        /* if the list has anything else in it, remove myself */
<a name="2214"></a>        if (lst.length() != 1)
<a name="2215"></a>            lst = lst.removeElementAt(lst.indexWhich({x: x.obj_ == self}));
<a name="2216"></a>
<a name="2217"></a>        /* return the list */
<a name="2218"></a>        return lst;
<a name="2219"></a>    }
<a name="2220"></a>
<a name="2221"></a>    /*
<a name="2222"></a>     *   trying to given an order to an Unthing acts the same way as any
<a name="2223"></a>     *   other kind of interaction
<a name="2224"></a>     */
<a name="2225"></a>    acceptCommand(issuingActor) { mainReport(notHereMsg, self); }
<a name="2226"></a>;
<a name="2227"></a>
<a name="2228"></a>
<a name="2229"></a>/* ------------------------------------------------------------------------ */
<a name="2230"></a>/*
<a name="2231"></a> *   Distant item.  This is an object that's too far away to manipulate,
<a name="2232"></a> *   but can be seen.  This is useful for scenery objects that are at a
<a name="2233"></a> *   great distance within a large location.
<a name="2234"></a> *
<a name="2235"></a> *   A Distant item is essentially just like a decoration, but the default
<a name="2236"></a> *   message is different.  Note that this class is based on Fixture, which
<a name="2237"></a> *   means that it should be *obvious* that the object is too far away to
<a name="2238"></a> *   take or move.
<a name="2239"></a> */
<a name="2240"></a>class Distant: Fixture
<a name="2241"></a>    /* don't include in 'all' */
<a name="2242"></a>    hideFromAll(action) { return true; }
<a name="2243"></a>
<a name="2244"></a>    dobjFor(Default)
<a name="2245"></a>    {
<a name="2246"></a>        verify() { illogical(&amp;tooDistantMsg, self); }
<a name="2247"></a>    }
<a name="2248"></a>    iobjFor(Default)
<a name="2249"></a>    {
<a name="2250"></a>        verify() { illogical(&amp;tooDistantMsg, self); }
<a name="2251"></a>    }
<a name="2252"></a>
<a name="2253"></a>    /*
<a name="2254"></a>     *   Explicitly allow examining and listening to a Distant item.  To
<a name="2255"></a>     *   do this, override the 'verify' methods explicitly; we only need
<a name="2256"></a>     *   to inherit the base class handling, but we need to explicitly do
<a name="2257"></a>     *   so to 'override' the catch-all default handlers.
<a name="2258"></a>     */
<a name="2259"></a>    dobjFor(Examine) { verify { inherited() ; } }
<a name="2260"></a>    dobjFor(ListenTo) { verify() { inherited(); } }
<a name="2261"></a>
<a name="2262"></a>    /* similarly, allow showing a distant item */
<a name="2263"></a>    dobjFor(ShowTo) { verify() { inherited(); } }
<a name="2264"></a>;
<a name="2265"></a>
<a name="2266"></a>/*
<a name="2267"></a> *   Out Of Reach - this is a special mix-in that can be used to create an
<a name="2268"></a> *   object that places its *contents* out of reach under customizable
<a name="2269"></a> *   conditions, and can optionally place itself out of reach as well.
<a name="2270"></a> */
<a name="2271"></a>class OutOfReach: object
<a name="2272"></a>    checkTouchViaPath(obj, dest, op)
<a name="2273"></a>    {
<a name="2274"></a>        /* check how we're traversing the object */
<a name="2275"></a>        if (op == PathTo)
<a name="2276"></a>        {
<a name="2277"></a>            /*
<a name="2278"></a>             *   we're reaching from outside for this object itself -
<a name="2279"></a>             *   check to see if the source can reach me
<a name="2280"></a>             */
<a name="2281"></a>            if (!canObjReachSelf(obj))
<a name="2282"></a>                return new CheckStatusFailure(
<a name="2283"></a>                    cannotReachFromOutsideMsg(dest), dest);
<a name="2284"></a>        }
<a name="2285"></a>        else if (op == PathIn)
<a name="2286"></a>        {
<a name="2287"></a>            /*
<a name="2288"></a>             *   we're reaching in to touch one of my contents - check to
<a name="2289"></a>             *   see if the source object is within reach of my contents
<a name="2290"></a>             */
<a name="2291"></a>            if (!canObjReachContents(obj))
<a name="2292"></a>                return new CheckStatusFailure(
<a name="2293"></a>                    cannotReachFromOutsideMsg(dest), dest);
<a name="2294"></a>        }
<a name="2295"></a>        else if (op == PathOut)
<a name="2296"></a>        {
<a name="2297"></a>            local ok;
<a name="2298"></a>
<a name="2299"></a>            /*
<a name="2300"></a>             *   We're reaching out.  If we're reaching for the object
<a name="2301"></a>             *   itself, check to see if we're reachable from within;
<a name="2302"></a>             *   otherwise, check to see if we can reach objects outside
<a name="2303"></a>             *   us from within.
<a name="2304"></a>             */
<a name="2305"></a>            if (dest == self)
<a name="2306"></a>                ok = canReachSelfFromInside(obj);
<a name="2307"></a>            else
<a name="2308"></a>                ok = canReachFromInside(obj, dest);
<a name="2309"></a>
<a name="2310"></a>            /* if we can't reach the object, say so */
<a name="2311"></a>            if (!ok)
<a name="2312"></a>                return new CheckStatusFailure(
<a name="2313"></a>                    cannotReachFromInsideMsg(dest), dest);
<a name="2314"></a>        }
<a name="2315"></a>
<a name="2316"></a>        /* if we didn't find a problem, allow the operation */
<a name="2317"></a>        return checkStatusSuccess;
<a name="2318"></a>    }
<a name="2319"></a>
<a name="2320"></a>    /*
<a name="2321"></a>     *   The message to use to indicate that we can't reach an object,
<a name="2322"></a>     *   because the actor is outside me and the target is inside, or vice
<a name="2323"></a>     *   versa.  Each of these can return a property ID giving an actor
<a name="2324"></a>     *   action message property, or can simply return a string with the
<a name="2325"></a>     *   message text.
<a name="2326"></a>     */
<a name="2327"></a>    cannotReachFromOutsideMsg(dest) { return &amp;tooDistantMsg; }
<a name="2328"></a>    cannotReachFromInsideMsg(dest) { return  &amp;tooDistantMsg; }
<a name="2329"></a>
<a name="2330"></a>    /*
<a name="2331"></a>     *   Determine if the given object can reach my contents.  'obj' is
<a name="2332"></a>     *   the object (usually an actor) attempting to reach my contents
<a name="2333"></a>     *   from outside of me.
<a name="2334"></a>     *
<a name="2335"></a>     *   By default, we'll return nil, so that nothing within me can be
<a name="2336"></a>     *   reached from anyone outside.  This can be overridden to allow my
<a name="2337"></a>     *   contents to become reachable from some external locations but not
<a name="2338"></a>     *   others; for example, a high shelf could allow an actor standing
<a name="2339"></a>     *   on a chair to reach my contents.
<a name="2340"></a>     */
<a name="2341"></a>    canObjReachContents(obj) { return nil; }
<a name="2342"></a>
<a name="2343"></a>    /*
<a name="2344"></a>     *   Determine if the given object can reach me.  'obj' is the object
<a name="2345"></a>     *   (usually an actor) attempting to reach this object.
<a name="2346"></a>     *
<a name="2347"></a>     *   By default, make this object subject to the same rules as its
<a name="2348"></a>     *   contents.
<a name="2349"></a>     */
<a name="2350"></a>    canObjReachSelf(obj) { return canObjReachContents(obj); }
<a name="2351"></a>
<a name="2352"></a>    /*
<a name="2353"></a>     *   Determine if the given object outside of me is reachable from
<a name="2354"></a>     *   within me.  'obj' (usually an actor) is attempting to reach
<a name="2355"></a>     *   'dest'.
<a name="2356"></a>     *
<a name="2357"></a>     *   By default, we return nil, so nothing outside of me is reachable
<a name="2358"></a>     *   from within me.  This can be overridden as needed.  This should
<a name="2359"></a>     *   usually behave symmetrically with canObjReachContents().
<a name="2360"></a>     */
<a name="2361"></a>    canReachFromInside(obj, dest) { return nil; }
<a name="2362"></a>
<a name="2363"></a>    /*
<a name="2364"></a>     *   Determine if we can reach this object itself from within.  This
<a name="2365"></a>     *   is used when 'obj' tries to touch this object when 'obj' is
<a name="2366"></a>     *   located within this object.
<a name="2367"></a>     *
<a name="2368"></a>     *   By default, we we use the same rules as we use to reach an
<a name="2369"></a>     *   external object from within.
<a name="2370"></a>     */
<a name="2371"></a>    canReachSelfFromInside(obj) { return canReachFromInside(obj, self); }
<a name="2372"></a>
<a name="2373"></a>    /*
<a name="2374"></a>     *   We cannot implicitly remove this obstruction, so simply return
<a name="2375"></a>     *   nil when asked.
<a name="2376"></a>     */
<a name="2377"></a>    tryImplicitRemoveObstructor(sense, obj) { return nil; }
<a name="2378"></a>;
<a name="2379"></a>
<a name="2380"></a>/* ------------------------------------------------------------------------ */
<a name="2381"></a>/*
<a name="2382"></a> *   A Fill Medium - this is the class of object returned from
<a name="2383"></a> *   Thing.fillMedium().
<a name="2384"></a> */
<a name="2385"></a>class FillMedium: Thing
<a name="2386"></a>    /*
<a name="2387"></a>     *   Get the transparency sensing through this medium.
<a name="2388"></a>     */
<a name="2389"></a>    senseThru(sense)
<a name="2390"></a>    {
<a name="2391"></a>        /*
<a name="2392"></a>         *   if I have a meterial, use its transparency; otherwise, we're
<a name="2393"></a>         *   transparent
<a name="2394"></a>         */
<a name="2395"></a>        return (material != nil ? material.senseThru(sense) : transparent);
<a name="2396"></a>    }
<a name="2397"></a>
<a name="2398"></a>    /* my material */
<a name="2399"></a>    material = nil
<a name="2400"></a>;
<a name="2401"></a>
<a name="2402"></a>/* ------------------------------------------------------------------------ */
<a name="2403"></a>/*
<a name="2404"></a> *   Base multi-location item with automatic initialization.  This is the
<a name="2405"></a> *   base class for various multi-located object classes.
<a name="2406"></a> *
<a name="2407"></a> *   We provide four ways of initializing a multi-located object's set of
<a name="2408"></a> *   locations.
<a name="2409"></a> *
<a name="2410"></a> *   First, the object can simply enumerate the locations explicitly, by
<a name="2411"></a> *   setting the 'locationList' property to the list of locations.
<a name="2412"></a> *
<a name="2413"></a> *   Second, the object can indicate that it's located in every object of a
<a name="2414"></a> *   given class, by setting the 'initialLocationClass' property to the
<a name="2415"></a> *   desired class.
<a name="2416"></a> *
<a name="2417"></a> *   Third, the object can define a rule that specifies which objects are
<a name="2418"></a> *   its initial locations, by defining the 'isInitiallyIn(obj)' method to
<a name="2419"></a> *   return true if 'obj' is an initial location, nil if not.  This can be
<a name="2420"></a> *   combined with the 'initialLocationClass' mechanism: if
<a name="2421"></a> *   'initialLocationClass' is non-nil, then only objects of the given
<a name="2422"></a> *   class will be tested with 'isInitiallyIn()'; if 'initialLocationClass'
<a name="2423"></a> *   is nil, then every object in the entire game will be tested.
<a name="2424"></a> *
<a name="2425"></a> *   Fourth, you can override the method buildLocationList() to build an
<a name="2426"></a> *   return the initial list of locations.  You can use this approach if
<a name="2427"></a> *   you have a complex set of rules for determining the initial location
<a name="2428"></a> *   list, and none of the above approaches are flexible enough to
<a name="2429"></a> *   implement it.  If you override buildLocationList(), simply compute and
<a name="2430"></a> *   return the list of initial locations; the library will automatically
<a name="2431"></a> *   call the method during pre-initialization.
<a name="2432"></a> *
<a name="2433"></a> *   If you don't define any of these, then the object simply has no
<a name="2434"></a> *   initial locations by default.
<a name="2435"></a> */
<a name="2436"></a>class BaseMultiLoc: object
<a name="2437"></a>    /*
<a name="2438"></a>     *   The location list.  Instances can override this to manually
<a name="2439"></a>     *   enumerate our initial locations.  By default, we'll call
<a name="2440"></a>     *   buildLocationList() the first time this is invoked, and store the
<a name="2441"></a>     *   result.
<a name="2442"></a>     */
<a name="2443"></a>    locationList = perInstance(buildLocationList())
<a name="2444"></a>
<a name="2445"></a>    /*
<a name="2446"></a>     *   The class of our initial locations.  If this is nil, then our
<a name="2447"></a>     *   default buildLocationList() method will test every object in the
<a name="2448"></a>     *   entire game with our isInitiallyIn() method; otherwise, we'll test
<a name="2449"></a>     *   only objects of the given class.
<a name="2450"></a>     */
<a name="2451"></a>    initialLocationClass = nil
<a name="2452"></a>
<a name="2453"></a>    /*
<a name="2454"></a>     *   Test an object for inclusion in our initial location list.  By
<a name="2455"></a>     *   default, we'll simply return true to include every object.  We
<a name="2456"></a>     *   return true by default so that an instance can merely specify a
<a name="2457"></a>     *   value for initialLocationClass in order to place this object in
<a name="2458"></a>     *   every instance of the given class.
<a name="2459"></a>     */
<a name="2460"></a>    isInitiallyIn(obj) { return true; }
<a name="2461"></a>
<a name="2462"></a>    /*
<a name="2463"></a>     *   Build my list of locations, and return the list.  This default
<a name="2464"></a>     *   implementation looks for an 'initialLocationClass' property value,
<a name="2465"></a>     *   and if one is found, looks at every object of that class;
<a name="2466"></a>     *   otherwise, it looks at every object in the entire game.  In either
<a name="2467"></a>     *   case, each object is then passed to our isInitiallyIn() method,
<a name="2468"></a>     *   and is included in our result list if isInitiallyIn() returns
<a name="2469"></a>     *   true.
<a name="2470"></a>     */
<a name="2471"></a>    buildLocationList()
<a name="2472"></a>    {
<a name="2473"></a>        /*
<a name="2474"></a>         *   If the object doesn't define any of the standard rules, which
<a name="2475"></a>         *   it would do by overriding initialLocationClass and/or
<a name="2476"></a>         *   isInitiallyIn(), then simply return an empty list.  We take
<a name="2477"></a>         *   the absence of overrides for any of the rules to mean that the
<a name="2478"></a>         *   object simply has no initial locations.
<a name="2479"></a>         */
<a name="2480"></a>        if (initialLocationClass == nil
<a name="2481"></a>            &amp;&amp; !overrides(self, BaseMultiLoc, &amp;isInitiallyIn))
<a name="2482"></a>            return [];
<a name="2483"></a>
<a name="2484"></a>        /* start with an empty list */
<a name="2485"></a>        local lst = new Vector(16);
<a name="2486"></a>
<a name="2487"></a>        /*
<a name="2488"></a>         *   if initialLocationClass is defined, loop over all objects of
<a name="2489"></a>         *   that class; otherwise, loop over all objects
<a name="2490"></a>         */
<a name="2491"></a>        if (initialLocationClass != nil)
<a name="2492"></a>        {
<a name="2493"></a>            /* loop over all instances of the given class */
<a name="2494"></a>            for (local obj = firstObj(initialLocationClass) ; obj != nil ;
<a name="2495"></a>                 obj = nextObj(obj, initialLocationClass))
<a name="2496"></a>            {
<a name="2497"></a>                /* if the object passes the test, include it */
<a name="2498"></a>                if (isInitiallyIn(obj))
<a name="2499"></a>                    lst.append(obj);
<a name="2500"></a>            }
<a name="2501"></a>        }
<a name="2502"></a>        else
<a name="2503"></a>        {
<a name="2504"></a>            /* loop over all objects */
<a name="2505"></a>            for (local obj = firstObj() ; obj != nil ; obj = nextObj(obj))
<a name="2506"></a>            {
<a name="2507"></a>                /* if the object passes the test, include it */
<a name="2508"></a>                if (isInitiallyIn(obj))
<a name="2509"></a>                    lst.append(obj);
<a name="2510"></a>            }
<a name="2511"></a>        }
<a name="2512"></a>
<a name="2513"></a>        /* return the list of locations */
<a name="2514"></a>        return lst.toList();
<a name="2515"></a>    }
<a name="2516"></a>
<a name="2517"></a>    /* determine if I'm in a given object, directly or indirectly */
<a name="2518"></a>    isIn(obj)
<a name="2519"></a>    {
<a name="2520"></a>        /* first, check to see if I'm directly in the given object */
<a name="2521"></a>        if (isDirectlyIn(obj))
<a name="2522"></a>            return true;
<a name="2523"></a>
<a name="2524"></a>        /*
<a name="2525"></a>         *   Look at each object in my location list.  For each location
<a name="2526"></a>         *   object, if the location is within the object, I'm within the
<a name="2527"></a>         *   object.
<a name="2528"></a>         */
<a name="2529"></a>        return locationList.indexWhich({loc: loc.isIn(obj)}) != nil;
<a name="2530"></a>    }
<a name="2531"></a>
<a name="2532"></a>    /* determine if I'm directly in the given object */
<a name="2533"></a>    isDirectlyIn(obj)
<a name="2534"></a>    {
<a name="2535"></a>        /*
<a name="2536"></a>         *   we're directly in the given object only if the object is in
<a name="2537"></a>         *   my list of immediate locations
<a name="2538"></a>         */
<a name="2539"></a>        return (locationList.indexOf(obj) != nil);
<a name="2540"></a>    }
<a name="2541"></a>
<a name="2542"></a>    /*
<a name="2543"></a>     *   Determine if I'm to be listed within my immediate container.  As a
<a name="2544"></a>     *   multi-location object, we have multiple immediate containers, so
<a name="2545"></a>     *   we need to know which direct container we're talking about.
<a name="2546"></a>     *   Thing.examineListContents() passes this down via "cont:", a named
<a name="2547"></a>     *   parameter.  Other callers might not always provide this argument,
<a name="2548"></a>     *   though, so if it's not present simply base this on whether we have
<a name="2549"></a>     *   a special description in any context.
<a name="2550"></a>     */
<a name="2551"></a>    isListedInContents(examinee:?)
<a name="2552"></a>    {
<a name="2553"></a>        return (examinee != nil
<a name="2554"></a>                ? !useSpecialDescInContents(examinee)
<a name="2555"></a>                : !useSpecialDesc());
<a name="2556"></a>    }
<a name="2557"></a>
<a name="2558"></a>    /* Am I either inside 'obj', or equal to 'obj'?  */
<a name="2559"></a>    isOrIsIn(obj) { return self == obj || isIn(obj); }
<a name="2560"></a>;
<a name="2561"></a>
<a name="2562"></a>/* ------------------------------------------------------------------------ */
<a name="2563"></a>/*
<a name="2564"></a> *   MultiLoc: this class can be multiply inherited by any object that
<a name="2565"></a> *   must exist in more than one place at a time.  To use this class, put
<a name="2566"></a> *   it BEFORE Thing (or any subclass of Thing) in the object's superclass
<a name="2567"></a> *   list, to ensure that we override the default containment
<a name="2568"></a> *   implementation for the object.
<a name="2569"></a> *
<a name="2570"></a> *   Note that a MultiLoc object appears *in its entirety* in each of its
<a name="2571"></a> *   locations.  This means that MultiLoc is most suitable for a couple of
<a name="2572"></a> *   specific situations:
<a name="2573"></a> *
<a name="2574"></a> *   - several locations overlap slightly so that they include a common
<a name="2575"></a> *   object: a large statue at the center of a public square, for example;
<a name="2576"></a> *
<a name="2577"></a> *   - an object forms a sense connection among its location: a window;
<a name="2578"></a> *
<a name="2579"></a> *   - a distant object that is seen in its entirety from several
<a name="2580"></a> *   locations: the moon, say, or a mountain range.
<a name="2581"></a> *
<a name="2582"></a> *   Note that MultiLoc is NOT suitable for cases where an object spans
<a name="2583"></a> *   several locations but isn't contained entirely in any one of them:
<a name="2584"></a> *   it's not good for something like a rope or a river, for example.
<a name="2585"></a> *   MultiLoc also isn't good for cases where you simply want to avoid
<a name="2586"></a> *   creating a bunch of repeated decorations in different locations.
<a name="2587"></a> *   MultiLoc isn't good for these cases because a MultiLoc is treated as
<a name="2588"></a> *   though it exists ENTIRELY and SIMULTANEOUSLY in all of its locations,
<a name="2589"></a> *   which means that all of its sense information and internal state is
<a name="2590"></a> *   shared among all of its locations.
<a name="2591"></a> *
<a name="2592"></a> *   MultiInstance is better than MultiLoc for cases where you want to
<a name="2593"></a> *   share a decoration object across several locations.  MultiInstance is
<a name="2594"></a> *   better because it creates individual copies of the object in the
<a name="2595"></a> *   different locations, so each copy has its own separate sense
<a name="2596"></a> *   information and its own separate identity.
<a name="2597"></a> *
<a name="2598"></a> *   MultiFaceted is better for objects that span several locations, such
<a name="2599"></a> *   as a river or a long rope.  Like MultiInstance, MultiFaceted creates
<a name="2600"></a> *   a separate copy in each location; in addition, MultiFaceted relates
<a name="2601"></a> *   the copies together as "facets" of the same object, so that the
<a name="2602"></a> *   parser knows they're all actually parts of one larger object.
<a name="2603"></a> */
<a name="2604"></a>class MultiLoc: BaseMultiLoc
<a name="2605"></a>    /*
<a name="2606"></a>     *   Initialize my location's contents list - add myself to my
<a name="2607"></a>     *   container during initialization
<a name="2608"></a>     */
<a name="2609"></a>    initializeLocation()
<a name="2610"></a>    {
<a name="2611"></a>        /* add myself to each of my container's contents lists */
<a name="2612"></a>        locationList.forEach({loc: loc.addToContents(self)});
<a name="2613"></a>    }
<a name="2614"></a>
<a name="2615"></a>    /*
<a name="2616"></a>     *   Re-initialize the location list.  This calls buildLocationList()
<a name="2617"></a>     *   to re-evaluate the location rules, then updates the locationList
<a name="2618"></a>     *   to match the new results.  We'll remove the MultiLoc from any old
<a name="2619"></a>     *   locations that are no longer part of the location list, and we'll
<a name="2620"></a>     *   add it to any new locations that weren't previously in the
<a name="2621"></a>     *   location list.  You can call this at any time to update the
<a name="2622"></a>     *   MutliLoc's presence to reflect applying our location rules to the
<a name="2623"></a>     *   current game state.
<a name="2624"></a>     *
<a name="2625"></a>     *   Note that this doesn't trigger any moveInto notifications.  This
<a name="2626"></a>     *   routine is a re-initialization rather than an in-game action, so
<a name="2627"></a>     *   it's not meant to behave as though an actor in the game were
<a name="2628"></a>     *   walking around moving the MultiLoc around; thus no notifications
<a name="2629"></a>     *   are sent.  Note also that we attempt to minimize our work by
<a name="2630"></a>     *   computing the "delta" from the old state - hence we only move the
<a name="2631"></a>     *   MultiLoc into containers it wasn't in previously, and we only
<a name="2632"></a>     *   remove it from existing containers that it's no longer in.
<a name="2633"></a>     */
<a name="2634"></a>    reInitializeLocation()
<a name="2635"></a>    {
<a name="2636"></a>        local newList;
<a name="2637"></a>
<a name="2638"></a>        /* build the new location list */
<a name="2639"></a>        newList = buildLocationList();
<a name="2640"></a>
<a name="2641"></a>        /*
<a name="2642"></a>         *   Update any containers that are not in the intersection of the
<a name="2643"></a>         *   two lists.  Note that we don't simply move ourselves out of
<a name="2644"></a>         *   the old list and into the new list, because the two lists
<a name="2645"></a>         *   could have common members; to avoid unnecessary work that
<a name="2646"></a>         *   might result from removing ourselves from a container and
<a name="2647"></a>         *   then adding ourselves right back in to the same container, we
<a name="2648"></a>         *   only notify containers when we're actually moving out or
<a name="2649"></a>         *   moving in.
<a name="2650"></a>         */
<a name="2651"></a>
<a name="2652"></a>        /*
<a name="2653"></a>         *   For each item in the old list, if it's not in the new list,
<a name="2654"></a>         *   notify the old container that we're being removed.
<a name="2655"></a>         */
<a name="2656"></a>        foreach (local loc in locationList)
<a name="2657"></a>        {
<a name="2658"></a>            /* if it's not in the new list, remove me from the container */
<a name="2659"></a>            if (newList.indexOf(loc) == nil)
<a name="2660"></a>                loc.removeFromContents(self);
<a name="2661"></a>        }
<a name="2662"></a>
<a name="2663"></a>        /*
<a name="2664"></a>         *   for each item in the new list, if we weren't already in this
<a name="2665"></a>         *   location, add ourselves to the location
<a name="2666"></a>         */
<a name="2667"></a>        foreach (local loc in newList)
<a name="2668"></a>        {
<a name="2669"></a>            /* if it's not in the old list, add me to the new container */
<a name="2670"></a>            if (!isDirectlyIn(loc) == nil)
<a name="2671"></a>                loc.addToContents(self);
<a name="2672"></a>        }
<a name="2673"></a>
<a name="2674"></a>        /* make the new location list current */
<a name="2675"></a>        locationList = newList;
<a name="2676"></a>    }
<a name="2677"></a>
<a name="2678"></a>    /*
<a name="2679"></a>     *   Note that we don't need to override any of the contents
<a name="2680"></a>     *   management methods, since we provide special handling for our
<a name="2681"></a>     *   location relationships, not for our contents relationships.
<a name="2682"></a>     */
<a name="2683"></a>
<a name="2684"></a>    /* save my location for later restoration */
<a name="2685"></a>    saveLocation()
<a name="2686"></a>    {
<a name="2687"></a>        /* return my list of locations */
<a name="2688"></a>        return locationList;
<a name="2689"></a>    }
<a name="2690"></a>
<a name="2691"></a>    /* restore a previously saved location */
<a name="2692"></a>    restoreLocation(oldLoc)
<a name="2693"></a>    {
<a name="2694"></a>        /* remove myself from each current location not in the saved list */
<a name="2695"></a>        foreach (local cur in locationList)
<a name="2696"></a>        {
<a name="2697"></a>            /*
<a name="2698"></a>             *   if this present location isn't in the saved list, remove
<a name="2699"></a>             *   myself from the location
<a name="2700"></a>             */
<a name="2701"></a>            if (oldLoc.indexOf(cur) == nil)
<a name="2702"></a>                cur.removeFromContents(self);
<a name="2703"></a>        }
<a name="2704"></a>
<a name="2705"></a>        /* add myself to each saved location not in the current list */
<a name="2706"></a>        foreach (local cur in oldLoc)
<a name="2707"></a>        {
<a name="2708"></a>            /* if I'm not already in this location, add me to it */
<a name="2709"></a>            if (locationList.indexOf(cur) == nil)
<a name="2710"></a>                cur.addToContents(self);
<a name="2711"></a>        }
<a name="2712"></a>
<a name="2713"></a>        /* set my own list to the original list */
<a name="2714"></a>        locationList = oldLoc;
<a name="2715"></a>    }
<a name="2716"></a>
<a name="2717"></a>    /*
<a name="2718"></a>     *   Basic routine to move this object into a given single container.
<a name="2719"></a>     *   Removes the object from all of its other containers.  Performs no
<a name="2720"></a>     *   notifications.
<a name="2721"></a>     */
<a name="2722"></a>    baseMoveInto(newContainer)
<a name="2723"></a>    {
<a name="2724"></a>        /* remove myself from all of my current contents */
<a name="2725"></a>        locationList.forEach({loc: loc.removeFromContents(self)});
<a name="2726"></a>
<a name="2727"></a>        /* set my location list to include only the new location */
<a name="2728"></a>        if (newContainer != nil)
<a name="2729"></a>        {
<a name="2730"></a>            /* set my new location */
<a name="2731"></a>            locationList = [newContainer];
<a name="2732"></a>
<a name="2733"></a>            /* add myself to my new container's contents */
<a name="2734"></a>            newContainer.addToContents(self);
<a name="2735"></a>        }
<a name="2736"></a>        else
<a name="2737"></a>        {
<a name="2738"></a>            /* we have no new locations */
<a name="2739"></a>            locationList = [];
<a name="2740"></a>        }
<a name="2741"></a>    }
<a name="2742"></a>
<a name="2743"></a>    /*
<a name="2744"></a>     *   Add this object to a new location - base version that performs no
<a name="2745"></a>     *   notifications.
<a name="2746"></a>     */
<a name="2747"></a>    baseMoveIntoAdd(newContainer)
<a name="2748"></a>    {
<a name="2749"></a>        /* add the new container to my list of locations */
<a name="2750"></a>        locationList += newContainer;
<a name="2751"></a>
<a name="2752"></a>        /* add myself to my new container's contents */
<a name="2753"></a>        newContainer.addToContents(self);
<a name="2754"></a>    }
<a name="2755"></a>
<a name="2756"></a>    /*
<a name="2757"></a>     *   Add this object to a new location.
<a name="2758"></a>     */
<a name="2759"></a>    moveIntoAdd(newContainer)
<a name="2760"></a>    {
<a name="2761"></a>        /* notify my new container that I'm about to be added */
<a name="2762"></a>        if (newContainer != nil)
<a name="2763"></a>            newContainer.sendNotifyInsert(self, newContainer, &amp;notifyInsert);
<a name="2764"></a>
<a name="2765"></a>        /* perform base move-into-add operation */
<a name="2766"></a>        baseMoveIntoAdd(newContainer);
<a name="2767"></a>
<a name="2768"></a>        /* note that I've been moved */
<a name="2769"></a>        moved = true;
<a name="2770"></a>    }
<a name="2771"></a>
<a name="2772"></a>    /*
<a name="2773"></a>     *   Base routine to move myself out of a given container.  Performs
<a name="2774"></a>     *   no notifications.
<a name="2775"></a>     */
<a name="2776"></a>    baseMoveOutOf(cont)
<a name="2777"></a>    {
<a name="2778"></a>        /* remove myself from this container's contents list */
<a name="2779"></a>        cont.removeFromContents(self);
<a name="2780"></a>
<a name="2781"></a>        /* remove this container from my location list */
<a name="2782"></a>        locationList -= cont;
<a name="2783"></a>    }
<a name="2784"></a>
<a name="2785"></a>    /*
<a name="2786"></a>     *   Remove myself from a given container, leaving myself in any other
<a name="2787"></a>     *   containers.
<a name="2788"></a>     */
<a name="2789"></a>    moveOutOf(cont)
<a name="2790"></a>    {
<a name="2791"></a>        /* if I'm not actually directly in this container, do nothing */
<a name="2792"></a>        if (!isDirectlyIn(cont))
<a name="2793"></a>            return;
<a name="2794"></a>
<a name="2795"></a>        /*
<a name="2796"></a>         *   notify this container (and only this container) that we're
<a name="2797"></a>         *   being removed from it
<a name="2798"></a>         */
<a name="2799"></a>        cont.sendNotifyRemove(obj, nil, &amp;notifyRemove);
<a name="2800"></a>
<a name="2801"></a>        /* perform base operation */
<a name="2802"></a>        baseMoveOutOf(cont);
<a name="2803"></a>
<a name="2804"></a>        /* note that I've been moved */
<a name="2805"></a>        moved = true;
<a name="2806"></a>    }
<a name="2807"></a>
<a name="2808"></a>    /*
<a name="2809"></a>     *   Call a function on each container.  We'll invoke the function as
<a name="2810"></a>     *   follows for each container 'cont':
<a name="2811"></a>     *
<a name="2812"></a>     *   (func)(cont, args...)
<a name="2813"></a>     */
<a name="2814"></a>    forEachContainer(func, [args])
<a name="2815"></a>    {
<a name="2816"></a>        /* call the function for each location in our list */
<a name="2817"></a>        foreach(local cur in locationList)
<a name="2818"></a>            (func)(cur, args...);
<a name="2819"></a>    }
<a name="2820"></a>
<a name="2821"></a>    /*
<a name="2822"></a>     *   Call a function on each connected container.  By default, we
<a name="2823"></a>     *   don't connect our containers for sense purposes, so we do nothing
<a name="2824"></a>     *   here.
<a name="2825"></a>     */
<a name="2826"></a>    forEachConnectedContainer(func, ...) { }
<a name="2827"></a>
<a name="2828"></a>    /*
<a name="2829"></a>     *   get a list of my connected containers; by default, we don't
<a name="2830"></a>     *   connect our containers, so this is an empty list
<a name="2831"></a>     */
<a name="2832"></a>    getConnectedContainers = []
<a name="2833"></a>
<a name="2834"></a>    /*
<a name="2835"></a>     *   Clone this object's contents for inclusion in a MultiInstance's
<a name="2836"></a>     *   contents tree.  A MultiLoc is capable of being in multiple places
<a name="2837"></a>     *   at once, so we can just use our original contents tree as is.
<a name="2838"></a>     */
<a name="2839"></a>    cloneMultiInstanceContents(loc) { }
<a name="2840"></a>
<a name="2841"></a>    /*
<a name="2842"></a>     *   Create a clone of this object for inclusion in a MultiInstance's
<a name="2843"></a>     *   contents tree.  We don't actually need to make a copy of the
<a name="2844"></a>     *   object, because a MultiLoc can be in several locations
<a name="2845"></a>     *   simultaneously; all we need to do is add ourselves to the new
<a name="2846"></a>     *   location.
<a name="2847"></a>     */
<a name="2848"></a>    cloneForMultiInstanceContents(loc)
<a name="2849"></a>    {
<a name="2850"></a>        /* add myself into the new container */
<a name="2851"></a>        baseMoveIntoAdd(loc);
<a name="2852"></a>    }
<a name="2853"></a>
<a name="2854"></a>    /*
<a name="2855"></a>     *   Add the direct containment connections for this item to a lookup
<a name="2856"></a>     *   table.
<a name="2857"></a>     *
<a name="2858"></a>     *   A MultiLoc does not, by default, connect its multiple locations
<a name="2859"></a>     *   together.  This means that if we're traversing in from a point of
<a name="2860"></a>     *   view outside the MultiLoc object, we don't add any of our other
<a name="2861"></a>     *   containers to the connection table.  However, the MultiLoc
<a name="2862"></a>     *   itself, and its contents, *can* see out to all of its locations;
<a name="2863"></a>     *   so if we're traversing from a point of view inside self, we will
<a name="2864"></a>     *   add all of our containers to the connection list.
<a name="2865"></a>     */
<a name="2866"></a>    addDirectConnections(tab)
<a name="2867"></a>    {
<a name="2868"></a>        /* add myself */
<a name="2869"></a>        tab[self] = true;
<a name="2870"></a>
<a name="2871"></a>        /* add my CollectiveGroup objects */
<a name="2872"></a>        foreach (local cur in collectiveGroups)
<a name="2873"></a>            tab[cur] = true;
<a name="2874"></a>
<a name="2875"></a>        /* add my contents */
<a name="2876"></a>        foreach (local cur in contents)
<a name="2877"></a>        {
<a name="2878"></a>            if (tab[cur] == nil)
<a name="2879"></a>                cur.addDirectConnections(tab);
<a name="2880"></a>        }
<a name="2881"></a>
<a name="2882"></a>        /*
<a name="2883"></a>         *   If we're traversing from the outside in, don't connect any of
<a name="2884"></a>         *   our other containers.  However, if we're traversing from our
<a name="2885"></a>         *   own point of view, or from a point of view inside us, we do
<a name="2886"></a>         *   get to see out to all of our containers.
<a name="2887"></a>         */
<a name="2888"></a>        if (senseTmp.pointOfView == self || senseTmp.pointOfView.isIn(self))
<a name="2889"></a>        {
<a name="2890"></a>            /* add my locations */
<a name="2891"></a>            foreach (local cur in locationList)
<a name="2892"></a>            {
<a name="2893"></a>                if (tab[cur] == nil)
<a name="2894"></a>                    cur.addDirectConnections(tab);
<a name="2895"></a>            }
<a name="2896"></a>        }
<a name="2897"></a>    }
<a name="2898"></a>
<a name="2899"></a>    /*
<a name="2900"></a>     *   Transmit ambient energy to my location or locations.  Note that
<a name="2901"></a>     *   even though we don't by default shine light from one of our
<a name="2902"></a>     *   containers to another, we still shine light from within me to
<a name="2903"></a>     *   each of our containers.
<a name="2904"></a>     */
<a name="2905"></a>    shineOnLoc(sense, ambient, fill)
<a name="2906"></a>    {
<a name="2907"></a>        /* shine on each of my containers and their immediate children */
<a name="2908"></a>        foreach (local cur in locationList)
<a name="2909"></a>            cur.shineFromWithin(self, sense, ambient, fill);
<a name="2910"></a>    }
<a name="2911"></a>
<a name="2912"></a>
<a name="2913"></a>    /*
<a name="2914"></a>     *   Build a sense path to my location or locations.  Note that even
<a name="2915"></a>     *   though we don't by default connect our different containers
<a name="2916"></a>     *   together, we still build a sense path from within to outside,
<a name="2917"></a>     *   because we can see from within out to all of our containers.
<a name="2918"></a>     */
<a name="2919"></a>    sensePathToLoc(sense, trans, obs, fill)
<a name="2920"></a>    {
<a name="2921"></a>        /* build a path to each of my containers and their children */
<a name="2922"></a>        foreach (local cur in locationList)
<a name="2923"></a>            cur.sensePathFromWithin(self, sense, trans, obs, fill);
<a name="2924"></a>    }
<a name="2925"></a>
<a name="2926"></a>
<a name="2927"></a>    /*
<a name="2928"></a>     *   Get the drop destination.  The default implementation in Thing
<a name="2929"></a>     *   won't work for us, because it delegates to its location to find
<a name="2930"></a>     *   the drop destination; we can't do that because we could have
<a name="2931"></a>     *   several locations.  To figure out which of our multiple locations
<a name="2932"></a>     *   to delegate to, we'll look for 'self' in the supplied sense path;
<a name="2933"></a>     *   if we can find it, and the previous path element is a container or
<a name="2934"></a>     *   peer of ours, then we'll delegate to that container, because it's
<a name="2935"></a>     *   the "side" we approached from.  If there's no path, or if we're
<a name="2936"></a>     *   not preceded in the path by a container of ours, we'll arbitrarily
<a name="2937"></a>     *   delegate to our first container.
<a name="2938"></a>     *
<a name="2939"></a>     *   Note that when we don't have a path, or there's no container of
<a name="2940"></a>     *   ours preceding us in the path, the object being dropped must be
<a name="2941"></a>     *   starting inside us.  It would be highly unusual for this to happen
<a name="2942"></a>     *   with a multi-location object, because MutliLoc isn't designed for
<a name="2943"></a>     *   use as a "nested room" or the like.  However, it's not an
<a name="2944"></a>     *   impossible situation; if the game does want to create such a
<a name="2945"></a>     *   scenario, then the game simply needs to override this routine so
<a name="2946"></a>     *   that it does whatever makes sense in the game scenario.  There's
<a name="2947"></a>     *   no general way to handle such situations, but it should be
<a name="2948"></a>     *   possible to determine the correct handling for specific scenarios.
<a name="2949"></a>     */
<a name="2950"></a>    getDropDestination(obj, path)
<a name="2951"></a>    {
<a name="2952"></a>        local idx;
<a name="2953"></a>
<a name="2954"></a>        /*
<a name="2955"></a>         *   if there's no path, get the ordinary "touch" path from the
<a name="2956"></a>         *   current actor to us, since this is how the actor would reach
<a name="2957"></a>         *   out and touch this object
<a name="2958"></a>         */
<a name="2959"></a>        if (path == nil)
<a name="2960"></a>            path = gActor.getTouchPathTo(self);
<a name="2961"></a>
<a name="2962"></a>        /*
<a name="2963"></a>         *   if there's a path, check to see if we're in it; if so, and
<a name="2964"></a>         *   we're not the first element, and the preceding element is a
<a name="2965"></a>         *   container or peer of ours, delegate to the preceding element
<a name="2966"></a>         */
<a name="2967"></a>        if (path != nil
<a name="2968"></a>            &amp;&amp; (idx = path.indexOf(self)) != nil
<a name="2969"></a>            &amp;&amp; idx &gt;= 3
<a name="2970"></a>            &amp;&amp; path[idx - 1] is in (PathIn, PathPeer))
<a name="2971"></a>        {
<a name="2972"></a>            /*
<a name="2973"></a>             *   we're preceded in the path by a container or peer of ours,
<a name="2974"></a>             *   so we know that we're approaching from that "side" -
<a name="2975"></a>             *   delegate to that container, since we're coming from that
<a name="2976"></a>             *   direction
<a name="2977"></a>             */
<a name="2978"></a>            return path[idx - 2].getDropDestination(obj, path);
<a name="2979"></a>        }
<a name="2980"></a>
<a name="2981"></a>        /*
<a name="2982"></a>         *   We either don't have a path, or we're not preceded in the path
<a name="2983"></a>         *   by one of our containers or peers, so we don't have any idea
<a name="2984"></a>         *   which "side" we're approaching from.  This means we have no
<a name="2985"></a>         *   good basis for deciding where the object being dropped will
<a name="2986"></a>         *   fall.  Arbitrarily delegate to our first container, if we have
<a name="2987"></a>         *   one.
<a name="2988"></a>         */
<a name="2989"></a>        return locationList.length() &gt; 0
<a name="2990"></a>            ? locationList[1].getDropDestination(obj, path)
<a name="2991"></a>            : nil;
<a name="2992"></a>    }
<a name="2993"></a>;
<a name="2994"></a>
<a name="2995"></a>/* ------------------------------------------------------------------------ */
<a name="2996"></a>/*
<a name="2997"></a> *   A "multi-instance" object is a simple way of creating copies of an
<a name="2998"></a> *   object in several places.  This is often useful for decorations and
<a name="2999"></a> *   other features that recur in a whole group of rooms.
<a name="3000"></a> *
<a name="3001"></a> *   You define a multi-instance object in two parts.
<a name="3002"></a> *
<a name="3003"></a> *   First, you define a MultiInstance object, which is just a hollow
<a name="3004"></a> *   shell of an object that sets up the location relationships.  This
<a name="3005"></a> *   shell object doesn't have any presence in the game world; it's just a
<a name="3006"></a> *   programming abstraction.
<a name="3007"></a> *
<a name="3008"></a> *   Second, as part of the shell object, you define an example of the
<a name="3009"></a> *   object that will actually show up in the game in each of the multiple
<a name="3010"></a> *   locations.  You do this by defining a nested object under the
<a name="3011"></a> *   'instanceObject' property of the shell object.  This is otherwise a
<a name="3012"></a> *   perfectly ordinary object.  In most cases, you'll want to make this a
<a name="3013"></a> *   Decoration, Fixture, or some other non-portable object class, since
<a name="3014"></a> *   the "cloned" nature of these objects means that you usually won't
<a name="3015"></a> *   want them moving around (if they did, you might run into situations
<a name="3016"></a> *   where you had several of them in the same place, leading to
<a name="3017"></a> *   disambiguation headaches for the player).
<a name="3018"></a> *
<a name="3019"></a> *   Here's an example of how you set up a multi-instance object:
<a name="3020"></a> *
<a name="3021"></a> *   trees: MultiInstance
<a name="3022"></a> *.    locationList = [forest1, forest2, forest3]
<a name="3023"></a> *.    instanceObject: Fixture { 'tree/trees' 'trees'
<a name="3024"></a> *.      "Many tall, old trees grow here. "
<a name="3025"></a> *.      isPlural = true
<a name="3026"></a> *.    }
<a name="3027"></a> *.  ;
<a name="3028"></a> *
<a name="3029"></a> *   Note that the instanceObject itself has no location, because it
<a name="3030"></a> *   doesn't appear in the game-world model itself - it's just a template
<a name="3031"></a> *   for the real objects.
<a name="3032"></a> *
<a name="3033"></a> *   During initialization, the library will automatically create several
<a name="3034"></a> *   instances (i.e., subclasses) of the example object - one instance per
<a name="3035"></a> *   location, to be exact.  These instances are the real objects that
<a name="3036"></a> *   show up in the game world.
<a name="3037"></a> *
<a name="3038"></a> *   MultiInstance has one more helpful feature: it lets you dynamically
<a name="3039"></a> *   change the set of locations where the instances appear.  You do this
<a name="3040"></a> *   using the same interface that you use to move around MultiLoc objects
<a name="3041"></a> *   - moveInto(), moveIntoAdd(), moveOutOf().  When you call these
<a name="3042"></a> *   routines on the MultiInstance shell object, it will add and remove
<a name="3043"></a> *   object instances as needed to keep everything consistent.  Thanks to
<a name="3044"></a> *   a little manipulation we do on the instance objects when we set them up,
<a name="3045"></a> *   you can also move the instance objects around directly using
<a name="3046"></a> *   moveInto(), and they'll update the MultiInstance parent to keep its
<a name="3047"></a> *   location list consistent.
<a name="3048"></a> */
<a name="3049"></a>class MultiInstance: BaseMultiLoc
<a name="3050"></a>    /* the template object */
<a name="3051"></a>    instanceObject = nil
<a name="3052"></a>
<a name="3053"></a>    /* initialize my locations */
<a name="3054"></a>    initializeLocation()
<a name="3055"></a>    {
<a name="3056"></a>        /* create a copy of our template object for each of our locations */
<a name="3057"></a>        locationList.forEach({loc: addInstance(loc)});
<a name="3058"></a>    }
<a name="3059"></a>
<a name="3060"></a>    /*
<a name="3061"></a>     *   Move the MultiInstance into the given location.  This removes us
<a name="3062"></a>     *   from any other existing locations and adds us (if we're not
<a name="3063"></a>     *   already there) to the given location.
<a name="3064"></a>     */
<a name="3065"></a>    moveInto(loc)
<a name="3066"></a>    {
<a name="3067"></a>        /* remove all instances that aren't in the new location */
<a name="3068"></a>        foreach (local cur in instanceList)
<a name="3069"></a>        {
<a name="3070"></a>            /* if this instance isn't directly in 'loc', remove it */
<a name="3071"></a>            if (!cur.isDirectlyIn(loc))
<a name="3072"></a>                cur.moveInto(nil);
<a name="3073"></a>        }
<a name="3074"></a>
<a name="3075"></a>        /*
<a name="3076"></a>         *   If I don't have an instance object in the new location, add
<a name="3077"></a>         *   one.  Since I've dropped every other instance already, we
<a name="3078"></a>         *   either have exactly one location now, which is in the new
<a name="3079"></a>         *   location, or we have no locations at all; so we need only
<a name="3080"></a>         *   check to see if we have any instances and add one in the new
<a name="3081"></a>         *   location if not.
<a name="3082"></a>         */
<a name="3083"></a>        if (loc != nil &amp;&amp; locationList.length() == 0)
<a name="3084"></a>            addInstance(loc);
<a name="3085"></a>    }
<a name="3086"></a>
<a name="3087"></a>    /*
<a name="3088"></a>     *   Add the new location to our set of locations.  Any existing
<a name="3089"></a>     *   locations are unaffected.
<a name="3090"></a>     */
<a name="3091"></a>    moveIntoAdd(loc)
<a name="3092"></a>    {
<a name="3093"></a>        /* if I'm not already in the location, add an instance there */
<a name="3094"></a>        if (locationList.indexOf(loc) == nil)
<a name="3095"></a>            addInstance(loc);
<a name="3096"></a>    }
<a name="3097"></a>
<a name="3098"></a>    /*
<a name="3099"></a>     *   Remove me from the given location.  Other locations are
<a name="3100"></a>     *   unaffected.
<a name="3101"></a>     */
<a name="3102"></a>    moveOutOf(loc)
<a name="3103"></a>    {
<a name="3104"></a>        local inst;
<a name="3105"></a>
<a name="3106"></a>        /* find our instance that's in the given location */
<a name="3107"></a>        inst = getInstanceIn(loc);
<a name="3108"></a>
<a name="3109"></a>        /* if we found it, remove this instance from its location */
<a name="3110"></a>        if (inst != nil)
<a name="3111"></a>            inst.moveInto(nil);
<a name="3112"></a>    }
<a name="3113"></a>
<a name="3114"></a>    /* get our instance object (if any) that's in the given location */
<a name="3115"></a>    getInstanceIn(loc)
<a name="3116"></a>        { return instanceList.valWhich({x: x.isDirectlyIn(loc)}); }
<a name="3117"></a>
<a name="3118"></a>    /* internal service routine - add an instance for a given location */
<a name="3119"></a>    addInstance(loc)
<a name="3120"></a>    {
<a name="3121"></a>        local inst;
<a name="3122"></a>
<a name="3123"></a>        /*
<a name="3124"></a>         *   Create an instance of the template object, mixing in our
<a name="3125"></a>         *   special instance superclass using multiple inheritance.  The
<a name="3126"></a>         *   MultiInstanceInstance superclass overrides the location
<a name="3127"></a>         *   manipulation methods so that we keep the MultiInstance parent
<a name="3128"></a>         *   (i.e., us) synchronized if we move around the instance object
<a name="3129"></a>         *   directly (by calling its moveInto() method directly, for
<a name="3130"></a>         *   example).
<a name="3131"></a>         */
<a name="3132"></a>        inst = TadsObject.createInstanceOf(
<a name="3133"></a>            [instanceMixIn, self], [instanceObject]);
<a name="3134"></a>
<a name="3135"></a>        /* add it to our list of active instances */
<a name="3136"></a>        instanceList.append(inst);
<a name="3137"></a>
<a name="3138"></a>        /* move the instance into its new location */
<a name="3139"></a>        inst.moveInto(loc);
<a name="3140"></a>    }
<a name="3141"></a>
<a name="3142"></a>    /*
<a name="3143"></a>     *   If any contents are added to the MultiInstance object, they must
<a name="3144"></a>     *   be contents of the template object, so add them to the template
<a name="3145"></a>     *   object instead of the MultiInstance parent.
<a name="3146"></a>     */
<a name="3147"></a>    addToContents(obj) { instanceObject.addToContents(obj); }
<a name="3148"></a>
<a name="3149"></a>    /*
<a name="3150"></a>     *   remove an object from our contents - we'll delegate this to our
<a name="3151"></a>     *   template object just like we delegate addToContents
<a name="3152"></a>     */
<a name="3153"></a>    removeFromContents(obj) { instanceObject.removeFromContents(obj); }
<a name="3154"></a>
<a name="3155"></a>    /* the mix-in superclass for our instance objects */
<a name="3156"></a>    instanceMixIn = MultiInstanceInstance
<a name="3157"></a>
<a name="3158"></a>    /* our vector of active instance objects */
<a name="3159"></a>    instanceList = perInstance(new Vector(5))
<a name="3160"></a>;
<a name="3161"></a>
<a name="3162"></a>/*
<a name="3163"></a> *   An instance of a MultiInstance object.  This is a mix-in class that
<a name="3164"></a> *   we add (using mutiple inheritance) to each instance.  This overrides
<a name="3165"></a> *   the location manipulation methods, to ensure that we keep the
<a name="3166"></a> *   MultiInstance parent object in sync with any changes made directly to
<a name="3167"></a> *   the instance objects.
<a name="3168"></a> *
<a name="3169"></a> *   IMPORTANT - the library adds this class to each instance object
<a name="3170"></a> *   *automatically*.  Game code shouldn't ever have to use this class
<a name="3171"></a> *   directly.
<a name="3172"></a> */
<a name="3173"></a>class MultiInstanceInstance: object
<a name="3174"></a>    construct(parent)
<a name="3175"></a>    {
<a name="3176"></a>        /* remember our MultiInstance parent object */
<a name="3177"></a>        miParent = parent;
<a name="3178"></a>
<a name="3179"></a>        /*
<a name="3180"></a>         *   clone my contents tree for the new instance, so that we have a
<a name="3181"></a>         *   private copy of any components within the instance
<a name="3182"></a>         */
<a name="3183"></a>        cloneMultiInstanceContents();
<a name="3184"></a>    }
<a name="3185"></a>
<a name="3186"></a>    /* move to a new location */
<a name="3187"></a>    baseMoveInto(newCont)
<a name="3188"></a>    {
<a name="3189"></a>        /*
<a name="3190"></a>         *   if we currently have a location, take the location out of our
<a name="3191"></a>         *   MultiInstance parent's location list
<a name="3192"></a>         */
<a name="3193"></a>        if (location != nil)
<a name="3194"></a>            miParent.locationList -= location;
<a name="3195"></a>
<a name="3196"></a>        /* inherit the standard behavior */
<a name="3197"></a>        inherited(newCont);
<a name="3198"></a>
<a name="3199"></a>        /*
<a name="3200"></a>         *   if we have a new location, add the new location to our
<a name="3201"></a>         *   MultiInstance parent's location list; otherwise, drop out of
<a name="3202"></a>         *   the parent's instance list
<a name="3203"></a>         */
<a name="3204"></a>        if (newCont != nil)
<a name="3205"></a>        {
<a name="3206"></a>            /*
<a name="3207"></a>             *   add the new location to the parent's location list, if
<a name="3208"></a>             *   we're not already there
<a name="3209"></a>             */
<a name="3210"></a>            if (miParent.locationList.indexOf(newCont) == nil)
<a name="3211"></a>                miParent.locationList += newCont;
<a name="3212"></a>        }
<a name="3213"></a>        else
<a name="3214"></a>        {
<a name="3215"></a>            /*
<a name="3216"></a>             *   we're being removed from the game world, so remove this
<a name="3217"></a>             *   instance from the parent's instance list
<a name="3218"></a>             */
<a name="3219"></a>            miParent.instanceList.removeElement(self);
<a name="3220"></a>        }
<a name="3221"></a>    }
<a name="3222"></a>
<a name="3223"></a>    /*
<a name="3224"></a>     *   All instances of a given MultiInstance are equivalent to one
<a name="3225"></a>     *   another, for parsing purposes.
<a name="3226"></a>     */
<a name="3227"></a>    isEquivalent = true
<a name="3228"></a>
<a name="3229"></a>    /* our MultiInstance parent */
<a name="3230"></a>    miParent = nil
<a name="3231"></a>;
<a name="3232"></a>
<a name="3233"></a>
<a name="3234"></a>/* ------------------------------------------------------------------------ */
<a name="3235"></a>/*
<a name="3236"></a> *   A "multi-faceted" object is similar to a MultiInstance object, with
<a name="3237"></a> *   the addition that the instance objects are "facets" of one another.
<a name="3238"></a> *   This means that they have the same identity, from the perspective of
<a name="3239"></a> *   a character in the scenario: all of the instance objects are part of
<a name="3240"></a> *   the same conceptual object, not separate objects.
<a name="3241"></a> *
<a name="3242"></a> *   This is especially useful for large objects that span multiple
<a name="3243"></a> *   locations, such as a river or a long rope.
<a name="3244"></a> *
<a name="3245"></a> *   You define a multi-faceted object the same way you set up a
<a name="3246"></a> *   MultiInstance: definfe a MultiFaceted shell object, and as part of
<a name="3247"></a> *   the shell, define the facet object using the instanceObject property.
<a name="3248"></a> *   Here's an example:
<a name="3249"></a> *
<a name="3250"></a> *   river: MultiFaceted
<a name="3251"></a> *.    locationList = [riverBank, meadow, canyon]
<a name="3252"></a> *.    instanceObject: Fixture { 'river' 'river'
<a name="3253"></a> *.      "The river meanders by. "
<a name="3254"></a> *.    }
<a name="3255"></a> *.  ;
<a name="3256"></a> *
<a name="3257"></a> *   The main difference between MultiInstance and MultiFaceted is that
<a name="3258"></a> *   the "facet" objects of a MultiFaceted are related as facets of a
<a name="3259"></a> *   common object from the parser's perspective.  For example, if a
<a name="3260"></a> *   player refers to one facet, then travels to another location that
<a name="3261"></a> *   contains a different facet, then refers to "it", the parser will
<a name="3262"></a> *   realize that the pronoun refers to the new facet in the new location.
<a name="3263"></a> */
<a name="3264"></a>class MultiFaceted: MultiInstance
<a name="3265"></a>    /* our instance objects represent our facets for parsing purposes */
<a name="3266"></a>    getFacets() { return instanceList; }
<a name="3267"></a>
<a name="3268"></a>    /* the mix-in superclass for our instance objects */
<a name="3269"></a>    instanceMixIn = MultiFacetedFacet
<a name="3270"></a>;
<a name="3271"></a>
<a name="3272"></a>/*
<a name="3273"></a> *   The mix-in superclass for MultiFaceted facet instances.
<a name="3274"></a> *
<a name="3275"></a> *   IMPORTANT - the library adds this class to each instance object
<a name="3276"></a> *   *automatically*.  Game code shouldn't ever have to use this class
<a name="3277"></a> *   directly.
<a name="3278"></a> */
<a name="3279"></a>class MultiFacetedFacet: MultiInstanceInstance
<a name="3280"></a>    /*
<a name="3281"></a>     *   Get our other facets for parsing purposes - our parent maintains
<a name="3282"></a>     *   the list of all of its facets, so simply return that list.  (Note
<a name="3283"></a>     *   that we'll be in the list as well, but that's harmless, so don't
<a name="3284"></a>     *   bother removing us.)
<a name="3285"></a>     */
<a name="3286"></a>    getFacets() { return miParent.getFacets(); }
<a name="3287"></a>;
<a name="3288"></a>
<a name="3289"></a>/* ------------------------------------------------------------------------ */
<a name="3290"></a>/*
<a name="3291"></a> *   A "linkable" object is one that can participate in a master/slave
<a name="3292"></a> *   relationship.  This kind of relationship means that the state of both
<a name="3293"></a> *   objects in the pair is controlled by one of the objects, called the
<a name="3294"></a> *   master; the other object defers to the other to get and set all of
<a name="3295"></a> *   its linkable state.
<a name="3296"></a> *
<a name="3297"></a> *   Note that this base class doesn't provide for the management of any
<a name="3298"></a> *   of the actual linked state.  Subclasses are responsible for doing
<a name="3299"></a> *   this.  The general pattern is to create a getter/setter method pair
<a name="3300"></a> *   for each bit of linked state, and in these methods refer to
<a name="3301"></a> *   masterObject.xxx rather than just self.xxx.
<a name="3302"></a> *
<a name="3303"></a> *   This is useful for objects such as doors that have two separate
<a name="3304"></a> *   objects representing the two sides of the door.  The two sides are
<a name="3305"></a> *   always linked for things like open/closed and locked/unlocked state;
<a name="3306"></a> *   this can be handled by linking the two sides, and managing all state
<a name="3307"></a> *   of both sides in one side designated as the master.
<a name="3308"></a> */
<a name="3309"></a>class Linkable: object
<a name="3310"></a>    /*
<a name="3311"></a>     *   Get the master object, which holds our state.  By default, this
<a name="3312"></a>     *   is simply 'self', but some objects might want to override this.
<a name="3313"></a>     *   For example, doors are usually implemented with two separate
<a name="3314"></a>     *   objects, representing the two sides of the door, which share
<a name="3315"></a>     *   common state; in such cases, one of the pair can be designated as
<a name="3316"></a>     *   the master, which holds the common state of the door, and this
<a name="3317"></a>     *   method can be overridden so that all state operations on the lock
<a name="3318"></a>     *   are performed on the master side of the door.
<a name="3319"></a>     *
<a name="3320"></a>     *   We return self by default so that a linkable object can stand
<a name="3321"></a>     *   alone if desired.  That is, a linkable object doesn't have to be
<a name="3322"></a>     *   part of a pair; it can just as well be a single object.
<a name="3323"></a>     */
<a name="3324"></a>    masterObject()
<a name="3325"></a>    {
<a name="3326"></a>        /*
<a name="3327"></a>         *   inherit from the next superclass, if possible; otherwise, use
<a name="3328"></a>         *   'self' as the default master object
<a name="3329"></a>         */
<a name="3330"></a>        if (canInherit())
<a name="3331"></a>            return inherited();
<a name="3332"></a>        else
<a name="3333"></a>            return self;
<a name="3334"></a>    }
<a name="3335"></a>
<a name="3336"></a>    /*
<a name="3337"></a>     *   We're normally mixed into a Thing; do some extra work in
<a name="3338"></a>     *   initialization.
<a name="3339"></a>     */
<a name="3340"></a>    initializeThing()
<a name="3341"></a>    {
<a name="3342"></a>        /* inherit the default handling */
<a name="3343"></a>        inherited();
<a name="3344"></a>
<a name="3345"></a>        /*
<a name="3346"></a>         *   If we're tied to a separate master object, check the master
<a name="3347"></a>         *   object to see if it's tied back to us as its master object.
<a name="3348"></a>         *   Only one can be the master; if each says the other is the
<a name="3349"></a>         *   master, we'll get stuck in infinite loops as each tries to
<a name="3350"></a>         *   defer to the other.  To avoid this, break the loop by
<a name="3351"></a>         *   arbitrarily choosing one or the other as the master.  Note
<a name="3352"></a>         *   that we don't have to worry about the other object making a
<a name="3353"></a>         *   different decision and breaking the relationship, because if
<a name="3354"></a>         *   we detect the loop, it means we're going first - if the other
<a name="3355"></a>         *   object had gone first then it would have detected and broken
<a name="3356"></a>         *   the loop itself, and we wouldn't be finding the loop now.
<a name="3357"></a>         */
<a name="3358"></a>        if (masterObject != self &amp;&amp; masterObject.masterObject == self)
<a name="3359"></a>        {
<a name="3360"></a>            /*
<a name="3361"></a>             *   We're tied together in a loop - break the loop by
<a name="3362"></a>             *   arbitrarily electing myself as the master object.
<a name="3363"></a>             *   Because these relationships are symmetric, it shouldn't
<a name="3364"></a>             *   matter which we choose.
<a name="3365"></a>             */
<a name="3366"></a>            masterObject = self;
<a name="3367"></a>        }
<a name="3368"></a>    }
<a name="3369"></a>;
<a name="3370"></a>
<a name="3371"></a>
<a name="3372"></a>/* ------------------------------------------------------------------------ */
<a name="3373"></a>/*
<a name="3374"></a> *   A "basic openable" is an object that keeps open/closed status, and
<a name="3375"></a> *   which can be linked to another object to maintain that status.  This
<a name="3376"></a> *   basic class doesn't handle any special commands; it's purely for
<a name="3377"></a> *   keeping track of internal open/closed state.
<a name="3378"></a> */
<a name="3379"></a>class BasicOpenable: Linkable
<a name="3380"></a>    /*
<a name="3381"></a>     *   Initial open/closed setting.  Set this to true to make the object
<a name="3382"></a>     *   open initially.  If this object is linked to another object (as
<a name="3383"></a>     *   in the two sides of a door), you only need to set this property
<a name="3384"></a>     *   in the *master* object - the other side will automatically link
<a name="3385"></a>     *   up to the master object during initialization.
<a name="3386"></a>     */
<a name="3387"></a>    initiallyOpen = nil
<a name="3388"></a>
<a name="3389"></a>    /*
<a name="3390"></a>     *   Flag: door is open.  Travel is only possible when the door is
<a name="3391"></a>     *   open.  Return the master's status.
<a name="3392"></a>     */
<a name="3393"></a>    isOpen()
<a name="3394"></a>    {
<a name="3395"></a>        /*
<a name="3396"></a>         *   If we're the master, simply use our isOpen_ property;
<a name="3397"></a>         *   otherwise, call our master's isOpen method.  This way, if the
<a name="3398"></a>         *   master has a different way of calculating isOpen, we'll defer
<a name="3399"></a>         *   to its different handling.
<a name="3400"></a>         */
<a name="3401"></a>        if (masterObject == self)
<a name="3402"></a>            return isOpen_;
<a name="3403"></a>        else
<a name="3404"></a>            return masterObject.isOpen();
<a name="3405"></a>    }
<a name="3406"></a>
<a name="3407"></a>    /*
<a name="3408"></a>     *   Make the object open or closed.  By default, we'll simply set the
<a name="3409"></a>     *   isOpen flag to the new status.  Objects can override this to
<a name="3410"></a>     *   apply side effects of opening or closing the object.
<a name="3411"></a>     */
<a name="3412"></a>    makeOpen(stat)
<a name="3413"></a>    {
<a name="3414"></a>        /*
<a name="3415"></a>         *   if we're the master, simply set our isOpen_ property;
<a name="3416"></a>         *   otherwise, defer to the master
<a name="3417"></a>         */
<a name="3418"></a>        if (masterObject == self)
<a name="3419"></a>            isOpen_ = stat;
<a name="3420"></a>        else
<a name="3421"></a>            masterObject.makeOpen(stat);
<a name="3422"></a>
<a name="3423"></a>        /* inherit the next superclass's handling */
<a name="3424"></a>        inherited(stat);
<a name="3425"></a>    }
<a name="3426"></a>
<a name="3427"></a>    /*
<a name="3428"></a>     *   Open status name.  This is an adjective describing whether the
<a name="3429"></a>     *   object is opened or closed.  In English, this will return "open"
<a name="3430"></a>     *   or "closed."
<a name="3431"></a>     */
<a name="3432"></a>    openDesc = (isOpen ? gLibMessages.openMsg(self)
<a name="3433"></a>                       : gLibMessages.closedMsg(self))
<a name="3434"></a>
<a name="3435"></a>    /* initialization */
<a name="3436"></a>    initializeThing()
<a name="3437"></a>    {
<a name="3438"></a>        /* inherit the default handling */
<a name="3439"></a>        inherited();
<a name="3440"></a>
<a name="3441"></a>        /* if we're the master, set our initial open/closed state */
<a name="3442"></a>        if (masterObject == self)
<a name="3443"></a>            isOpen_ = initiallyOpen;
<a name="3444"></a>    }
<a name="3445"></a>
<a name="3446"></a>    /*
<a name="3447"></a>     *   If we're obstructing a sense path, it must be because we're
<a name="3448"></a>     *   closed.  Try implicitly opening.
<a name="3449"></a>     */
<a name="3450"></a>    tryImplicitRemoveObstructor(sense, obj)
<a name="3451"></a>    {
<a name="3452"></a>        /*
<a name="3453"></a>         *   If I'm not already open, try opening me.  As usual for 'try'
<a name="3454"></a>         *   routines, we return true if we attempt a command, nil if not.
<a name="3455"></a>         *
<a name="3456"></a>         *   Note that we might be creating an obstruction despite already
<a name="3457"></a>         *   being open; in this case, we don't want to do anything, since
<a name="3458"></a>         *   an implied 'open' won't help when we're already open.
<a name="3459"></a>         */
<a name="3460"></a>        return isOpen ? nil : tryImplicitAction(Open, self);
<a name="3461"></a>    }
<a name="3462"></a>
<a name="3463"></a>    /*
<a name="3464"></a>     *   if we can't reach or move something through the container, it
<a name="3465"></a>     *   must be because we're closed
<a name="3466"></a>     */
<a name="3467"></a>    cannotTouchThroughMsg = &amp;cannotTouchThroughClosedMsg
<a name="3468"></a>    cannotMoveThroughMsg = &amp;cannotMoveThroughClosedMsg
<a name="3469"></a>
<a name="3470"></a>    /*
<a name="3471"></a>     *   Internal open/closed status.  Do not use this for initialization
<a name="3472"></a>     *   - set initiallyOpen in the master object instead.
<a name="3473"></a>     */
<a name="3474"></a>    isOpen_ = nil
<a name="3475"></a>;
<a name="3476"></a>
<a name="3477"></a>/* ------------------------------------------------------------------------ */
<a name="3478"></a>/*
<a name="3479"></a> *   Openable: a mix-in class that can be combined with an object's other
<a name="3480"></a> *   superclasses to make the object respond to the verbs "open" and
<a name="3481"></a> *   "close."  We also add some extra features for other related verbs,
<a name="3482"></a> *   such as a must-be-open precondition "look in" and "board".
<a name="3483"></a> */
<a name="3484"></a>class Openable: BasicOpenable
<a name="3485"></a>    /*
<a name="3486"></a>     *   Describe our contents using a special version of the contents
<a name="3487"></a>     *   lister, so that we add our open/closed status to the listing.  The
<a name="3488"></a>     *   message we add is given by our openStatus method, so if all you
<a name="3489"></a>     *   want to change is the "it's open" status message, you can just
<a name="3490"></a>     *   override openStatus rather than providing a whole new lister.
<a name="3491"></a>     */
<a name="3492"></a>    descContentsLister = openableDescContentsLister
<a name="3493"></a>
<a name="3494"></a>    /*
<a name="3495"></a>     *   Contents lister to use when we're opening the object.  This
<a name="3496"></a>     *   lister shows the items that are newly revealed when the object is
<a name="3497"></a>     *   opened.
<a name="3498"></a>     */
<a name="3499"></a>    openingLister = openableOpeningLister
<a name="3500"></a>
<a name="3501"></a>    /*
<a name="3502"></a>     *   Get our "open status" message - this is a complete sentence saying
<a name="3503"></a>     *   that we're open or closed.  By default, in English, we just say
<a name="3504"></a>     *   "it's open" (adjusted for number and gender, of course).
<a name="3505"></a>     *
<a name="3506"></a>     *   Note that this message has to be a stand-alone independent clause.
<a name="3507"></a>     *   In particular note that we don't put any spacing after it, since
<a name="3508"></a>     *   we need to be able to add sentence-ending or clause-ending
<a name="3509"></a>     *   punctuation immediately after it.
<a name="3510"></a>     */
<a name="3511"></a>    openStatus() { return gLibMessages.openStatusMsg(self); }
<a name="3512"></a>
<a name="3513"></a>    /*
<a name="3514"></a>     *   By default, an Openable that's also a Lockable must be closed to
<a name="3515"></a>     *   be locked.  This means that when it's open, the object is
<a name="3516"></a>     *   implicitly unlocked, in which case "It's unlocked" isn't worth
<a name="3517"></a>     *   mentioning when the description says "It's open."
<a name="3518"></a>     */
<a name="3519"></a>    lockStatusReportable = (!isOpen)
<a name="3520"></a>
<a name="3521"></a>    /*
<a name="3522"></a>     *   Action handlers
<a name="3523"></a>     */
<a name="3524"></a>    dobjFor(Open)
<a name="3525"></a>    {
<a name="3526"></a>        verify()
<a name="3527"></a>        {
<a name="3528"></a>            /* it makes no sense to open something that's already open */
<a name="3529"></a>            if (isOpen)
<a name="3530"></a>                illogicalAlready(&amp;alreadyOpenMsg);
<a name="3531"></a>        }
<a name="3532"></a>        action()
<a name="3533"></a>        {
<a name="3534"></a>            local trans;
<a name="3535"></a>
<a name="3536"></a>            /*
<a name="3537"></a>             *   note the effect we have currently, while still closed, on
<a name="3538"></a>             *   sensing from outside into our contents
<a name="3539"></a>             */
<a name="3540"></a>            trans = transSensingIn(sight);
<a name="3541"></a>
<a name="3542"></a>            /* make it open */
<a name="3543"></a>            makeOpen(true);
<a name="3544"></a>
<a name="3545"></a>            /*
<a name="3546"></a>             *   make the default report - if we make a non-default
<a name="3547"></a>             *   report, the default will be ignored, so we don't need to
<a name="3548"></a>             *   worry about whether or not we'll make a non-default
<a name="3549"></a>             *   report now
<a name="3550"></a>             */
<a name="3551"></a>            defaultReport(&amp;okayOpenMsg);
<a name="3552"></a>
<a name="3553"></a>            /*
<a name="3554"></a>             *   If the actor is outside me, and we have any listable
<a name="3555"></a>             *   contents, and our sight transparency is now better than it
<a name="3556"></a>             *   was before we were open, reveal the new contents.
<a name="3557"></a>             *   Otherwise, just show our default 'opened' message.
<a name="3558"></a>             *
<a name="3559"></a>             *   As a special case, if we're running as an implied command
<a name="3560"></a>             *   within a LookIn or Search action on this same object,
<a name="3561"></a>             *   don't bother showing this result.  Doing so would be
<a name="3562"></a>             *   redundant with the explicit examination of the contents
<a name="3563"></a>             *   that we'll be doing anyway with the main action.
<a name="3564"></a>             */
<a name="3565"></a>            if (!gActor.isIn(self)
<a name="3566"></a>                &amp;&amp; transparencyCompare(transSensingIn(sight), trans) &gt; 0
<a name="3567"></a>                &amp;&amp; !(gAction.isImplicit
<a name="3568"></a>                     &amp;&amp; (gAction.parentAction.ofKind(LookInAction)
<a name="3569"></a>                         || gAction.parentAction.ofKind(SearchAction))
<a name="3570"></a>                     &amp;&amp; gAction.parentAction.getDobj() == self))
<a name="3571"></a>            {
<a name="3572"></a>                local tab;
<a name="3573"></a>
<a name="3574"></a>                /* get the table of visible objects */
<a name="3575"></a>                tab = gActor.visibleInfoTable();
<a name="3576"></a>
<a name="3577"></a>                /* show my contents list, if I have any */
<a name="3578"></a>                openingLister.showList(gActor, self, contents, ListRecurse,
<a name="3579"></a>                                       0, tab, nil);
<a name="3580"></a>
<a name="3581"></a>                /* mark my contents as having been seen */
<a name="3582"></a>                setContentsSeenBy(tab, gActor);
<a name="3583"></a>
<a name="3584"></a>                /* show any special contents as well */
<a name="3585"></a>                examineSpecialContents();
<a name="3586"></a>            }
<a name="3587"></a>        }
<a name="3588"></a>    }
<a name="3589"></a>
<a name="3590"></a>    dobjFor(Close)
<a name="3591"></a>    {
<a name="3592"></a>        verify()
<a name="3593"></a>        {
<a name="3594"></a>            /* it makes no sense to close something that's already closed */
<a name="3595"></a>            if (!isOpen)
<a name="3596"></a>                illogicalAlready(&amp;alreadyClosedMsg);
<a name="3597"></a>        }
<a name="3598"></a>        action()
<a name="3599"></a>        {
<a name="3600"></a>            /* make it closed */
<a name="3601"></a>            makeOpen(nil);
<a name="3602"></a>
<a name="3603"></a>            /* show the default report */
<a name="3604"></a>            defaultReport(&amp;okayCloseMsg);
<a name="3605"></a>        }
<a name="3606"></a>    }
<a name="3607"></a>
<a name="3608"></a>    dobjFor(LookIn)
<a name="3609"></a>    {
<a name="3610"></a>        /*
<a name="3611"></a>         *   to look in an openable object, we must be open, unless the
<a name="3612"></a>         *   object is transparent or the actor is inside us
<a name="3613"></a>         */
<a name="3614"></a>        preCond
<a name="3615"></a>        {
<a name="3616"></a>            local lst;
<a name="3617"></a>
<a name="3618"></a>            /* get the inherited preconditions */
<a name="3619"></a>            lst = nilToList(inherited());
<a name="3620"></a>
<a name="3621"></a>            /*
<a name="3622"></a>             *   if I'm not transparent looking in, and the actor isn't
<a name="3623"></a>             *   already inside me, try opening me
<a name="3624"></a>             */
<a name="3625"></a>            if (transSensingIn(sight) != transparent &amp;&amp; !gActor.isIn(self))
<a name="3626"></a>                lst += objOpen;
<a name="3627"></a>
<a name="3628"></a>            /* return the result */
<a name="3629"></a>            return lst;
<a name="3630"></a>        }
<a name="3631"></a>    }
<a name="3632"></a>
<a name="3633"></a>    dobjFor(Search)
<a name="3634"></a>    {
<a name="3635"></a>        /*
<a name="3636"></a>         *   To search an openable object, we must be open - unlike LOOK
<a name="3637"></a>         *   IN, this applies even if the object is transparent, since
<a name="3638"></a>         *   SEARCH is inherently more aggressive than LOOK IN, and implies
<a name="3639"></a>         *   physically picking through the contents.  This doesn't apply
<a name="3640"></a>         *   if the actor is already inside me.
<a name="3641"></a>         */
<a name="3642"></a>        preCond
<a name="3643"></a>        {
<a name="3644"></a>            /* get the inherited preconditions */
<a name="3645"></a>            local lst = nilToList(inherited());
<a name="3646"></a>
<a name="3647"></a>            /* if the actor isn't in me, make sure I'm open */
<a name="3648"></a>            if (!gActor.isIn(self))
<a name="3649"></a>                lst += objOpen;
<a name="3650"></a>
<a name="3651"></a>            /*
<a name="3652"></a>             *   searching implies physically sifting through the contents,
<a name="3653"></a>             *   so we need to be able to touch the object
<a name="3654"></a>             */
<a name="3655"></a>            lst += touchObj;
<a name="3656"></a>
<a name="3657"></a>            /* return the updated list */
<a name="3658"></a>            return lst;
<a name="3659"></a>        }
<a name="3660"></a>    }
<a name="3661"></a>
<a name="3662"></a>    /*
<a name="3663"></a>     *   Generate a precondition to make sure gActor can reach the interior
<a name="3664"></a>     *   of the container.  We consider the inside reachable if either the
<a name="3665"></a>     *   actor is located inside the container, or the actor is outside and
<a name="3666"></a>     *   the container is open.
<a name="3667"></a>     */
<a name="3668"></a>    addInteriorReachableCond(lst)
<a name="3669"></a>    {
<a name="3670"></a>        /*
<a name="3671"></a>         *   If the actor's inside us, they can reach our interior whether
<a name="3672"></a>         *   we're open or not, so there's no need for any additional
<a name="3673"></a>         *   condition.  If not, we need to be open for the actor to be
<a name="3674"></a>         *   able to reach our interior.
<a name="3675"></a>         */
<a name="3676"></a>        if (!gActor.isIn(self))
<a name="3677"></a>            lst = nilToList(lst) + objOpen;
<a name="3678"></a>
<a name="3679"></a>        /* return the result */
<a name="3680"></a>        return lst;
<a name="3681"></a>    }
<a name="3682"></a>
<a name="3683"></a>    iobjFor(PutIn)
<a name="3684"></a>    {
<a name="3685"></a>        /* make sure that our interior is reachable */
<a name="3686"></a>        preCond { return addInteriorReachableCond(inherited()); }
<a name="3687"></a>    }
<a name="3688"></a>
<a name="3689"></a>    iobjFor(PourInto)
<a name="3690"></a>    {
<a name="3691"></a>        /* make sure that our interior is reachable */
<a name="3692"></a>        preCond { return addInteriorReachableCond(inherited()); }
<a name="3693"></a>    }
<a name="3694"></a>
<a name="3695"></a>    /* can't lock an openable that isn't closed */
<a name="3696"></a>    dobjFor(Lock)
<a name="3697"></a>    {
<a name="3698"></a>        preCond { return nilToList(inherited()) + objClosed; }
<a name="3699"></a>    }
<a name="3700"></a>    dobjFor(LockWith)
<a name="3701"></a>    {
<a name="3702"></a>        preCond { return nilToList(inherited()) + objClosed; }
<a name="3703"></a>    }
<a name="3704"></a>
<a name="3705"></a>    /* must be open to get out of a nested room */
<a name="3706"></a>    dobjFor(GetOutOf)
<a name="3707"></a>    {
<a name="3708"></a>        preCond()
<a name="3709"></a>        {
<a name="3710"></a>            return nilToList(inherited())
<a name="3711"></a>                + new ObjectPreCondition(self, objOpen);
<a name="3712"></a>        }
<a name="3713"></a>    }
<a name="3714"></a>
<a name="3715"></a>    /* must be open to get into a nested room */
<a name="3716"></a>    dobjFor(Board)
<a name="3717"></a>    {
<a name="3718"></a>        preCond()
<a name="3719"></a>        {
<a name="3720"></a>            return nilToList(inherited())
<a name="3721"></a>                + new ObjectPreCondition(self, objOpen);
<a name="3722"></a>        }
<a name="3723"></a>    }
<a name="3724"></a>;
<a name="3725"></a>
<a name="3726"></a>/* ------------------------------------------------------------------------ */
<a name="3727"></a>/*
<a name="3728"></a> *   Lockable: a mix-in class that can be combined with an object's other
<a name="3729"></a> *   superclasses to make the object respond to the verbs "lock" and
<a name="3730"></a> *   "unlock."  A Lockable requires no key.
<a name="3731"></a> *
<a name="3732"></a> *   Note that Lockable should usually go BEFORE a Thing-derived class in
<a name="3733"></a> *   the superclass list.
<a name="3734"></a> */
<a name="3735"></a>class Lockable: Linkable
<a name="3736"></a>    /*
<a name="3737"></a>     *   Our initial locked state (i.e., at the start of the game).  By
<a name="3738"></a>     *   default, we start out locked.
<a name="3739"></a>     */
<a name="3740"></a>    initiallyLocked = true
<a name="3741"></a>
<a name="3742"></a>    /*
<a name="3743"></a>     *   Current locked state.  Use our isLocked_ status if we're the
<a name="3744"></a>     *   master, otherwise defer to the master.
<a name="3745"></a>     */
<a name="3746"></a>    isLocked()
<a name="3747"></a>    {
<a name="3748"></a>        if (masterObject == self)
<a name="3749"></a>            return isLocked_;
<a name="3750"></a>        else
<a name="3751"></a>            return masterObject.isLocked();
<a name="3752"></a>    }
<a name="3753"></a>
<a name="3754"></a>    /*
<a name="3755"></a>     *   Make the object locked or unlocked.  Objects can override this to
<a name="3756"></a>     *   apply side effects of locking or unlocking.  By default, if we're
<a name="3757"></a>     *   the master, we'll simply set our isLocked_ property to the new
<a name="3758"></a>     *   status, and otherwise defer to the master object.
<a name="3759"></a>     */
<a name="3760"></a>    makeLocked(stat)
<a name="3761"></a>    {
<a name="3762"></a>        /* apply to self or the master object, as appropriate */
<a name="3763"></a>        if (masterObject == self)
<a name="3764"></a>            isLocked_ = stat;
<a name="3765"></a>        else
<a name="3766"></a>            masterObject.makeLocked(stat);
<a name="3767"></a>
<a name="3768"></a>        /* inherit the next superclass's handling */
<a name="3769"></a>        inherited(stat);
<a name="3770"></a>    }
<a name="3771"></a>
<a name="3772"></a>    /* show our status */
<a name="3773"></a>    examineStatus()
<a name="3774"></a>    {
<a name="3775"></a>        /* inherit the default handling */
<a name="3776"></a>        inherited();
<a name="3777"></a>
<a name="3778"></a>        /*
<a name="3779"></a>         *   if our lock status is visually apparent, and we want to
<a name="3780"></a>         *   mention the lock status in our current state, show the lock
<a name="3781"></a>         *   status
<a name="3782"></a>         */
<a name="3783"></a>        if (lockStatusObvious &amp;&amp; lockStatusReportable)
<a name="3784"></a>            say(isLocked ? gLibMessages.currentlyLocked
<a name="3785"></a>                         : gLibMessages.currentlyUnlocked);
<a name="3786"></a>    }
<a name="3787"></a>
<a name="3788"></a>    /*
<a name="3789"></a>     *   Description of the object's current locked state.  In English,
<a name="3790"></a>     *   this simply returns one of 'locked' or 'unlocked'.  (Note that
<a name="3791"></a>     *   this is provided as a convenience to games, for generating
<a name="3792"></a>     *   messages about the object that include its state.  The library
<a name="3793"></a>     *   doesn't use this message itself, so overriding this won't change
<a name="3794"></a>     *   any library messages - in particular, it won't change the
<a name="3795"></a>     *   examineStatus message.)
<a name="3796"></a>     */
<a name="3797"></a>    lockedDesc = (isLocked() ? gLibMessages.lockedMsg(self)
<a name="3798"></a>                             : gLibMessages.unlockedMsg(self))
<a name="3799"></a>
<a name="3800"></a>    /*
<a name="3801"></a>     *   Is our 'locked' status obvious?  This should be set to true for an
<a name="3802"></a>     *   object whose locked/unlocked status can be visually observed, nil
<a name="3803"></a>     *   for an object whose status is not visuall apparent.  For example,
<a name="3804"></a>     *   you can usually tell from the inside that a door is locked by
<a name="3805"></a>     *   looking at the position of the lock's paddle, but on the outside
<a name="3806"></a>     *   of a door there's usually no way to see the status.
<a name="3807"></a>     *
<a name="3808"></a>     *   By default, since we can be locked and unlocked with simple LOCK
<a name="3809"></a>     *   and UNLOCK commands, we assume the status is as obvious as the
<a name="3810"></a>     *   mechanism must be to allow such simple commands.
<a name="3811"></a>     */
<a name="3812"></a>    lockStatusObvious = true
<a name="3813"></a>
<a name="3814"></a>    /*
<a name="3815"></a>     *   Is our 'locked' status reportable in our current state?  This is
<a name="3816"></a>     *   similar to lockStatusObvious, but serves a separate purpose: this
<a name="3817"></a>     *   tells us if we wish to report the lock status for aesthetic
<a name="3818"></a>     *   reasons.
<a name="3819"></a>     *
<a name="3820"></a>     *   This property is primarily of interest to mix-ins.  To allow
<a name="3821"></a>     *   mix-ins to get a say, regardless of the order of superclasses,
<a name="3822"></a>     *   we'll by default defer to any inherited value if there is in fact
<a name="3823"></a>     *   an inherited value.  If there's no inherited value, we'll simply
<a name="3824"></a>     *   return true.
<a name="3825"></a>     *
<a name="3826"></a>     *   We use this in the library for one case in particular: when we're
<a name="3827"></a>     *   mixed with Openable, we don't want to report the lock status for
<a name="3828"></a>     *   an open object because an Openable must by default be closed to be
<a name="3829"></a>     *   locked.  That is, when an Openable is open, it's always unlocked,
<a name="3830"></a>     *   so reporting that it's unlocked is essentially redundant
<a name="3831"></a>     *   information.
<a name="3832"></a>     */
<a name="3833"></a>    lockStatusReportable = (canInherit() ? inherited() : true)
<a name="3834"></a>
<a name="3835"></a>    /*
<a name="3836"></a>     *   Internal locked state.  Do not use this to set the initial state
<a name="3837"></a>     *   - set initiallyLocked in the master object instead.
<a name="3838"></a>     */
<a name="3839"></a>    isLocked_ = nil
<a name="3840"></a>
<a name="3841"></a>    /* initialization */
<a name="3842"></a>    initializeThing()
<a name="3843"></a>    {
<a name="3844"></a>        /* inherit the default handling */
<a name="3845"></a>        inherited();
<a name="3846"></a>
<a name="3847"></a>        /* if we're the master, set our initial state */
<a name="3848"></a>        if (masterObject == self)
<a name="3849"></a>            isLocked_ = initiallyLocked;
<a name="3850"></a>    }
<a name="3851"></a>
<a name="3852"></a>    /*
<a name="3853"></a>     *   Action handling
<a name="3854"></a>     */
<a name="3855"></a>
<a name="3856"></a>    /* "lock" */
<a name="3857"></a>    dobjFor(Lock)
<a name="3858"></a>    {
<a name="3859"></a>        preCond = (nilToList(inherited()) + [touchObj])
<a name="3860"></a>        verify()
<a name="3861"></a>        {
<a name="3862"></a>            /* if we're already locked, there's no point in locking us */
<a name="3863"></a>            if (isLocked)
<a name="3864"></a>                illogicalAlready(&amp;alreadyLockedMsg);
<a name="3865"></a>        }
<a name="3866"></a>        action()
<a name="3867"></a>        {
<a name="3868"></a>            /* make it locked */
<a name="3869"></a>            makeLocked(true);
<a name="3870"></a>
<a name="3871"></a>            /* make the default report */
<a name="3872"></a>            defaultReport(&amp;okayLockMsg);
<a name="3873"></a>        }
<a name="3874"></a>    }
<a name="3875"></a>
<a name="3876"></a>    /* "unlock" */
<a name="3877"></a>    dobjFor(Unlock)
<a name="3878"></a>    {
<a name="3879"></a>        preCond = (nilToList(inherited()) + [touchObj])
<a name="3880"></a>        verify()
<a name="3881"></a>        {
<a name="3882"></a>            /* if we're already unlocked, there's no point in doing this */
<a name="3883"></a>            if (!isLocked)
<a name="3884"></a>                illogicalAlready(&amp;alreadyUnlockedMsg);
<a name="3885"></a>        }
<a name="3886"></a>        action()
<a name="3887"></a>        {
<a name="3888"></a>            /* make it unlocked */
<a name="3889"></a>            makeLocked(nil);
<a name="3890"></a>
<a name="3891"></a>            /* make the default report */
<a name="3892"></a>            defaultReport(&amp;okayUnlockMsg);
<a name="3893"></a>        }
<a name="3894"></a>    }
<a name="3895"></a>
<a name="3896"></a>    /* "lock with" */
<a name="3897"></a>    dobjFor(LockWith)
<a name="3898"></a>    {
<a name="3899"></a>        preCond = (nilToList(inherited()) + [touchObj])
<a name="3900"></a>        verify() { illogical(&amp;noKeyNeededMsg); }
<a name="3901"></a>    }
<a name="3902"></a>
<a name="3903"></a>    /* "unlock with" */
<a name="3904"></a>    dobjFor(UnlockWith)
<a name="3905"></a>    {
<a name="3906"></a>        preCond = (nilToList(inherited()) + [touchObj])
<a name="3907"></a>        verify() { illogical(&amp;noKeyNeededMsg); }
<a name="3908"></a>    }
<a name="3909"></a>
<a name="3910"></a>    /*
<a name="3911"></a>     *   Should we automatically unlock this door on OPEN?  By default, we
<a name="3912"></a>     *   do this only if the lock status is obvious.
<a name="3913"></a>     */
<a name="3914"></a>    autoUnlockOnOpen = (lockStatusObvious)
<a name="3915"></a>
<a name="3916"></a>    /*
<a name="3917"></a>     *   A locked object can't be opened - apply a precondition and a check
<a name="3918"></a>     *   for "open" that ensures that we unlock this object before we can
<a name="3919"></a>     *   open it.
<a name="3920"></a>     *
<a name="3921"></a>     *   If the lock status isn't obvious, don't try to unlock the object
<a name="3922"></a>     *   as a precondition.  Instead, test to make sure it's unlocked in
<a name="3923"></a>     *   the 'check' routine, and fail.
<a name="3924"></a>     */
<a name="3925"></a>    dobjFor(Open)
<a name="3926"></a>    {
<a name="3927"></a>        preCond()
<a name="3928"></a>        {
<a name="3929"></a>            /* start with the inherited preconditions */
<a name="3930"></a>            local ret = nilToList(inherited());
<a name="3931"></a>
<a name="3932"></a>            /* automatically unlock on open, if appropriate */
<a name="3933"></a>            if (autoUnlockOnOpen)
<a name="3934"></a>                ret += objUnlocked;
<a name="3935"></a>
<a name="3936"></a>            /* return the result */
<a name="3937"></a>            return ret;
<a name="3938"></a>        }
<a name="3939"></a>
<a name="3940"></a>        check()
<a name="3941"></a>        {
<a name="3942"></a>            /* make sure we're unlocked */
<a name="3943"></a>            if (isLocked)
<a name="3944"></a>            {
<a name="3945"></a>                /* let them know we're locked */
<a name="3946"></a>                reportFailure(&amp;cannotOpenLockedMsg);
<a name="3947"></a>
<a name="3948"></a>                /* set 'it' to me, so UNLOCK IT works */
<a name="3949"></a>                gActor.setPronounObj(self);
<a name="3950"></a>
<a name="3951"></a>                /* we cannot proceed */
<a name="3952"></a>                exit;
<a name="3953"></a>            }
<a name="3954"></a>
<a name="3955"></a>            /* inherit the default handling */
<a name="3956"></a>            inherited();
<a name="3957"></a>        }
<a name="3958"></a>    }
<a name="3959"></a>;
<a name="3960"></a>
<a name="3961"></a>/* ------------------------------------------------------------------------ */
<a name="3962"></a>/*
<a name="3963"></a> *   A lockable that can't be locked and unlocked by direct action.  The
<a name="3964"></a> *   LOCK and UNLOCK commands cannot be used with this kind of lockable.
<a name="3965"></a> *
<a name="3966"></a> *   This is useful for a couple of situations.  First, it's useful when we
<a name="3967"></a> *   want to create a locked object that simply can't be unlocked, such as
<a name="3968"></a> *   a locked door that forms a permanent boundary of the map.  Second,
<a name="3969"></a> *   it's useful for locked objects that must be unlocked by some other
<a name="3970"></a> *   means, such as manipulating an external mechanism (pulling a lever,
<a name="3971"></a> *   say).  In these cases, the trick is to figure out the separate means
<a name="3972"></a> *   of unlocking the door, so we don't want the LOCK and UNLOCK commands
<a name="3973"></a> *   to work directly.
<a name="3974"></a> */
<a name="3975"></a>class IndirectLockable: Lockable
<a name="3976"></a>    dobjFor(Lock)
<a name="3977"></a>    {
<a name="3978"></a>        check()
<a name="3979"></a>        {
<a name="3980"></a>            reportFailure(cannotLockMsg);
<a name="3981"></a>            exit;
<a name="3982"></a>        }
<a name="3983"></a>    }
<a name="3984"></a>    dobjFor(LockWith) asDobjFor(Lock)
<a name="3985"></a>    dobjFor(Unlock)
<a name="3986"></a>    {
<a name="3987"></a>        check()
<a name="3988"></a>        {
<a name="3989"></a>            reportFailure(cannotUnlockMsg);
<a name="3990"></a>            exit;
<a name="3991"></a>        }
<a name="3992"></a>    }
<a name="3993"></a>    dobjFor(UnlockWith) asDobjFor(Unlock)
<a name="3994"></a>
<a name="3995"></a>    /*
<a name="3996"></a>     *   Since we can't be locked and unlocked with simple LOCK and UNLOCK
<a name="3997"></a>     *   commands, presume that the lock status isn't obvious.  If the
<a name="3998"></a>     *   alternative mechanism that locks and unlocks the object makes the
<a name="3999"></a>     *   current status readily apparent, this should be overridden and set
<a name="4000"></a>     *   to true.
<a name="4001"></a>     */
<a name="4002"></a>    lockStatusObvious = nil
<a name="4003"></a>
<a name="4004"></a>    /* the message we display in response to LOCK/UNLOCK */
<a name="4005"></a>    cannotLockMsg = &amp;unknownHowToLockMsg
<a name="4006"></a>    cannotUnlockMsg = &amp;unknownHowToUnlockMsg
<a name="4007"></a>;
<a name="4008"></a>
<a name="4009"></a>
<a name="4010"></a>/* ------------------------------------------------------------------------ */
<a name="4011"></a>/*
<a name="4012"></a> *   LockableWithKey: a mix-in class that can be combined with an object's
<a name="4013"></a> *   other superclasses to make the object respond to the verbs "lock" and
<a name="4014"></a> *   "unlock," with a key as an indirect object.  A LockableWithKey cannot
<a name="4015"></a> *   be locked or unlocked except with the keys listed in the keyList
<a name="4016"></a> *   property.
<a name="4017"></a> *
<a name="4018"></a> *   Note that LockableWithKey should usually go BEFORE a Thing-derived
<a name="4019"></a> *   class in the superclass list.
<a name="4020"></a> */
<a name="4021"></a>class LockableWithKey: Lockable
<a name="4022"></a>    /*
<a name="4023"></a>     *   Determine if the key fits this lock.  Returns true if so, nil if
<a name="4024"></a>     *   not.  By default, we'll return true if the key is in my keyList.
<a name="4025"></a>     *   This can be overridden to use other key selection criteria.
<a name="4026"></a>     */
<a name="4027"></a>    keyFitsLock(key) { return keyList.indexOf(key) != nil; }
<a name="4028"></a>
<a name="4029"></a>    /*
<a name="4030"></a>     *   Determine if the key is plausibly of the right type for this
<a name="4031"></a>     *   lock.  This doesn't check to see if the key actually fits the
<a name="4032"></a>     *   lock - rather, this checks to see if the key is generally the
<a name="4033"></a>     *   kind of object that might plausibly be used with this lock.
<a name="4034"></a>     *
<a name="4035"></a>     *   The point of this routine is to make this class concerned only
<a name="4036"></a>     *   with the abstract notion of objects that serve to lock and unlock
<a name="4037"></a>     *   other objects, without requiring that the key objects resemble
<a name="4038"></a>     *   little notched metal sticks or that the lock objects resemble
<a name="4039"></a>     *   cylinders with pins - or, more specifically, without requiring
<a name="4040"></a>     *   that all of the kinds of keys in a game remotely resemble one
<a name="4041"></a>     *   another.
<a name="4042"></a>     *
<a name="4043"></a>     *   For example, one kind of "key" in a game might be a plastic card
<a name="4044"></a>     *   with a magnetic stripe, and the corresponding lock would be a
<a name="4045"></a>     *   card slot; another kind of key might the traditional notched
<a name="4046"></a>     *   metal stick.  Clearly, no one would ever think to use a plastic
<a name="4047"></a>     *   card with a conventional door lock, nor would one try to put a
<a name="4048"></a>     *   house key into a card slot (not with the expectation that it
<a name="4049"></a>     *   would actually work, anyway).  This routine is meant to
<a name="4050"></a>     *   facilitate this kind of distinction: the card slot can use this
<a name="4051"></a>     *   routine to indicate that only plastic card objects are plausible
<a name="4052"></a>     *   as keys, and door locks can indicate that only metal keys are
<a name="4053"></a>     *   plausible.
<a name="4054"></a>     *
<a name="4055"></a>     *   This routine can be used for disambiguation and other purposes
<a name="4056"></a>     *   when we must programmatically select a key that is not specified
<a name="4057"></a>     *   or is only vaguely specified.  For example, the keyring searcher
<a name="4058"></a>     *   uses it so that, when we're searching for a key on a keyring to
<a name="4059"></a>     *   open this lock, we implicitly try only the kinds of keys that
<a name="4060"></a>     *   would be plausibly useful for this kind of lock.
<a name="4061"></a>     *
<a name="4062"></a>     *   By default, we'll simply return true.  Subclasses specific to a
<a name="4063"></a>     *   game (such as the "card reader" base class or the "door lock"
<a name="4064"></a>     *   base class) can override this to discriminate among the
<a name="4065"></a>     *   game-specific key classes.
<a name="4066"></a>     */
<a name="4067"></a>    keyIsPlausible(key) { return true; }
<a name="4068"></a>
<a name="4069"></a>    /* the list of objects that can serve as keys for this object */
<a name="4070"></a>    keyList = []
<a name="4071"></a>
<a name="4072"></a>    /*
<a name="4073"></a>     *   The list of keys which the player knows will fit this lock.  This
<a name="4074"></a>     *   is used to make key disambiguation automatic once the player
<a name="4075"></a>     *   knows the correct key for a lock.
<a name="4076"></a>     */
<a name="4077"></a>    knownKeyList = []
<a name="4078"></a>
<a name="4079"></a>    /*
<a name="4080"></a>     *   Get my known key list.  This simply returns the known key list
<a name="4081"></a>     *   from the known key owner.
<a name="4082"></a>     */
<a name="4083"></a>    getKnownKeyList() { return getKnownKeyOwner().knownKeyList; }
<a name="4084"></a>
<a name="4085"></a>    /*
<a name="4086"></a>     *   Get the object that own our known key list.  If we explicitly have
<a name="4087"></a>     *   our own non-empty known key list, we own the key list; otherwise,
<a name="4088"></a>     *   our master object owns the list, as long as it has a non-nil key
<a name="4089"></a>     *   list at all.
<a name="4090"></a>     */
<a name="4091"></a>    getKnownKeyOwner()
<a name="4092"></a>    {
<a name="4093"></a>        /*
<a name="4094"></a>         *   if we have a non-empty key list, or our master object doesn't
<a name="4095"></a>         *   have a key list at all, use our list; otherwise, use our
<a name="4096"></a>         *   master object's list so use our list
<a name="4097"></a>         */
<a name="4098"></a>        if (knownKeyList.length() != 0 || masterObject.knownKeyList == nil)
<a name="4099"></a>            return self;
<a name="4100"></a>        else
<a name="4101"></a>            return masterObject;
<a name="4102"></a>    }
<a name="4103"></a>
<a name="4104"></a>    /*
<a name="4105"></a>     *   Flag: remember my keys after they're successfully used.  If this
<a name="4106"></a>     *   is true, whenever a key is successfully used to lock or unlock
<a name="4107"></a>     *   this object, we'll add the key to our known key list;
<a name="4108"></a>     *   subsequently, whenever we try to use a key in this lock, we will
<a name="4109"></a>     *   automatically disambiguate the key based on the keys known to
<a name="4110"></a>     *   work previously.
<a name="4111"></a>     *
<a name="4112"></a>     *   Some authors might prefer not to assume that the player should
<a name="4113"></a>     *   remember which keys operate which locks, so this property can be
<a name="4114"></a>     *   changed to nil to eliminate this memory feature.  By default we
<a name="4115"></a>     *   set this to true, since it shouldn't generally give away any
<a name="4116"></a>     *   secrets or puzzles for the game to assume that a key that was
<a name="4117"></a>     *   used successfully once with a given lock is the one to be used
<a name="4118"></a>     *   subsequently with the same lock.
<a name="4119"></a>     */
<a name="4120"></a>    rememberKnownKeys = true
<a name="4121"></a>
<a name="4122"></a>    /*
<a name="4123"></a>     *   Determine if the player knows that the given key operates this
<a name="4124"></a>     *   lock.  Returns true if the key is in our known key list, nil if
<a name="4125"></a>     *   not.
<a name="4126"></a>     */
<a name="4127"></a>    isKeyKnown(key) { return getKnownKeyList().indexOf(key) != nil; }
<a name="4128"></a>
<a name="4129"></a>    /*
<a name="4130"></a>     *   By default, the locked/unlocked status of a keyed lockable is nil.
<a name="4131"></a>     *   In most cases, an object that's locked and unlocked using a key
<a name="4132"></a>     *   doesn't have a visible indication of the status; for example, you
<a name="4133"></a>     *   usually can't tell just by looking at it from the outside whether
<a name="4134"></a>     *   or not an exterior door to a building is locked.  Usually, the
<a name="4135"></a>     *   only way to tell from the outside that an exterior door is locked
<a name="4136"></a>     *   is to try opening it and see if it opens.
<a name="4137"></a>     */
<a name="4138"></a>    lockStatusObvious = nil
<a name="4139"></a>
<a name="4140"></a>    /*
<a name="4141"></a>     *   Should we automatically unlock on OPEN?  We will if our inherited
<a name="4142"></a>     *   handling says so, OR if the current actor is carrying a key
<a name="4143"></a>     *   that's known to work with this object.  We automatically unlock
<a name="4144"></a>     *   when a known key is present as a convenience: if we have a known
<a name="4145"></a>     *   key, then there's no mystery in unlocking this object, and thus
<a name="4146"></a>     *   for playability we want to make its operation fully automatic.
<a name="4147"></a>     */
<a name="4148"></a>    autoUnlockOnOpen()
<a name="4149"></a>    {
<a name="4150"></a>        return (inherited()
<a name="4151"></a>                || getKnownKeyList.indexWhich({x: x.isIn(gActor)}) != nil);
<a name="4152"></a>    }
<a name="4153"></a>
<a name="4154"></a>    /*
<a name="4155"></a>     *   Action handling
<a name="4156"></a>     */
<a name="4157"></a>
<a name="4158"></a>    dobjFor(Lock)
<a name="4159"></a>    {
<a name="4160"></a>        preCond
<a name="4161"></a>        {
<a name="4162"></a>            /*
<a name="4163"></a>             *   remove any objClosed from our precondition - since we
<a name="4164"></a>             *   won't actually do any locking but will instead merely ask
<a name="4165"></a>             *   for an indirect object, we don't want to apply the normal
<a name="4166"></a>             *   closed precondition here
<a name="4167"></a>             */
<a name="4168"></a>            return inherited() - objClosed;
<a name="4169"></a>        }
<a name="4170"></a>        verify()
<a name="4171"></a>        {
<a name="4172"></a>            /* if we're already locked, there's no point in locking us */
<a name="4173"></a>            if (isLocked)
<a name="4174"></a>                illogicalAlready(&amp;alreadyLockedMsg);
<a name="4175"></a>        }
<a name="4176"></a>        action()
<a name="4177"></a>        {
<a name="4178"></a>            /* ask for an indirect object to use as the key */
<a name="4179"></a>            askForIobj(LockWith);
<a name="4180"></a>        }
<a name="4181"></a>    }
<a name="4182"></a>
<a name="4183"></a>    /* "unlock" */
<a name="4184"></a>    dobjFor(Unlock)
<a name="4185"></a>    {
<a name="4186"></a>        verify()
<a name="4187"></a>        {
<a name="4188"></a>            /* if we're not locked, there's no point in unlocking us */
<a name="4189"></a>            if (!isLocked)
<a name="4190"></a>                illogicalAlready(&amp;alreadyUnlockedMsg);
<a name="4191"></a>        }
<a name="4192"></a>        action()
<a name="4193"></a>        {
<a name="4194"></a>            /*
<a name="4195"></a>             *   We need a key.  If we're running as an implied action, the
<a name="4196"></a>             *   player hasn't specifically proposed unlocking the object,
<a name="4197"></a>             *   so it's a little weird to ask a follow-up question about
<a name="4198"></a>             *   what key to use.  So, if the action is implicit and
<a name="4199"></a>             *   there's no default key, don't proceed; simply fail with an
<a name="4200"></a>             *   explanation.
<a name="4201"></a>             */
<a name="4202"></a>            if (gAction.isImplicit
<a name="4203"></a>                &amp;&amp; !UnlockWithAction.testRetryDefaultIobj(gAction))
<a name="4204"></a>            {
<a name="4205"></a>                /* explain that we need a key, and we're done */
<a name="4206"></a>                reportFailure(&amp;unlockRequiresKeyMsg);
<a name="4207"></a>                return;
<a name="4208"></a>            }
<a name="4209"></a>
<a name="4210"></a>            /* ask for a key */
<a name="4211"></a>            askForIobj(UnlockWith);
<a name="4212"></a>        }
<a name="4213"></a>    }
<a name="4214"></a>
<a name="4215"></a>    /*
<a name="4216"></a>     *   perform the action processing for LockWith or UnlockWith - these
<a name="4217"></a>     *   are highly symmetrical, in that the only thing that varies is the
<a name="4218"></a>     *   new lock state we establish
<a name="4219"></a>     */
<a name="4220"></a>    lockOrUnlockAction(lock)
<a name="4221"></a>    {
<a name="4222"></a>        /*
<a name="4223"></a>         *   If it's a keyring, let the keyring's action handler do the
<a name="4224"></a>         *   work.  Otherwise, if it's my key, lock/unlock; it's not a
<a name="4225"></a>         *   key, fail.
<a name="4226"></a>         */
<a name="4227"></a>        if (gIobj.ofKind(Keyring))
<a name="4228"></a>        {
<a name="4229"></a>            /*
<a name="4230"></a>             *   do nothing - let the indirect object action handler do
<a name="4231"></a>             *   the work
<a name="4232"></a>             */
<a name="4233"></a>        }
<a name="4234"></a>        else if (keyFitsLock(gIobj))
<a name="4235"></a>        {
<a name="4236"></a>            local ko;
<a name="4237"></a>
<a name="4238"></a>            /*
<a name="4239"></a>             *   get the object (us or our master object) that owns the
<a name="4240"></a>             *   known key list
<a name="4241"></a>             */
<a name="4242"></a>            ko = getKnownKeyOwner();
<a name="4243"></a>
<a name="4244"></a>            /*
<a name="4245"></a>             *   if the key owner remembers known keys, and it doesn't know
<a name="4246"></a>             *   about this working key yet, remember this in the list of
<a name="4247"></a>             *   known keys
<a name="4248"></a>             */
<a name="4249"></a>            if (ko.rememberKnownKeys
<a name="4250"></a>                &amp;&amp; ko.knownKeyList.indexOf(gIobj) == nil)
<a name="4251"></a>                ko.knownKeyList += gIobj;
<a name="4252"></a>
<a name="4253"></a>            /* set my new state and issue a default report */
<a name="4254"></a>            makeLocked(lock);
<a name="4255"></a>            defaultReport(lock ? &amp;okayLockMsg : &amp;okayUnlockMsg);
<a name="4256"></a>        }
<a name="4257"></a>        else
<a name="4258"></a>        {
<a name="4259"></a>            /* the key doesn't work in this lock */
<a name="4260"></a>            reportFailure(&amp;keyDoesNotFitLockMsg);
<a name="4261"></a>        }
<a name="4262"></a>    }
<a name="4263"></a>
<a name="4264"></a>    /* "lock with" */
<a name="4265"></a>    dobjFor(LockWith)
<a name="4266"></a>    {
<a name="4267"></a>        verify()
<a name="4268"></a>        {
<a name="4269"></a>            /* if we're already locked, there's no point in locking us */
<a name="4270"></a>            if (isLocked)
<a name="4271"></a>                illogicalAlready(&amp;alreadyLockedMsg);
<a name="4272"></a>        }
<a name="4273"></a>        action()
<a name="4274"></a>        {
<a name="4275"></a>            /* perform the generic lock/unlock action processing */
<a name="4276"></a>            lockOrUnlockAction(true);
<a name="4277"></a>        }
<a name="4278"></a>    }
<a name="4279"></a>
<a name="4280"></a>    /* "unlock with" */
<a name="4281"></a>    dobjFor(UnlockWith)
<a name="4282"></a>    {
<a name="4283"></a>        verify()
<a name="4284"></a>        {
<a name="4285"></a>            /* if we're not locked, there's no point in unlocking us */
<a name="4286"></a>            if (!isLocked)
<a name="4287"></a>                illogicalAlready(&amp;alreadyUnlockedMsg);
<a name="4288"></a>        }
<a name="4289"></a>        action()
<a name="4290"></a>        {
<a name="4291"></a>            /* perform the generic lock/unlock action processing */
<a name="4292"></a>            lockOrUnlockAction(nil);
<a name="4293"></a>        }
<a name="4294"></a>    }
<a name="4295"></a>;
<a name="4296"></a>
<a name="4297"></a>/* ------------------------------------------------------------------------ */
<a name="4298"></a>/*
<a name="4299"></a> *   The common base class for containers and surfaces: things that have
<a name="4300"></a> *   limited bulk capacities.  This class isn't usually used directly;
<a name="4301"></a> *   subclasses such as Surface and Container are usually used instead.
<a name="4302"></a> */
<a name="4303"></a>class BulkLimiter: Thing
<a name="4304"></a>    /*
<a name="4305"></a>     *   A container can limit the cumulative amount of bulk of its
<a name="4306"></a>     *   contents, and the maximum bulk of any one object, using
<a name="4307"></a>     *   bulkCapacity and maxSingleBulk.  We count the cumulative and
<a name="4308"></a>     *   single-item limits separately, since we want to allow modelling
<a name="4309"></a>     *   some objects as so large that they won't fit in this container at
<a name="4310"></a>     *   all, even if the container is carrying nothing else, without
<a name="4311"></a>     *   limiting the number of small items we can carry.
<a name="4312"></a>     *
<a name="4313"></a>     *   By default, we set bulkCapacity to a very large number, making
<a name="4314"></a>     *   the total capacity of the object essentially unlimited.  However,
<a name="4315"></a>     *   we set maxSingleBulk to a relatively low number - this way, if an
<a name="4316"></a>     *   author wants to designate certain objects as especially large and
<a name="4317"></a>     *   thus unable to fit in ordinary containers, the author merely
<a name="4318"></a>     *   needs to set the bulk of those large items to something greater
<a name="4319"></a>     *   than 10.  On the other hand, if an author doesn't want to worry
<a name="4320"></a>     *   about bulk and limited carrying capacities and simply uses
<a name="4321"></a>     *   library defaults for everything, we will be able to contain
<a name="4322"></a>     *   anything and everything.
<a name="4323"></a>     *
<a name="4324"></a>     *   In a game that models bulk realistically, a container's bulk
<a name="4325"></a>     *   should generally be equal to or slightly greater than its
<a name="4326"></a>     *   bulkCapacity, because a container shouldn't be smaller on the
<a name="4327"></a>     *   outside than on the inside.  If bulkCapacity exceeds bulk, the
<a name="4328"></a>     *   player can work around a holding bulk limit by piling objects
<a name="4329"></a>     *   into the container, thus "hiding" the bulks of the contents
<a name="4330"></a>     *   behind the smaller bulk of the container.
<a name="4331"></a>     */
<a name="4332"></a>    bulkCapacity = 10000
<a name="4333"></a>    maxSingleBulk = 10
<a name="4334"></a>
<a name="4335"></a>    /*
<a name="4336"></a>     *   receive notification that we're about to insert an object into
<a name="4337"></a>     *   this container
<a name="4338"></a>     */
<a name="4339"></a>    notifyInsert(obj, newCont)
<a name="4340"></a>    {
<a name="4341"></a>        /* if I'm the new direct container, check our bulk limit */
<a name="4342"></a>        if (newCont == self)
<a name="4343"></a>        {
<a name="4344"></a>            /*
<a name="4345"></a>             *   do a 'what if' test to see what would happen to our
<a name="4346"></a>             *   contained bulk if we moved this item into me
<a name="4347"></a>             */
<a name="4348"></a>            obj.whatIf({: checkBulkInserted(obj)}, &amp;moveInto, self);
<a name="4349"></a>        }
<a name="4350"></a>
<a name="4351"></a>        /* inherit base class handling */
<a name="4352"></a>        inherited(obj, newCont);
<a name="4353"></a>    }
<a name="4354"></a>
<a name="4355"></a>    /*
<a name="4356"></a>     *   Check to see if a proposed insertion - already tentatively in
<a name="4357"></a>     *   effect when this routine is called - would overflow our bulk
<a name="4358"></a>     *   limits.  Reports failure and exits if the inserted object would
<a name="4359"></a>     *   exceed our capacity.
<a name="4360"></a>     */
<a name="4361"></a>    checkBulkInserted(insertedObj)
<a name="4362"></a>    {
<a name="4363"></a>        local objBulk;
<a name="4364"></a>
<a name="4365"></a>        /* get the bulk of the inserted object itself */
<a name="4366"></a>        objBulk = insertedObj.getBulk();
<a name="4367"></a>
<a name="4368"></a>        /*
<a name="4369"></a>         *   Check the object itself to see if it fits by itself.  If it
<a name="4370"></a>         *   doesn't, we can report the simple fact that the object is too
<a name="4371"></a>         *   big for the container.
<a name="4372"></a>         */
<a name="4373"></a>        if (objBulk &gt; maxSingleBulk || objBulk &gt; bulkCapacity)
<a name="4374"></a>        {
<a name="4375"></a>            reportFailure(&amp;tooLargeForContainerMsg, insertedObj, self);
<a name="4376"></a>            exit;
<a name="4377"></a>        }
<a name="4378"></a>
<a name="4379"></a>        /*
<a name="4380"></a>         *   If our contained bulk is over our maximum, don't allow it.
<a name="4381"></a>         *   Note that we merely need to check our current bulk within,
<a name="4382"></a>         *   since this routine is called with the insertion already
<a name="4383"></a>         *   tentatively in effect.
<a name="4384"></a>         */
<a name="4385"></a>        if (getBulkWithin() &gt; bulkCapacity)
<a name="4386"></a>        {
<a name="4387"></a>            reportFailure(tooFullMsg, insertedObj, self);
<a name="4388"></a>            exit;
<a name="4389"></a>        }
<a name="4390"></a>    }
<a name="4391"></a>
<a name="4392"></a>    /*
<a name="4393"></a>     *   the message property to use when we're too full to hold a new
<a name="4394"></a>     *   object (i.e., the object's bulk would push us over our bulk
<a name="4395"></a>     *   capacity limit)
<a name="4396"></a>     */
<a name="4397"></a>    tooFullMsg = &amp;containerTooFullMsg
<a name="4398"></a>
<a name="4399"></a>    /*
<a name="4400"></a>     *   the message property to use when doing something to one of our
<a name="4401"></a>     *   contents would make it too large to fit all by itself into this
<a name="4402"></a>     *   container (that is, it would cause that object's bulk to exceed
<a name="4403"></a>     *   our maxSingleBulk)
<a name="4404"></a>     */
<a name="4405"></a>    becomingTooLargeMsg = &amp;becomingTooLargeForContainerMsg
<a name="4406"></a>
<a name="4407"></a>    /*
<a name="4408"></a>     *   the message property to use when doing something to one of our
<a name="4409"></a>     *   contents would cause our overall contents to exceed our capacity
<a name="4410"></a>     */
<a name="4411"></a>    becomingTooFullMsg = &amp;containerBecomingTooFullMsg
<a name="4412"></a>
<a name="4413"></a>    /*
<a name="4414"></a>     *   Check a bulk change of one of my direct contents.
<a name="4415"></a>     */
<a name="4416"></a>    checkBulkChangeWithin(obj)
<a name="4417"></a>    {
<a name="4418"></a>        local objBulk;
<a name="4419"></a>
<a name="4420"></a>        /* get the object's new bulk */
<a name="4421"></a>        objBulk = obj.getBulk();
<a name="4422"></a>
<a name="4423"></a>        /*
<a name="4424"></a>         *   if this change would cause the object to exceed our
<a name="4425"></a>         *   single-item bulk limit, don't allow it
<a name="4426"></a>         */
<a name="4427"></a>        if (objBulk &gt; maxSingleBulk || objBulk &gt; bulkCapacity)
<a name="4428"></a>        {
<a name="4429"></a>            reportFailure(becomingTooLargeMsg, obj, self);
<a name="4430"></a>            exit;
<a name="4431"></a>        }
<a name="4432"></a>
<a name="4433"></a>        /*
<a name="4434"></a>         *   If our total carrying capacity is exceeded with this change,
<a name="4435"></a>         *   don't allow it.  Note that 'obj' is already among our
<a name="4436"></a>         *   contents when this routine is called, so we can simply check
<a name="4437"></a>         *   our current total bulk within.
<a name="4438"></a>         */
<a name="4439"></a>        if (getBulkWithin() &gt; bulkCapacity)
<a name="4440"></a>        {
<a name="4441"></a>            reportFailure(becomingTooFullMsg, obj, self);
<a name="4442"></a>            exit;
<a name="4443"></a>        }
<a name="4444"></a>    }
<a name="4445"></a>
<a name="4446"></a>    /*
<a name="4447"></a>     *   Adjust a THROW destination.  Since we only allow a limited amount
<a name="4448"></a>     *   of bulk within our contents, we need to make sure the thrown
<a name="4449"></a>     *   object would fit if it landed here.  If it doesn't, we'll redirect
<a name="4450"></a>     *   the landing site to our container.
<a name="4451"></a>     */
<a name="4452"></a>    adjustThrowDestination(thrownObj, path)
<a name="4453"></a>    {
<a name="4454"></a>        local thrownBulk = thrownObj.getBulk();
<a name="4455"></a>        local newBulk;
<a name="4456"></a>        local dest;
<a name="4457"></a>
<a name="4458"></a>        /*
<a name="4459"></a>         *   do a 'what if' test to test our total bulk with the projectile
<a name="4460"></a>         *   added to my contents
<a name="4461"></a>         */
<a name="4462"></a>        newBulk = thrownObj.whatIf({: getBulkWithin()}, &amp;moveInto, self);
<a name="4463"></a>
<a name="4464"></a>        /*
<a name="4465"></a>         *   If that exceeds our maximum bulk, or the object's bulk
<a name="4466"></a>         *   individually is over our limit, we can't be the landing site.
<a name="4467"></a>         *   In this case, defer to our location's drop destination, if it
<a name="4468"></a>         *   has one.
<a name="4469"></a>         */
<a name="4470"></a>        if ((newBulk &gt; bulkCapacity
<a name="4471"></a>            || thrownBulk &gt; bulkCapacity
<a name="4472"></a>            || thrownBulk &gt; maxSingleBulk)
<a name="4473"></a>            &amp;&amp; location != nil
<a name="4474"></a>            &amp;&amp; (dest = location.getDropDestination(thrownObj, path)) != nil)
<a name="4475"></a>        {
<a name="4476"></a>            /*
<a name="4477"></a>             *   It won't fit, so defer to our container's drop
<a name="4478"></a>             *   destination.  Give the new destination a chance to further
<a name="4479"></a>             *   adjust the destination.
<a name="4480"></a>             */
<a name="4481"></a>            return dest.adjustThrowDestination(thrownObj, path);
<a name="4482"></a>        }
<a name="4483"></a>
<a name="4484"></a>        /*
<a name="4485"></a>         *   the projectile fits, or we just can't find a container to
<a name="4486"></a>         *   defer to; use the original destination, i.e., self
<a name="4487"></a>         */
<a name="4488"></a>        return self;
<a name="4489"></a>    }
<a name="4490"></a>
<a name="4491"></a>    /*
<a name="4492"></a>     *   Examine my interior.  This can be used to handle the action() for
<a name="4493"></a>     *   LOOK IN, or for other commands appropriate to the subclass.
<a name="4494"></a>     */
<a name="4495"></a>    examineInterior()
<a name="4496"></a>    {
<a name="4497"></a>        /* examine the interior with our normal look-in lister */
<a name="4498"></a>        examineInteriorWithLister(lookInLister);
<a name="4499"></a>
<a name="4500"></a>        /*
<a name="4501"></a>         *   Anything that the an overriding caller (a routine that called
<a name="4502"></a>         *   us with 'inherited') wants to add is an addendum to our
<a name="4503"></a>         *   description, so add a transcript marker to indicate that the
<a name="4504"></a>         *   main description is now finished.
<a name="4505"></a>         *
<a name="4506"></a>         *   The important thing about this is that any message that an
<a name="4507"></a>         *   overriding caller wants to add is not considered part of the
<a name="4508"></a>         *   description, in the sense that we don't want it to suppress
<a name="4509"></a>         *   any default description we've already generated.  One of the
<a name="4510"></a>         *   transformations we apply to the transcript is to suppress any
<a name="4511"></a>         *   default descriptive text if there's any more specific
<a name="4512"></a>         *   descriptive text following (for example, we suppress "It's an
<a name="4513"></a>         *   ordinary &lt;thing&gt;" if we also are going to say "it's open" or
<a name="4514"></a>         *   "it contains three coins").  If we have an overriding caller
<a name="4515"></a>         *   who's going to add anything, then we must assume that what the
<a name="4516"></a>         *   caller's adding is something about the act of examining the
<a name="4517"></a>         *   object, rather than a description of the object, so we don't
<a name="4518"></a>         *   want it to suppress a default description.
<a name="4519"></a>         */
<a name="4520"></a>        gTranscript.endDescription();
<a name="4521"></a>    }
<a name="4522"></a>
<a name="4523"></a>    /* examine my interior, listing the contents with the given lister */
<a name="4524"></a>    examineInteriorWithLister(lister)
<a name="4525"></a>    {
<a name="4526"></a>        local tab;
<a name="4527"></a>
<a name="4528"></a>        /* if desired, reveal any "Hidden" items concealed within */
<a name="4529"></a>        if (revealHiddenItems)
<a name="4530"></a>        {
<a name="4531"></a>            /* scan our contents and reveal each Hidden item */
<a name="4532"></a>            foreach (local cur in contents)
<a name="4533"></a>            {
<a name="4534"></a>                /* if it's a Hidden item, reveal it */
<a name="4535"></a>                if (cur.ofKind(Hidden))
<a name="4536"></a>                    cur.discover();
<a name="4537"></a>            }
<a name="4538"></a>        }
<a name="4539"></a>
<a name="4540"></a>        /* get my visible sense info */
<a name="4541"></a>        tab = gActor.visibleInfoTable();
<a name="4542"></a>
<a name="4543"></a>        /* show my contents, if I have any */
<a name="4544"></a>        lister.showList(gActor, self, contents, ListRecurse,  0, tab, nil);
<a name="4545"></a>
<a name="4546"></a>        /* mark my contents as having been seen */
<a name="4547"></a>        setContentsSeenBy(tab, gActor);
<a name="4548"></a>
<a name="4549"></a>        /* examine my special contents */
<a name="4550"></a>        examineSpecialContents();
<a name="4551"></a>    }
<a name="4552"></a>
<a name="4553"></a>    /*
<a name="4554"></a>     *   Verify putting something new in my interior.  This is suitable
<a name="4555"></a>     *   for use as a verify() method for a command like PutIn or PutOn.
<a name="4556"></a>     *   Note that this routine assumes and requires that gDobj be the
<a name="4557"></a>     *   object to be added, and gIobj be self.
<a name="4558"></a>     */
<a name="4559"></a>    verifyPutInInterior()
<a name="4560"></a>    {
<a name="4561"></a>        /*
<a name="4562"></a>         *   if we haven't resolved the direct object yet, we can at least
<a name="4563"></a>         *   check to see if all of the potential direct objects are
<a name="4564"></a>         *   already in me, and rule out this indirect object as illogical
<a name="4565"></a>         *   if so
<a name="4566"></a>         */
<a name="4567"></a>        if (gDobj == nil)
<a name="4568"></a>        {
<a name="4569"></a>            /*
<a name="4570"></a>             *   check the tentative direct objects to see if (1) all of
<a name="4571"></a>             *   them are directly inside me already, or (2) all of them
<a name="4572"></a>             *   are at least indirectly inside me already
<a name="4573"></a>             */
<a name="4574"></a>            if (gTentativeDobj.indexWhich(
<a name="4575"></a>                {x: !x.obj_.isDirectlyIn(self)}) == nil)
<a name="4576"></a>            {
<a name="4577"></a>                /*
<a name="4578"></a>                 *   All of the potential direct objects are already
<a name="4579"></a>                 *   directly inside me.  This makes this object
<a name="4580"></a>                 *   illogical, since there's no need to move any of these
<a name="4581"></a>                 *   objects into me.
<a name="4582"></a>                 */
<a name="4583"></a>                illogicalAlready(&amp;alreadyPutInMsg);
<a name="4584"></a>            }
<a name="4585"></a>            else if (gTentativeDobj.indexWhich(
<a name="4586"></a>                {x: !x.obj_.isIn(self)}) == nil)
<a name="4587"></a>            {
<a name="4588"></a>                /*
<a name="4589"></a>                 *   All of the potential direct objects are already in
<a name="4590"></a>                 *   me, at least indirectly.  This makes this object
<a name="4591"></a>                 *   somewhat less likely, since we're more likely to want
<a name="4592"></a>                 *   to put something in here that wasn't already within.
<a name="4593"></a>                 *   Note that this isn't actually illogical, though,
<a name="4594"></a>                 *   since we could be moving something from deeper inside
<a name="4595"></a>                 *   me to directly inside me.
<a name="4596"></a>                 */
<a name="4597"></a>                logicalRank(50, 'dobjs already inside');
<a name="4598"></a>            }
<a name="4599"></a>        }
<a name="4600"></a>        else
<a name="4601"></a>        {
<a name="4602"></a>            /*
<a name="4603"></a>             *   We can't put myself in myself, obviously.  We also can't
<a name="4604"></a>             *   put something into any component of itself, so the command
<a name="4605"></a>             *   is illogical if we're a component of the direct object.
<a name="4606"></a>             */
<a name="4607"></a>            if (gDobj == self || isComponentOf(gDobj))
<a name="4608"></a>                illogicalSelf(&amp;cannotPutInSelfMsg);
<a name="4609"></a>
<a name="4610"></a>            /* if it's already directly inside me, this is illogical */
<a name="4611"></a>            if (gDobj.isDirectlyIn(self))
<a name="4612"></a>                illogicalAlready(&amp;alreadyPutInMsg);
<a name="4613"></a>        }
<a name="4614"></a>
<a name="4615"></a>        /*
<a name="4616"></a>         *   if I'm not held by the actor, give myself a slightly lower
<a name="4617"></a>         *   ranking than fully logical, so that objects being held are
<a name="4618"></a>         *   preferred
<a name="4619"></a>         */
<a name="4620"></a>        if (!isIn(gActor))
<a name="4621"></a>            logicalRank(60, 'not indirectly held');
<a name="4622"></a>        else if (!isHeldBy(gActor))
<a name="4623"></a>            logicalRank(70, 'not held');
<a name="4624"></a>    }
<a name="4625"></a>
<a name="4626"></a>    /*
<a name="4627"></a>     *   Flag: reveal any hidden items contained directly within me when
<a name="4628"></a>     *   my interior is explicitly examined, via a command such as LOOK IN
<a name="4629"></a>     *   &lt;self&gt;.  By default, we reveal our hidden contents on
<a name="4630"></a>     *   examination; hidden objects are in most cases meant to be more
<a name="4631"></a>     *   inconspicuous than actually camouflaged, so a careful, explicit
<a name="4632"></a>     *   examination would normally reveal them.  If our hidden objects
<a name="4633"></a>     *   are so concealed that even explicit examination of our interior
<a name="4634"></a>     *   wouldn't reveal them, set this to nil.
<a name="4635"></a>     */
<a name="4636"></a>    revealHiddenItems = true
<a name="4637"></a>;
<a name="4638"></a>
<a name="4639"></a>
<a name="4640"></a>/* ------------------------------------------------------------------------ */
<a name="4641"></a>/*
<a name="4642"></a> *   A basic container is an object that can enclose its contents.  This is
<a name="4643"></a> *   the core of the Container type, but this class only has the bare-bones
<a name="4644"></a> *   sense-related enclosing features, without any action implementation.
<a name="4645"></a> *   This can be used for cases where an object isn't meant to have its
<a name="4646"></a> *   contents be manipulable by the player (so we don't want to allow "put
<a name="4647"></a> *   in" and so on), but where we do want the ability to conceal our
<a name="4648"></a> *   contents when we're closed.
<a name="4649"></a> */
<a name="4650"></a>class BasicContainer: BulkLimiter
<a name="4651"></a>    /*
<a name="4652"></a>     *   My current open/closed state.  By default, this state never
<a name="4653"></a>     *   changes, but is fixed in the object's definition; for example, a
<a name="4654"></a>     *   box without a lid would always be open, while a hollow glass cube
<a name="4655"></a>     *   would always be closed.  Our default state is open.
<a name="4656"></a>     */
<a name="4657"></a>    isOpen = true
<a name="4658"></a>
<a name="4659"></a>    /* the material that we're made of */
<a name="4660"></a>    material = adventium
<a name="4661"></a>
<a name="4662"></a>    /* prepositional phrase for objects being put into me */
<a name="4663"></a>    putDestMessage = &amp;putDestContainer
<a name="4664"></a>
<a name="4665"></a>    /*
<a name="4666"></a>     *   Determine if I can move an object via a path through this
<a name="4667"></a>     *   container.
<a name="4668"></a>     */
<a name="4669"></a>    checkMoveViaPath(obj, dest, op)
<a name="4670"></a>    {
<a name="4671"></a>        /*
<a name="4672"></a>         *   if we're moving the object in or out of me, we must consider
<a name="4673"></a>         *   our openness and whether or not the object fits through our
<a name="4674"></a>         *   opening
<a name="4675"></a>         */
<a name="4676"></a>        if (op is in (PathIn, PathOut))
<a name="4677"></a>        {
<a name="4678"></a>            /* if we're closed, we can't move anything in or out */
<a name="4679"></a>            if (!isOpen)
<a name="4680"></a>                return new CheckStatusFailure(cannotMoveThroughMsg,
<a name="4681"></a>                                              obj, self);
<a name="4682"></a>
<a name="4683"></a>            /* if it doesn't fit through our opening, don't allow it */
<a name="4684"></a>            if (!canFitObjThruOpening(obj))
<a name="4685"></a>                return new CheckStatusFailure(op == PathIn
<a name="4686"></a>                                              ? &amp;cannotFitIntoOpeningMsg
<a name="4687"></a>                                              : &amp;cannotFitOutOfOpeningMsg,
<a name="4688"></a>                                              obj, self);
<a name="4689"></a>        }
<a name="4690"></a>
<a name="4691"></a>        /* in any other cases, allow the operation */
<a name="4692"></a>        return checkStatusSuccess;
<a name="4693"></a>    }
<a name="4694"></a>
<a name="4695"></a>    /*
<a name="4696"></a>     *   The message property we use when we can't move an object through
<a name="4697"></a>     *   the containment boundary.  This is a playerActionMessages
<a name="4698"></a>     *   property.
<a name="4699"></a>     */
<a name="4700"></a>    cannotMoveThroughMsg = &amp;cannotMoveThroughContainerMsg
<a name="4701"></a>
<a name="4702"></a>    /*
<a name="4703"></a>     *   Determine if an actor can touch an object via a path through this
<a name="4704"></a>     *   container.
<a name="4705"></a>     */
<a name="4706"></a>    checkTouchViaPath(obj, dest, op)
<a name="4707"></a>    {
<a name="4708"></a>        /*
<a name="4709"></a>         *   if we're reaching from inside directly to me, allow it -
<a name="4710"></a>         *   treat this as touching our interior, which we allow from
<a name="4711"></a>         *   within regardless of our open/closed status
<a name="4712"></a>         */
<a name="4713"></a>        if (op == PathOut &amp;&amp; dest == self)
<a name="4714"></a>            return checkStatusSuccess;
<a name="4715"></a>
<a name="4716"></a>        /*
<a name="4717"></a>         *   if we're reaching in or out of me, consider our openness and
<a name="4718"></a>         *   whether or not the actor's hand fits through our opening
<a name="4719"></a>         */
<a name="4720"></a>        if (op is in (PathIn, PathOut))
<a name="4721"></a>        {
<a name="4722"></a>            /* if we're closed, we can't reach into/out of the container */
<a name="4723"></a>            if (!isOpen)
<a name="4724"></a>                return new CheckStatusFailure(cannotTouchThroughMsg,
<a name="4725"></a>                                              obj, self);
<a name="4726"></a>
<a name="4727"></a>            /*
<a name="4728"></a>             *   if the object's "hand" doesn't fit through our opening,
<a name="4729"></a>             *   don't allow it
<a name="4730"></a>             */
<a name="4731"></a>            if (!canObjReachThruOpening(obj))
<a name="4732"></a>                return new CheckStatusFailure(op == PathIn
<a name="4733"></a>                                              ? &amp;cannotReachIntoOpeningMsg
<a name="4734"></a>                                              : &amp;cannotReachOutOfOpeningMsg,
<a name="4735"></a>                                              obj, self);
<a name="4736"></a>        }
<a name="4737"></a>
<a name="4738"></a>        /* in any other cases, allow the operation */
<a name="4739"></a>        return checkStatusSuccess;
<a name="4740"></a>    }
<a name="4741"></a>
<a name="4742"></a>    /*
<a name="4743"></a>     *   Library message (in playerActionMessages) explaining why we can't
<a name="4744"></a>     *   touch an object through this container.  This is used when an
<a name="4745"></a>     *   actor on the outside tries to reach something on the inside, or
<a name="4746"></a>     *   vice versa.
<a name="4747"></a>     */
<a name="4748"></a>    cannotTouchThroughMsg = &amp;cannotTouchThroughContainerMsg
<a name="4749"></a>
<a name="4750"></a>    /*
<a name="4751"></a>     *   Determine if the given object fits through our opening.  This is
<a name="4752"></a>     *   only called when we're open; this determines if the object can be
<a name="4753"></a>     *   moved in or out of this container.  By default, we'll return
<a name="4754"></a>     *   true; some objects might want to override this to disallow
<a name="4755"></a>     *   objects over a certain size from being moved in or out of this
<a name="4756"></a>     *   container.
<a name="4757"></a>     *
<a name="4758"></a>     *   Note that this method doesn't care whether or not the object can
<a name="4759"></a>     *   actually fit inside the container once through the opening; we
<a name="4760"></a>     *   only care about whether or not the object can fit through the
<a name="4761"></a>     *   opening itself.  This allows for things like narrow-mouthed
<a name="4762"></a>     *   bottles which have greater capacity within than in their
<a name="4763"></a>     *   openings.
<a name="4764"></a>     */
<a name="4765"></a>    canFitObjThruOpening(obj) { return true; }
<a name="4766"></a>
<a name="4767"></a>    /*
<a name="4768"></a>     *   Determine if the given object can "reach" through our opening,
<a name="4769"></a>     *   for the purposes of touching an object on the other side of the
<a name="4770"></a>     *   opening.  This is used to determine if the object, which is
<a name="4771"></a>     *   usually an actor, can its "hand" (or whatever appendange 'obj'
<a name="4772"></a>     *   uses to reach things) through our opening.  This is only called
<a name="4773"></a>     *   when we're open.  By default, we'll simply return true.
<a name="4774"></a>     *
<a name="4775"></a>     *   This differs from canFitObjThruOpening() in that we don't care if
<a name="4776"></a>     *   all of 'obj' is able to fit through the opening; we only care
<a name="4777"></a>     *   whether obj's hand (or whatever it uses for reaching) can fit.
<a name="4778"></a>     */
<a name="4779"></a>    canObjReachThruOpening(obj) { return true; }
<a name="4780"></a>
<a name="4781"></a>    /*
<a name="4782"></a>     *   Determine how a sense passes to my contents.  If I'm open, the
<a name="4783"></a>     *   sense passes through directly, since there's nothing in the way.
<a name="4784"></a>     *   If I'm closed, the sense must pass through my material.
<a name="4785"></a>     */
<a name="4786"></a>    transSensingIn(sense)
<a name="4787"></a>    {
<a name="4788"></a>        if (isOpen)
<a name="4789"></a>        {
<a name="4790"></a>            /* I'm open, so the sense passes through without interference */
<a name="4791"></a>            return transparent;
<a name="4792"></a>        }
<a name="4793"></a>        else
<a name="4794"></a>        {
<a name="4795"></a>            /* I'm closed, so the sense must pass through my material */
<a name="4796"></a>            return material.senseThru(sense);
<a name="4797"></a>        }
<a name="4798"></a>    }
<a name="4799"></a>
<a name="4800"></a>    /*
<a name="4801"></a>     *   Get my fill medium.  If I'm open, inherit my parent's medium,
<a name="4802"></a>     *   assuming that the medium behaves like fog or smoke and naturally
<a name="4803"></a>     *   disperses to fill any nested open containers.  If I'm closed, I
<a name="4804"></a>     *   am by default filled with no medium.
<a name="4805"></a>     */
<a name="4806"></a>    fillMedium()
<a name="4807"></a>    {
<a name="4808"></a>        if (isOpen &amp;&amp; location != nil)
<a name="4809"></a>        {
<a name="4810"></a>            /* I'm open, so return my location's medium */
<a name="4811"></a>            return location.fillMedium();
<a name="4812"></a>        }
<a name="4813"></a>        else
<a name="4814"></a>        {
<a name="4815"></a>            /*
<a name="4816"></a>             *   I'm closed, so we're cut off from the parent - assume
<a name="4817"></a>             *   we're filled with nothing
<a name="4818"></a>             */
<a name="4819"></a>            return nil;
<a name="4820"></a>        }
<a name="4821"></a>    }
<a name="4822"></a>
<a name="4823"></a>    /*
<a name="4824"></a>     *   Display a message explaining why we are obstructing a sense path
<a name="4825"></a>     *   to the given object.
<a name="4826"></a>     */
<a name="4827"></a>    cannotReachObject(obj)
<a name="4828"></a>    {
<a name="4829"></a>        /*
<a name="4830"></a>         *   We must be obstructing by containment.  Show an appropriate
<a name="4831"></a>         *   message depending on whether the object is inside me or not -
<a name="4832"></a>         *   if not, then the actor trying to reach the object must be
<a name="4833"></a>         *   inside me.
<a name="4834"></a>         */
<a name="4835"></a>        if (obj.isIn(self))
<a name="4836"></a>            gLibMessages.cannotReachContents(obj, self);
<a name="4837"></a>        else
<a name="4838"></a>            gLibMessages.cannotReachOutside(obj, self);
<a name="4839"></a>    }
<a name="4840"></a>
<a name="4841"></a>    /* explain why we can't see the source of a sound */
<a name="4842"></a>    cannotSeeSoundSource(obj)
<a name="4843"></a>    {
<a name="4844"></a>        /* we must be obstructing by containment */
<a name="4845"></a>        if (obj.isIn(self))
<a name="4846"></a>            gLibMessages.soundIsFromWithin(obj, self);
<a name="4847"></a>        else
<a name="4848"></a>            gLibMessages.soundIsFromWithout(obj, self);
<a name="4849"></a>    }
<a name="4850"></a>
<a name="4851"></a>    /* explain why we can't see the source of an odor */
<a name="4852"></a>    cannotSeeSmellSource(obj)
<a name="4853"></a>    {
<a name="4854"></a>        /* we must be obstructing by containment */
<a name="4855"></a>        if (obj.isIn(self))
<a name="4856"></a>            gLibMessages.smellIsFromWithin(obj, self);
<a name="4857"></a>        else
<a name="4858"></a>            gLibMessages.smellIsFromWithout(obj, self);
<a name="4859"></a>    }
<a name="4860"></a>
<a name="4861"></a>    /* message when an object is too large (all by itself) to fit in me */
<a name="4862"></a>    tooLargeForContainerMsg = &amp;tooLargeForContainerMsg
<a name="4863"></a>;
<a name="4864"></a>
<a name="4865"></a>/* ------------------------------------------------------------------------ */
<a name="4866"></a>/*
<a name="4867"></a> *   Container: an object that can have other objects placed within it.
<a name="4868"></a> */
<a name="4869"></a>class Container: BasicContainer
<a name="4870"></a>    /*
<a name="4871"></a>     *   Our fixed "look in" description, if any.  This is shown on LOOK
<a name="4872"></a>     *   IN before our normal listing of our portable contents; it can be
<a name="4873"></a>     *   used to describe generally what the interior looks like, for
<a name="4874"></a>     *   example.  By default, we show nothing here.
<a name="4875"></a>     */
<a name="4876"></a>    lookInDesc = nil
<a name="4877"></a>
<a name="4878"></a>    /*
<a name="4879"></a>     *   Show our status for "examine".  This shows our open/closed status,
<a name="4880"></a>     *   and lists our contents.
<a name="4881"></a>     */
<a name="4882"></a>    examineStatus()
<a name="4883"></a>    {
<a name="4884"></a>        /* show any special container-specific status */
<a name="4885"></a>        examineContainerStatus();
<a name="4886"></a>
<a name="4887"></a>        /* inherit the default handling to show my contents */
<a name="4888"></a>        inherited();
<a name="4889"></a>    }
<a name="4890"></a>
<a name="4891"></a>    /*
<a name="4892"></a>     *   mention my open/closed status for Examine processing
<a name="4893"></a>     */
<a name="4894"></a>    examineContainerStatus()
<a name="4895"></a>    {
<a name="4896"></a>        /*
<a name="4897"></a>         *   By default, show nothing extra.  This can be overridden by
<a name="4898"></a>         *   subclasses as needed to show any extra status before our
<a name="4899"></a>         *   contents list.
<a name="4900"></a>         */
<a name="4901"></a>    }
<a name="4902"></a>
<a name="4903"></a>    /*
<a name="4904"></a>     *   Try putting an object into me when I'm serving as a bag of
<a name="4905"></a>     *   holding.  For a container, this simply does a "put obj in bag".
<a name="4906"></a>     */
<a name="4907"></a>    tryPuttingObjInBag(target)
<a name="4908"></a>    {
<a name="4909"></a>        /* if the object won't fit all by itself, don't even try */
<a name="4910"></a>        if (target.getBulk() &gt; maxSingleBulk)
<a name="4911"></a>            return nil;
<a name="4912"></a>
<a name="4913"></a>        /* if we can't fit the object with other contents, don't try */
<a name="4914"></a>        if (target.whatIf({: getBulkWithin() &gt; bulkCapacity},
<a name="4915"></a>                          &amp;moveInto, self))
<a name="4916"></a>            return nil;
<a name="4917"></a>
<a name="4918"></a>        /* we're a container, so use "put in" to get the object */
<a name="4919"></a>        return tryImplicitActionMsg(&amp;announceMoveToBag, PutIn, target, self);
<a name="4920"></a>    }
<a name="4921"></a>
<a name="4922"></a>    /*
<a name="4923"></a>     *   Try moving an object into this container.  For a container, this
<a name="4924"></a>     *   performs a PUT IN command to move the object into self.
<a name="4925"></a>     */
<a name="4926"></a>    tryMovingObjInto(obj) { return tryImplicitAction(PutIn, obj, self); }
<a name="4927"></a>
<a name="4928"></a>    /* -------------------------------------------------------------------- */
<a name="4929"></a>    /*
<a name="4930"></a>     *   "Look in"
<a name="4931"></a>     */
<a name="4932"></a>    dobjFor(LookIn)
<a name="4933"></a>    {
<a name="4934"></a>        verify() { }
<a name="4935"></a>        check()
<a name="4936"></a>        {
<a name="4937"></a>            /*
<a name="4938"></a>             *   If I'm closed, and I can't see my contents when closed, we
<a name="4939"></a>             *   can't go on.  Unless, of course, the actor is inside us,
<a name="4940"></a>             *   in which case our external boundary isn't relevant.
<a name="4941"></a>             */
<a name="4942"></a>            if (!isOpen
<a name="4943"></a>                &amp;&amp; transSensingIn(sight) == opaque
<a name="4944"></a>                &amp;&amp; !gActor.isIn(self))
<a name="4945"></a>            {
<a name="4946"></a>                /* we can't see anything because we're closed */
<a name="4947"></a>                reportFailure(&amp;cannotLookInClosedMsg);
<a name="4948"></a>                exit;
<a name="4949"></a>            }
<a name="4950"></a>        }
<a name="4951"></a>        action()
<a name="4952"></a>        {
<a name="4953"></a>            /* show our fixed "look in" description, if any */
<a name="4954"></a>            lookInDesc;
<a name="4955"></a>
<a name="4956"></a>            /* examine my interior */
<a name="4957"></a>            examineInterior();
<a name="4958"></a>        }
<a name="4959"></a>    }
<a name="4960"></a>
<a name="4961"></a>    /*
<a name="4962"></a>     *   "Search".  This is mostly like Open, except that the actor has to
<a name="4963"></a>     *   be able to reach into the object, not just see into it - searching
<a name="4964"></a>     *   implies a more thorough sort of examination, usually including
<a name="4965"></a>     *   physically poking through the object's contents.
<a name="4966"></a>     */
<a name="4967"></a>    dobjFor(Search)
<a name="4968"></a>    {
<a name="4969"></a>        preCond = (nilToList(inherited()) + [touchObj])
<a name="4970"></a>        check()
<a name="4971"></a>        {
<a name="4972"></a>            /*
<a name="4973"></a>             *   if I'm closed, and the actor isn't inside me, make sure my
<a name="4974"></a>             *   contents are reachable from the outside
<a name="4975"></a>             */
<a name="4976"></a>            if (!isOpen
<a name="4977"></a>                &amp;&amp; transSensingIn(touch) != transparent
<a name="4978"></a>                &amp;&amp; !gActor.isIn(self))
<a name="4979"></a>            {
<a name="4980"></a>                /* we can't search an object that we can't reach into */
<a name="4981"></a>                reportFailure(&amp;cannotTouchThroughMsg, gActor, self);
<a name="4982"></a>                exit;
<a name="4983"></a>            }
<a name="4984"></a>        }
<a name="4985"></a>    }
<a name="4986"></a>
<a name="4987"></a>
<a name="4988"></a>    /* -------------------------------------------------------------------- */
<a name="4989"></a>    /*
<a name="4990"></a>     *   Put In processing.  A container can accept new contents.
<a name="4991"></a>     */
<a name="4992"></a>
<a name="4993"></a>    iobjFor(PutIn)
<a name="4994"></a>    {
<a name="4995"></a>        verify()
<a name="4996"></a>        {
<a name="4997"></a>            /* use the standard verification for adding new contents */
<a name="4998"></a>            verifyPutInInterior();
<a name="4999"></a>        }
<a name="5000"></a>
<a name="5001"></a>        action()
<a name="5002"></a>        {
<a name="5003"></a>            /* move the direct object into me */
<a name="5004"></a>            gDobj.moveInto(self);
<a name="5005"></a>
<a name="5006"></a>            /* issue our default acknowledgment of the command */
<a name="5007"></a>            defaultReport(&amp;okayPutInMsg);
<a name="5008"></a>        }
<a name="5009"></a>    }
<a name="5010"></a>;
<a name="5011"></a>
<a name="5012"></a>
<a name="5013"></a>/*
<a name="5014"></a> *   A "restricted holder" is a generic mix-in class for various container
<a name="5015"></a> *   types (Containers, Surfaces, Undersides, RearContainers, RearSurfaces)
<a name="5016"></a> *   that adds a restriction to what can be contained.
<a name="5017"></a> */
<a name="5018"></a>class RestrictedHolder: object
<a name="5019"></a>    /*
<a name="5020"></a>     *   A list of acceptable items for the container.  This list can be
<a name="5021"></a>     *   used to identify the objects that can be put in the container (or
<a name="5022"></a>     *   on the surface, under the underside, or behind the rear container
<a name="5023"></a>     *   or surface).
<a name="5024"></a>     */
<a name="5025"></a>    validContents = []
<a name="5026"></a>
<a name="5027"></a>    /*
<a name="5028"></a>     *   Is the given object allowed to go in this container (or
<a name="5029"></a>     *   on/under/behind it, as appropriate for the type)?  Returns true if
<a name="5030"></a>     *   so, nil if not.  By default, we'll return true if the object is
<a name="5031"></a>     *   found in our validContents list, nil if not.  This can be
<a name="5032"></a>     *   overridden if a subclass wants to determine which objects are
<a name="5033"></a>     *   acceptable with some other kind of per-object test; for example, a
<a name="5034"></a>     *   subclass might accept only objects of a given class as contents,
<a name="5035"></a>     *   or might accept only contents with some particular attribute.
<a name="5036"></a>     */
<a name="5037"></a>    canPutIn(obj) { return validContents.indexOf(obj) != nil; }
<a name="5038"></a>
<a name="5039"></a>    /*
<a name="5040"></a>     *   Check a PUT IN/ON/UNDER/BEHIND action to ensure that the direct
<a name="5041"></a>     *   object is in our approved-contents list.
<a name="5042"></a>     */
<a name="5043"></a>    checkPutDobj(msgProp)
<a name="5044"></a>    {
<a name="5045"></a>        /* validate the direct object */
<a name="5046"></a>        if (!canPutIn(gDobj))
<a name="5047"></a>        {
<a name="5048"></a>            /* explain the problem */
<a name="5049"></a>            reportFailure(self.(msgProp)(gDobj));
<a name="5050"></a>
<a name="5051"></a>            /* terminate the command */
<a name="5052"></a>            exit;
<a name="5053"></a>        }
<a name="5054"></a>    }
<a name="5055"></a>;
<a name="5056"></a>
<a name="5057"></a>
<a name="5058"></a>/*
<a name="5059"></a> *   A special kind of container that only accepts specific contents.  The
<a name="5060"></a> *   acceptable contents can be specified by a list of enumerated items,
<a name="5061"></a> *   or by a method that indicates whether or not an item is allowed.
<a name="5062"></a> */
<a name="5063"></a>class RestrictedContainer: RestrictedHolder, Container
<a name="5064"></a>    /*
<a name="5065"></a>     *   A message that explains why the direct object can't be put in this
<a name="5066"></a>     *   container.  In most cases, the rather generic default message
<a name="5067"></a>     *   should be overridden to provide a specific reason that the dobj
<a name="5068"></a>     *   can't be put in this object.  The rejected object is provided as a
<a name="5069"></a>     *   parameter in case the message needs to vary by object, but we
<a name="5070"></a>     *   ignore this and just use a single blanket failure message by
<a name="5071"></a>     *   default.
<a name="5072"></a>     */
<a name="5073"></a>    cannotPutInMsg(obj) { return &amp;cannotPutInRestrictedMsg; }
<a name="5074"></a>
<a name="5075"></a>    /* override PutIn to enforce our contents restriction */
<a name="5076"></a>    iobjFor(PutIn) { check() { checkPutDobj(&amp;cannotPutInMsg); } }
<a name="5077"></a>;
<a name="5078"></a>
<a name="5079"></a>/*
<a name="5080"></a> *   A single container is a special kind of container that can only
<a name="5081"></a> *   contain a single item.  If another object is put into this container,
<a name="5082"></a> *   we'll remove any current contents.
<a name="5083"></a> */
<a name="5084"></a>class SingleContainer: Container
<a name="5085"></a>    /* override PutIn to enforce our single-contents rule */
<a name="5086"></a>    iobjFor(PutIn)
<a name="5087"></a>    {
<a name="5088"></a>        preCond { return inherited() + objEmpty; }
<a name="5089"></a>    }
<a name="5090"></a>;
<a name="5091"></a>
<a name="5092"></a>/* ------------------------------------------------------------------------ */
<a name="5093"></a>/*
<a name="5094"></a> *   OpenableContainer: an object that can contain things, and which can
<a name="5095"></a> *   be opened and closed.
<a name="5096"></a> */
<a name="5097"></a>class OpenableContainer: Openable, Container
<a name="5098"></a>;
<a name="5099"></a>
<a name="5100"></a>/* ------------------------------------------------------------------------ */
<a name="5101"></a>/*
<a name="5102"></a> *   LockableContainer: an object that can contain things, and that can be
<a name="5103"></a> *   opened and closed as well as locked and unlocked.
<a name="5104"></a> */
<a name="5105"></a>class LockableContainer: Lockable, OpenableContainer
<a name="5106"></a>;
<a name="5107"></a>
<a name="5108"></a>/* ------------------------------------------------------------------------ */
<a name="5109"></a>/*
<a name="5110"></a> *   KeyedContainer: an openable container that can be locked and
<a name="5111"></a> *   unlocked, but only with a specified key.
<a name="5112"></a> */
<a name="5113"></a>class KeyedContainer: LockableWithKey, OpenableContainer
<a name="5114"></a>;
<a name="5115"></a>
<a name="5116"></a>
<a name="5117"></a>/* ------------------------------------------------------------------------ */
<a name="5118"></a>/*
<a name="5119"></a> *   Surface: an object that can have other objects placed on top of it.
<a name="5120"></a> *   A surface is essentially the same as a regular container, but the
<a name="5121"></a> *   contents of a surface behave as though they are on the surface's top
<a name="5122"></a> *   rather than contained within the object.
<a name="5123"></a> */
<a name="5124"></a>class Surface: BulkLimiter
<a name="5125"></a>    /*
<a name="5126"></a>     *   Our fixed LOOK IN description.  This is shown in response to LOOK
<a name="5127"></a>     *   IN before we list our portable contents; it can be used to show
<a name="5128"></a>     *   generally what the surface looks like.  By default, we say
<a name="5129"></a>     *   nothing here.
<a name="5130"></a>     */
<a name="5131"></a>    lookInDesc = nil
<a name="5132"></a>
<a name="5133"></a>    /* my contents lister */
<a name="5134"></a>    contentsLister = surfaceContentsLister
<a name="5135"></a>    descContentsLister = surfaceDescContentsLister
<a name="5136"></a>    lookInLister = surfaceLookInLister
<a name="5137"></a>    inlineContentsLister = surfaceInlineContentsLister
<a name="5138"></a>
<a name="5139"></a>    /*
<a name="5140"></a>     *   we're a surface, so taking something from me that's not among my
<a name="5141"></a>     *   contents shows the message as "that's not on the iobj"
<a name="5142"></a>     */
<a name="5143"></a>    takeFromNotInMessage = &amp;takeFromNotOnMsg
<a name="5144"></a>
<a name="5145"></a>    /*
<a name="5146"></a>     *   my message indicating that another object x cannot be put into me
<a name="5147"></a>     *   because I'm already in x
<a name="5148"></a>     */
<a name="5149"></a>    circularlyInMessage = &amp;circularlyOnMsg
<a name="5150"></a>
<a name="5151"></a>    /* message phrase for objects put into me */
<a name="5152"></a>    putDestMessage = &amp;putDestSurface
<a name="5153"></a>
<a name="5154"></a>    /* message when we're too full for another object */
<a name="5155"></a>    tooFullMsg = &amp;surfaceTooFullMsg
<a name="5156"></a>
<a name="5157"></a>    /*
<a name="5158"></a>     *   Try moving an object into this container.  For a surface, this
<a name="5159"></a>     *   performs a PUT ON command to move the object onto self.
<a name="5160"></a>     */
<a name="5161"></a>    tryMovingObjInto(obj) { return tryImplicitAction(PutOn, obj, self); }
<a name="5162"></a>
<a name="5163"></a>    /* -------------------------------------------------------------------- */
<a name="5164"></a>    /*
<a name="5165"></a>     *   Put On processing
<a name="5166"></a>     */
<a name="5167"></a>    iobjFor(PutOn)
<a name="5168"></a>    {
<a name="5169"></a>        verify()
<a name="5170"></a>        {
<a name="5171"></a>            /* use the standard put-in verification */
<a name="5172"></a>            verifyPutInInterior();
<a name="5173"></a>        }
<a name="5174"></a>
<a name="5175"></a>        action()
<a name="5176"></a>        {
<a name="5177"></a>            /* move the direct object onto me */
<a name="5178"></a>            gDobj.moveInto(self);
<a name="5179"></a>
<a name="5180"></a>            /* issue our default acknowledgment */
<a name="5181"></a>            defaultReport(&amp;okayPutOnMsg);
<a name="5182"></a>        }
<a name="5183"></a>    }
<a name="5184"></a>
<a name="5185"></a>    /*
<a name="5186"></a>     *   Looking "in" a surface simply shows the surface's contents.
<a name="5187"></a>     */
<a name="5188"></a>    dobjFor(LookIn)
<a name="5189"></a>    {
<a name="5190"></a>        verify() { }
<a name="5191"></a>        action()
<a name="5192"></a>        {
<a name="5193"></a>            /* show our fixed lookInDesc */
<a name="5194"></a>            lookInDesc;
<a name="5195"></a>
<a name="5196"></a>            /* show our contents */
<a name="5197"></a>            examineInterior();
<a name="5198"></a>        }
<a name="5199"></a>    }
<a name="5200"></a>
<a name="5201"></a>    /* use the PUT ON forms of the verifier messages */
<a name="5202"></a>    cannotPutInSelfMsg = &amp;cannotPutOnSelfMsg
<a name="5203"></a>    alreadyPutInMsg = &amp;alreadyPutOnMsg
<a name="5204"></a>;
<a name="5205"></a>
<a name="5206"></a>/*
<a name="5207"></a> *   A special kind of surface that only accepts specific contents.
<a name="5208"></a> */
<a name="5209"></a>class RestrictedSurface: RestrictedHolder, Surface
<a name="5210"></a>    /*
<a name="5211"></a>     *   A message that explains why the direct object can't be put on this
<a name="5212"></a>     *   surface.  In most cases, the rather generic default message should
<a name="5213"></a>     *   be overridden to provide a specific reason that the dobj can't be
<a name="5214"></a>     *   put on this surface.  The rejected object is provided as a
<a name="5215"></a>     *   parameter in case the message needs to vary by object, but we
<a name="5216"></a>     *   ignore this and just use a single blanket failure message by
<a name="5217"></a>     *   default.
<a name="5218"></a>     */
<a name="5219"></a>    cannotPutOnMsg(obj) { return &amp;cannotPutOnRestrictedMsg; }
<a name="5220"></a>
<a name="5221"></a>    /* override PutOn to enforce our contents restriction */
<a name="5222"></a>    iobjFor(PutOn) { check() { checkPutDobj(&amp;cannotPutOnMsg); } }
<a name="5223"></a>;
<a name="5224"></a>
<a name="5225"></a>/* ------------------------------------------------------------------------ */
<a name="5226"></a>/*
<a name="5227"></a> *   Food - something you can eat.  By default, when an actor eats a food
<a name="5228"></a> *   item, the item disappears.
<a name="5229"></a> */
<a name="5230"></a>class Food: Thing
<a name="5231"></a>    dobjFor(Taste)
<a name="5232"></a>    {
<a name="5233"></a>        /* tasting food is perfectly logical */
<a name="5234"></a>        verify() { }
<a name="5235"></a>    }
<a name="5236"></a>
<a name="5237"></a>    dobjFor(Eat)
<a name="5238"></a>    {
<a name="5239"></a>        verify() { }
<a name="5240"></a>        action()
<a name="5241"></a>        {
<a name="5242"></a>            /* describe the consumption */
<a name="5243"></a>            defaultReport(&amp;okayEatMsg);
<a name="5244"></a>
<a name="5245"></a>            /* the object disappears */
<a name="5246"></a>            moveInto(nil);
<a name="5247"></a>        }
<a name="5248"></a>    }
<a name="5249"></a>;
<a name="5250"></a>
<a name="5251"></a>/* ------------------------------------------------------------------------ */
<a name="5252"></a>/*
<a name="5253"></a> *   OnOffControl - a generic control that can be turned on and off.  We
<a name="5254"></a> *   keep track of an internal on/off state, and recognize the commands
<a name="5255"></a> *   "turn on" and "turn off".
<a name="5256"></a> */
<a name="5257"></a>class OnOffControl: Thing
<a name="5258"></a>    /*
<a name="5259"></a>     *   The current on/off setting.  We'll start in the 'off' position by
<a name="5260"></a>     *   default.
<a name="5261"></a>     */
<a name="5262"></a>    isOn = nil
<a name="5263"></a>
<a name="5264"></a>    /*
<a name="5265"></a>     *   On/off status name.  This returns the appropriate name ('on' or
<a name="5266"></a>     *   'off' in English) for our current status.
<a name="5267"></a>     */
<a name="5268"></a>    onDesc = (isOn ? gLibMessages.onMsg(self) : gLibMessages.offMsg(self))
<a name="5269"></a>
<a name="5270"></a>    /*
<a name="5271"></a>     *   Change our on/off setting.  Subclasses can override this to apply
<a name="5272"></a>     *   any side effects of changing the value.
<a name="5273"></a>     */
<a name="5274"></a>    makeOn(val)
<a name="5275"></a>    {
<a name="5276"></a>        /* remember the new value */
<a name="5277"></a>        isOn = val;
<a name="5278"></a>    }
<a name="5279"></a>
<a name="5280"></a>    dobjFor(TurnOn)
<a name="5281"></a>    {
<a name="5282"></a>        verify()
<a name="5283"></a>        {
<a name="5284"></a>            /* if it's already on, complain */
<a name="5285"></a>            if (isOn)
<a name="5286"></a>                illogicalAlready(&amp;alreadySwitchedOnMsg);
<a name="5287"></a>        }
<a name="5288"></a>        action()
<a name="5289"></a>        {
<a name="5290"></a>            /* set to 'on' and generate a default report */
<a name="5291"></a>            makeOn(true);
<a name="5292"></a>            defaultReport(&amp;okayTurnOnMsg);
<a name="5293"></a>        }
<a name="5294"></a>    }
<a name="5295"></a>
<a name="5296"></a>    dobjFor(TurnOff)
<a name="5297"></a>    {
<a name="5298"></a>        verify()
<a name="5299"></a>        {
<a name="5300"></a>            /* if it's already off, complain */
<a name="5301"></a>            if (!isOn)
<a name="5302"></a>                illogicalAlready(&amp;alreadySwitchedOffMsg);
<a name="5303"></a>        }
<a name="5304"></a>        action()
<a name="5305"></a>        {
<a name="5306"></a>            /* set to 'off' and generate a default report */
<a name="5307"></a>            makeOn(nil);
<a name="5308"></a>            defaultReport(&amp;okayTurnOffMsg);
<a name="5309"></a>        }
<a name="5310"></a>    }
<a name="5311"></a>;
<a name="5312"></a>
<a name="5313"></a>/*
<a name="5314"></a> *   Switch - a simple extension of the generic on/off control that can be
<a name="5315"></a> *   used with a "switch" command without specifying "on" or "off", and
<a name="5316"></a> *   treats "flip" synonymously.
<a name="5317"></a> */
<a name="5318"></a>class Switch: OnOffControl
<a name="5319"></a>    /* "switch" with no specific new setting - reverse our setting */
<a name="5320"></a>    dobjFor(Switch)
<a name="5321"></a>    {
<a name="5322"></a>        verify() { }
<a name="5323"></a>        action()
<a name="5324"></a>        {
<a name="5325"></a>            /* reverse our setting and generate a report */
<a name="5326"></a>            makeOn(!isOn);
<a name="5327"></a>            defaultReport(isOn ? &amp;okayTurnOnMsg : &amp;okayTurnOffMsg);
<a name="5328"></a>        }
<a name="5329"></a>    }
<a name="5330"></a>
<a name="5331"></a>    /* "flip" is the same as "switch" for our purposes */
<a name="5332"></a>    dobjFor(Flip) asDobjFor(Switch)
<a name="5333"></a>;
<a name="5334"></a>
<a name="5335"></a>/* ------------------------------------------------------------------------ */
<a name="5336"></a>/*
<a name="5337"></a> *   Settable - an abstract class for things you can set to different
<a name="5338"></a> *   settings; the settings can be essentially anything, such as numbers
<a name="5339"></a> *   (or other markers) on a dial, or stops on a sliding switch.
<a name="5340"></a> */
<a name="5341"></a>class Settable: Thing
<a name="5342"></a>    /*
<a name="5343"></a>     *   Our current setting.  This is an arbitrary string value.  The
<a name="5344"></a>     *   value initially assigned here is our initial setting; we'll
<a name="5345"></a>     *   update this whenever we're set to another setting.
<a name="5346"></a>     */
<a name="5347"></a>    curSetting = '1'
<a name="5348"></a>
<a name="5349"></a>    /*
<a name="5350"></a>     *   Canonicalize a proposed setting.  This ensures that the setting is
<a name="5351"></a>     *   in a specific primary format when there are superficially
<a name="5352"></a>     *   different ways of expressing the same value.  For example, if the
<a name="5353"></a>     *   setting is numeric, this could do things like trim off leading
<a name="5354"></a>     *   zeros; for a text value, it could ensure the value is in the
<a name="5355"></a>     *   proper case.
<a name="5356"></a>     */
<a name="5357"></a>    canonicalizeSetting(val)
<a name="5358"></a>    {
<a name="5359"></a>        /*
<a name="5360"></a>         *   by default, we don't have any special canonical format, so
<a name="5361"></a>         *   just return the value as it is
<a name="5362"></a>         */
<a name="5363"></a>        return val;
<a name="5364"></a>    }
<a name="5365"></a>
<a name="5366"></a>    /*
<a name="5367"></a>     *   Change our setting.  This is always called with the canonical
<a name="5368"></a>     *   version of the new setting, as returned by canonicalizeSetting().
<a name="5369"></a>     *   Subclasses can override this routine to apply any side effects of
<a name="5370"></a>     *   changing the value.
<a name="5371"></a>     */
<a name="5372"></a>    makeSetting(val)
<a name="5373"></a>    {
<a name="5374"></a>        /* remember the new value */
<a name="5375"></a>        curSetting = val;
<a name="5376"></a>    }
<a name="5377"></a>
<a name="5378"></a>    /*
<a name="5379"></a>     *   Is the given text a valid setting?  Returns true if so, nil if
<a name="5380"></a>     *   not.  This should not display any messages; simply indicate
<a name="5381"></a>     *   whether or not the setting is valid.
<a name="5382"></a>     *
<a name="5383"></a>     *   This is always called with the *canonical* value of the proposed
<a name="5384"></a>     *   new setting, as returned by canonicalizeSetting().
<a name="5385"></a>     */
<a name="5386"></a>    isValidSetting(val)
<a name="5387"></a>    {
<a name="5388"></a>        /*
<a name="5389"></a>         *   By default, allow anything; subclasses should override to
<a name="5390"></a>         *   enforce our valid set of values.
<a name="5391"></a>         */
<a name="5392"></a>        return true;
<a name="5393"></a>    }
<a name="5394"></a>
<a name="5395"></a>    /*
<a name="5396"></a>     *   "set &lt;self&gt;" action
<a name="5397"></a>     */
<a name="5398"></a>    dobjFor(Set)
<a name="5399"></a>    {
<a name="5400"></a>        verify() { logicalRank(150, 'settable'); }
<a name="5401"></a>        action() { askForLiteral(SetTo); }
<a name="5402"></a>    }
<a name="5403"></a>
<a name="5404"></a>    /*
<a name="5405"></a>     *   "set &lt;self&gt; to &lt;literal&gt;" action
<a name="5406"></a>     */
<a name="5407"></a>    dobjFor(SetTo)
<a name="5408"></a>    {
<a name="5409"></a>        preCond = [touchObj]
<a name="5410"></a>        verify()
<a name="5411"></a>        {
<a name="5412"></a>            local txt;
<a name="5413"></a>
<a name="5414"></a>            /*
<a name="5415"></a>             *   If we already know our literal text, and it's not valid,
<a name="5416"></a>             *   reduce the logicalness.  Don't actually make it
<a name="5417"></a>             *   illogical, as it's probably still more logical to set a
<a name="5418"></a>             *   settable to an invalid setting than to set something that
<a name="5419"></a>             *   isn't settable at all.
<a name="5420"></a>             */
<a name="5421"></a>            if ((txt = gAction.getLiteral()) != nil
<a name="5422"></a>                &amp;&amp; !isValidSetting(canonicalizeSetting(txt)))
<a name="5423"></a>                logicalRank(50, 'invalid setting');
<a name="5424"></a>        }
<a name="5425"></a>        check()
<a name="5426"></a>        {
<a name="5427"></a>            /* if the setting is not valid, don't allow it */
<a name="5428"></a>            if (!isValidSetting(canonicalizeSetting(gAction.getLiteral())))
<a name="5429"></a>            {
<a name="5430"></a>                /* there is no such setting */
<a name="5431"></a>                reportFailure(setToInvalidMsgProp);
<a name="5432"></a>                exit;
<a name="5433"></a>            }
<a name="5434"></a>        }
<a name="5435"></a>        action()
<a name="5436"></a>        {
<a name="5437"></a>            /* set the new value */
<a name="5438"></a>            makeSetting(canonicalizeSetting(gAction.getLiteral()));
<a name="5439"></a>
<a name="5440"></a>            /* remark on the change */
<a name="5441"></a>            defaultReport(okaySetToMsgProp, curSetting);
<a name="5442"></a>        }
<a name="5443"></a>    }
<a name="5444"></a>
<a name="5445"></a>    /* our message property for an invalid setting */
<a name="5446"></a>    setToInvalidMsgProp = &amp;setToInvalidMsg
<a name="5447"></a>
<a name="5448"></a>    /* our message property for acknowledging a new setting */
<a name="5449"></a>    okaySetToMsgProp = &amp;okaySetToMsg
<a name="5450"></a>;
<a name="5451"></a>
<a name="5452"></a>/*
<a name="5453"></a> *   Dial - something you can turn to different settings.  Note that dials
<a name="5454"></a> *   are usually used as components of larger objects; since our base
<a name="5455"></a> *   class is the basic Settable, component dials should be created to
<a name="5456"></a> *   inherit multiply from Dial and Component, in that order.
<a name="5457"></a> *
<a name="5458"></a> *   This is almost hte same as a regular Settable; the only thing we add
<a name="5459"></a> *   is that we make "turn &lt;self&gt; to &lt;literal&gt;" equivalent to "set &lt;self&gt;
<a name="5460"></a> *   to &lt;literal&gt;", as this is the verb most people would use to set a
<a name="5461"></a> *   dial.
<a name="5462"></a> */
<a name="5463"></a>class Dial: Settable
<a name="5464"></a>    /* "turn" with no destination - indicate that we need a setting */
<a name="5465"></a>    dobjFor(Turn)
<a name="5466"></a>    {
<a name="5467"></a>        verify() { illogical(&amp;mustSpecifyTurnToMsg); }
<a name="5468"></a>    }
<a name="5469"></a>
<a name="5470"></a>    /* treat "turn &lt;self&gt; to &lt;literal&gt;" the same as "set to" */
<a name="5471"></a>    dobjFor(TurnTo) asDobjFor(SetTo)
<a name="5472"></a>
<a name="5473"></a>    /* refer to setting the dial as turning it in our messages */
<a name="5474"></a>    setToInvalidMsgProp = &amp;turnToInvalidMsg
<a name="5475"></a>    okaySetToMsgProp = &amp;okayTurnToMsg
<a name="5476"></a>;
<a name="5477"></a>
<a name="5478"></a>/*
<a name="5479"></a> *   Numbered Dial - something you can turn to a range of numeric values.
<a name="5480"></a> */
<a name="5481"></a>class NumberedDial: Dial
<a name="5482"></a>    /*
<a name="5483"></a>     *   The range of settings - the dial can be set to values from the
<a name="5484"></a>     *   minimum to the maximum, inclusive.
<a name="5485"></a>     */
<a name="5486"></a>    minSetting = 1
<a name="5487"></a>    maxSetting = 10
<a name="5488"></a>
<a name="5489"></a>    /*
<a name="5490"></a>     *   Canonicalize a proposed setting value.  For numbers, strip off any
<a name="5491"></a>     *   leading zeros, since these don't change the meaning of the value.
<a name="5492"></a>     */
<a name="5493"></a>    canonicalizeSetting(val)
<a name="5494"></a>    {
<a name="5495"></a>        local num;
<a name="5496"></a>
<a name="5497"></a>        /* try parsing it as a digit string or a spelled-out number */
<a name="5498"></a>        if ((num = parseInt(val)) != nil)
<a name="5499"></a>        {
<a name="5500"></a>            /*
<a name="5501"></a>             *   we parsed it successfully - return the string
<a name="5502"></a>             *   representation of the numeric value
<a name="5503"></a>             */
<a name="5504"></a>            return toString(num);
<a name="5505"></a>        }
<a name="5506"></a>
<a name="5507"></a>        /* it didn't parse as a number, so just return it as-is */
<a name="5508"></a>        return val;
<a name="5509"></a>    }
<a name="5510"></a>
<a name="5511"></a>    /*
<a name="5512"></a>     *   Check a setting for validity.  A setting is valid only if it's a
<a name="5513"></a>     *   number within the allowed range for the dial.
<a name="5514"></a>     */
<a name="5515"></a>    isValidSetting(val)
<a name="5516"></a>    {
<a name="5517"></a>        local num;
<a name="5518"></a>
<a name="5519"></a>        /* if it doesn't look like a number, it's not valid */
<a name="5520"></a>        if (rexMatch('&lt;digit&gt;+', val) != val.length())
<a name="5521"></a>            return nil;
<a name="5522"></a>
<a name="5523"></a>        /* get the numeric value */
<a name="5524"></a>        num = toInteger(val);
<a name="5525"></a>
<a name="5526"></a>        /* it's valid if it's within range */
<a name="5527"></a>        return num &gt;= minSetting &amp;&amp; num &lt;= maxSetting;
<a name="5528"></a>    }
<a name="5529"></a>;
<a name="5530"></a>
<a name="5531"></a>/*
<a name="5532"></a> *   Labeled Dial - something you can turn to a set of arbitrary text
<a name="5533"></a> *   labels.
<a name="5534"></a> */
<a name="5535"></a>class LabeledDial: Dial
<a name="5536"></a>    /*
<a name="5537"></a>     *   The list of valid settings.  Each entry in this list should be a
<a name="5538"></a>     *   string value.  We ignore the case of these labels (we convert
<a name="5539"></a>     *   everything to upper-case when comparing labels).
<a name="5540"></a>     */
<a name="5541"></a>    validSettings = []
<a name="5542"></a>
<a name="5543"></a>    /*
<a name="5544"></a>     *   Canonicalize the setting.  We consider case insignificant in
<a name="5545"></a>     *   matching our labels, but the canonical version of a setting is the
<a name="5546"></a>     *   one that appears in the validSettings list - so if the player
<a name="5547"></a>     *   types in SET DIAL TO EXTRA LOUD, and the validSettings list
<a name="5548"></a>     *   contains 'Extra Loud', we'll want to convert the 'EXTRA LOUD' to
<a name="5549"></a>     *   the capitalization of the validSettings entry.
<a name="5550"></a>     */
<a name="5551"></a>    canonicalizeSetting(val)
<a name="5552"></a>    {
<a name="5553"></a>        local txt;
<a name="5554"></a>
<a name="5555"></a>        /*
<a name="5556"></a>         *   convert it to upper-case, so that we can compare it to our
<a name="5557"></a>         *   valid labels without regard to case
<a name="5558"></a>         */
<a name="5559"></a>        txt = val.toUpper();
<a name="5560"></a>
<a name="5561"></a>        /*
<a name="5562"></a>         *   if we find a match in the validSettings list, return the match
<a name="5563"></a>         *   from the list, since that's the canonical format
<a name="5564"></a>         */
<a name="5565"></a>        if ((txt = validSettings.valWhich({x: x.toUpper() == txt})) != nil)
<a name="5566"></a>            return txt;
<a name="5567"></a>
<a name="5568"></a>        /* we didn't find a match, so leave the original value unchanged */
<a name="5569"></a>        return val;
<a name="5570"></a>    }
<a name="5571"></a>
<a name="5572"></a>    /*
<a name="5573"></a>     *   Check a setting for validity.  A setting is valid only if it
<a name="5574"></a>     *   appears in the validSettings list for this dial.
<a name="5575"></a>     */
<a name="5576"></a>    isValidSetting(val)
<a name="5577"></a>    {
<a name="5578"></a>        /*
<a name="5579"></a>         *   If the given value appears in our validSettings list, it's a
<a name="5580"></a>         *   valid setting; otherwise, it's not valid.  Ignore case when
<a name="5581"></a>         *   comparing values by converting the valid labels to upper case;
<a name="5582"></a>         *   we've already converted the value we're testing to upper case,
<a name="5583"></a>         *   so the case mix won't matter in our comparison.
<a name="5584"></a>         *
<a name="5585"></a>         *   Note that we're handed a canonical setting value, so we don't
<a name="5586"></a>         *   have to worry about case differences.
<a name="5587"></a>         */
<a name="5588"></a>        return validSettings.indexOf(val) != nil;
<a name="5589"></a>    }
<a name="5590"></a>;
<a name="5591"></a>
<a name="5592"></a>
<a name="5593"></a>/* ------------------------------------------------------------------------ */
<a name="5594"></a>/*
<a name="5595"></a> *   Button - something you can push to activate, as a control for a
<a name="5596"></a> *   mechanical device.
<a name="5597"></a> */
<a name="5598"></a>class Button: Thing
<a name="5599"></a>    dobjFor(Push)
<a name="5600"></a>    {
<a name="5601"></a>        verify() { }
<a name="5602"></a>        action()
<a name="5603"></a>        {
<a name="5604"></a>            /*
<a name="5605"></a>             *   individual buttons should override this to carry out any
<a name="5606"></a>             *   special action for the button; by default, we'll just
<a name="5607"></a>             *   show a simple acknowledgment
<a name="5608"></a>             */
<a name="5609"></a>            defaultReport(&amp;okayPushButtonMsg);
<a name="5610"></a>        }
<a name="5611"></a>    }
<a name="5612"></a>;
<a name="5613"></a>
<a name="5614"></a>/* ------------------------------------------------------------------------ */
<a name="5615"></a>/*
<a name="5616"></a> *   Lever - something you can push, pull, or move, generally as a control
<a name="5617"></a> *   for a mechanical device.  Our basic lever has two states, "pushed"
<a name="5618"></a> *   and "pulled".
<a name="5619"></a> */
<a name="5620"></a>class Lever: Thing
<a name="5621"></a>    /*
<a name="5622"></a>     *   The current state.  We have two states: "pushed" and "pulled".
<a name="5623"></a>     *   We start in the pushed state, so the lever can initially be
<a name="5624"></a>     *   pulled, since "pull" is the verb most people would first think to
<a name="5625"></a>     *   apply to a lever.
<a name="5626"></a>     */
<a name="5627"></a>    isPulled = nil
<a name="5628"></a>
<a name="5629"></a>    /*
<a name="5630"></a>     *   Set the state.  This can be overridden to apply side effects as
<a name="5631"></a>     *   needed.
<a name="5632"></a>     */
<a name="5633"></a>    makePulled(pulled)
<a name="5634"></a>    {
<a name="5635"></a>        /* note the new state */
<a name="5636"></a>        isPulled = pulled;
<a name="5637"></a>    }
<a name="5638"></a>
<a name="5639"></a>    /*
<a name="5640"></a>     *   Action handlers.  We handle push and pull, and we treat "move" as
<a name="5641"></a>     *   equivalent to whichever of push or pull is appropriate to reverse
<a name="5642"></a>     *   the current state.
<a name="5643"></a>     */
<a name="5644"></a>    dobjFor(Push)
<a name="5645"></a>    {
<a name="5646"></a>        verify()
<a name="5647"></a>        {
<a name="5648"></a>            /* if it's already pushed, pushing it again makes no sense */
<a name="5649"></a>            if (!isPulled)
<a name="5650"></a>                illogicalAlready(&amp;alreadyPushedMsg);
<a name="5651"></a>        }
<a name="5652"></a>        action()
<a name="5653"></a>        {
<a name="5654"></a>            /* set the new state to pushed (i.e., not pulled) */
<a name="5655"></a>            makePulled(nil);
<a name="5656"></a>
<a name="5657"></a>            /* make the default report */
<a name="5658"></a>            defaultReport(&amp;okayPushLeverMsg);
<a name="5659"></a>        }
<a name="5660"></a>    }
<a name="5661"></a>    dobjFor(Pull)
<a name="5662"></a>    {
<a name="5663"></a>        verify()
<a name="5664"></a>        {
<a name="5665"></a>            /* if it's already pulled, pulling it again makes no sense */
<a name="5666"></a>            if (isPulled)
<a name="5667"></a>                illogicalAlready(&amp;alreadyPulledMsg);
<a name="5668"></a>        }
<a name="5669"></a>        action()
<a name="5670"></a>        {
<a name="5671"></a>            /* set the new state to pulled */
<a name="5672"></a>            makePulled(true);
<a name="5673"></a>
<a name="5674"></a>            /* make the default report */
<a name="5675"></a>            defaultReport(&amp;okayPullLeverMsg);
<a name="5676"></a>        }
<a name="5677"></a>    }
<a name="5678"></a>    dobjFor(Move)
<a name="5679"></a>    {
<a name="5680"></a>        verify() { }
<a name="5681"></a>        check()
<a name="5682"></a>        {
<a name="5683"></a>            /* run the check for pushing or pulling, as appropriate */
<a name="5684"></a>            if (isPulled)
<a name="5685"></a>                checkDobjPush();
<a name="5686"></a>            else
<a name="5687"></a>                checkDobjPull();
<a name="5688"></a>        }
<a name="5689"></a>        action()
<a name="5690"></a>        {
<a name="5691"></a>            /* if we're pulled, push the lever; otherwise pull it */
<a name="5692"></a>            if (isPulled)
<a name="5693"></a>                actionDobjPush();
<a name="5694"></a>            else
<a name="5695"></a>                actionDobjPull();
<a name="5696"></a>        }
<a name="5697"></a>    }
<a name="5698"></a>;
<a name="5699"></a>
<a name="5700"></a>/*
<a name="5701"></a> *   A spring-loaded lever is a lever that bounces back to its starting
<a name="5702"></a> *   position after being pulled.  This is essentially equivalent in terms
<a name="5703"></a> *   of functionality to a button, but can at least provide superficial
<a name="5704"></a> *   variety.
<a name="5705"></a> */
<a name="5706"></a>class SpringLever: Lever
<a name="5707"></a>    dobjFor(Pull)
<a name="5708"></a>    {
<a name="5709"></a>        action()
<a name="5710"></a>        {
<a name="5711"></a>            /*
<a name="5712"></a>             *   Individual objects should override this to perform the
<a name="5713"></a>             *   appropriate action when the lever is pulled.  By default,
<a name="5714"></a>             *   we'll do nothing except show a default report.
<a name="5715"></a>             */
<a name="5716"></a>            defaultReport(&amp;okayPullSpringLeverMsg);
<a name="5717"></a>        }
<a name="5718"></a>    }
<a name="5719"></a>;
<a name="5720"></a>
<a name="5721"></a>
<a name="5722"></a>/* ------------------------------------------------------------------------ */
<a name="5723"></a>/*
<a name="5724"></a> *   An item that can be worn
<a name="5725"></a> */
<a name="5726"></a>class Wearable: Thing
<a name="5727"></a>    /* is the item currently being worn? */
<a name="5728"></a>    isWorn()
<a name="5729"></a>    {
<a name="5730"></a>        /* it's being worn if the wearer is non-nil */
<a name="5731"></a>        return wornBy != nil;
<a name="5732"></a>    }
<a name="5733"></a>
<a name="5734"></a>    /*
<a name="5735"></a>     *   make the item worn by the given actor; if actor is nil, the item
<a name="5736"></a>     *   isn't being worn by anyone
<a name="5737"></a>     */
<a name="5738"></a>    makeWornBy(actor)
<a name="5739"></a>    {
<a name="5740"></a>        /* remember who's wearing the item */
<a name="5741"></a>        wornBy = actor;
<a name="5742"></a>    }
<a name="5743"></a>
<a name="5744"></a>    /*
<a name="5745"></a>     *   An item being worn is not considered to be held in the wearer's
<a name="5746"></a>     *   hands.
<a name="5747"></a>     */
<a name="5748"></a>    isHeldBy(actor)
<a name="5749"></a>    {
<a name="5750"></a>        if (isWornBy(actor))
<a name="5751"></a>        {
<a name="5752"></a>            /* it's being worn by the actor, so it's not also being held */
<a name="5753"></a>            return nil;
<a name="5754"></a>        }
<a name="5755"></a>        else
<a name="5756"></a>        {
<a name="5757"></a>            /*
<a name="5758"></a>             *   it's not being worn by this actor, so use the default
<a name="5759"></a>             *   interpretation of being held
<a name="5760"></a>             */
<a name="5761"></a>            return inherited(actor);
<a name="5762"></a>        }
<a name="5763"></a>    }
<a name="5764"></a>
<a name="5765"></a>    /*
<a name="5766"></a>     *   A wearable is not considered held by an actor when it is being
<a name="5767"></a>     *   worn, so we must do a what-if test for removing the item if the
<a name="5768"></a>     *   actor is currently wearing the item.  If the actor isn't wearing
<a name="5769"></a>     *   the item, we can use the default test of moving the item into the
<a name="5770"></a>     *   actor's inventory.
<a name="5771"></a>     */
<a name="5772"></a>    whatIfHeldBy(func, newLoc)
<a name="5773"></a>    {
<a name="5774"></a>        /*
<a name="5775"></a>         *   If the article is being worn, and it's already in the same
<a name="5776"></a>         *   location we're moving it to, simply test with the article no
<a name="5777"></a>         *   longer being worn.  Otherwise, inherit the default handling.
<a name="5778"></a>         */
<a name="5779"></a>        if (location == newLoc &amp;&amp; wornBy != nil)
<a name="5780"></a>            return whatIf(func, &amp;wornBy, nil);
<a name="5781"></a>        else
<a name="5782"></a>            return inherited(func, newLoc);
<a name="5783"></a>    }
<a name="5784"></a>
<a name="5785"></a>    /*
<a name="5786"></a>     *   Try making the current command's actor hold me.  If I'm already
<a name="5787"></a>     *   directly in the actor's inventory and I'm being worn, we'll try a
<a name="5788"></a>     *   'doff' command; otherwise, we'll use the default handling.
<a name="5789"></a>     */
<a name="5790"></a>    tryHolding()
<a name="5791"></a>    {
<a name="5792"></a>        /*
<a name="5793"></a>         *   Try an implicit 'take' command.  If the actor is carrying the
<a name="5794"></a>         *   object indirectly, make the command "take from" instead,
<a name="5795"></a>         *   since what we really want to do is take the object out of its
<a name="5796"></a>         *   container.
<a name="5797"></a>         */
<a name="5798"></a>        if (location == gActor &amp;&amp; isWornBy(gActor))
<a name="5799"></a>            return tryImplicitAction(Doff, self);
<a name="5800"></a>        else
<a name="5801"></a>            return inherited();
<a name="5802"></a>    }
<a name="5803"></a>
<a name="5804"></a>    /*
<a name="5805"></a>     *   The object wearing this object, if any; if I'm not being worn,
<a name="5806"></a>     *   this is nil.  The wearer should always be a container (direct or
<a name="5807"></a>     *   indirect) of this object - in order to wear something, you must
<a name="5808"></a>     *   be carrying it.  In most cases, the wearer should be the direct
<a name="5809"></a>     *   container of the object.
<a name="5810"></a>     *
<a name="5811"></a>     *   The reason we keep track of who's wearing the object (rather than
<a name="5812"></a>     *   simply keeping track of whether it's being worn) is to allow for
<a name="5813"></a>     *   cases where an actor is carrying another actor.  Since this
<a name="5814"></a>     *   object will be (indirectly) inside both actors in such cases, we
<a name="5815"></a>     *   would have to inspect intermediate containers to determine
<a name="5816"></a>     *   whether or not the outer actor was wearing the object if we
<a name="5817"></a>     *   didn't keep track of the wearer directly.
<a name="5818"></a>     */
<a name="5819"></a>    wornBy = nil
<a name="5820"></a>
<a name="5821"></a>    /* am I worn by the given object? */
<a name="5822"></a>    isWornBy(actor)
<a name="5823"></a>    {
<a name="5824"></a>        return wornBy == actor;
<a name="5825"></a>    }
<a name="5826"></a>
<a name="5827"></a>    /*
<a name="5828"></a>     *   An article of clothing that is being worn by an actor does not
<a name="5829"></a>     *   typically encumber the actor at all, so by default we'll return
<a name="5830"></a>     *   zero if we're being worn by the actor, and our normal bulk
<a name="5831"></a>     *   otherwise.
<a name="5832"></a>     */
<a name="5833"></a>    getEncumberingBulk(actor)
<a name="5834"></a>    {
<a name="5835"></a>        /*
<a name="5836"></a>         *   if we're being worn by the actor, we create no encumbrance at
<a name="5837"></a>         *   all; otherwise, return our normal bulk
<a name="5838"></a>         */
<a name="5839"></a>        return isWornBy(actor) ? 0 : getBulk();
<a name="5840"></a>    }
<a name="5841"></a>
<a name="5842"></a>    /*
<a name="5843"></a>     *   An article of clothing typically encumbers an actor with the same
<a name="5844"></a>     *   weight whether or not the actor is wearing the item.  However,
<a name="5845"></a>     *   this might not apply to all objects; a suit of armor, for
<a name="5846"></a>     *   example, might be slightly less encumbering in terms of weight
<a name="5847"></a>     *   when worn than it is when held because the distribution of weight
<a name="5848"></a>     *   is more manageable when worn.  By default, we simply return our
<a name="5849"></a>     *   normal weight, whether worn or not; subclasses can override as
<a name="5850"></a>     *   needed to differentiate.
<a name="5851"></a>     */
<a name="5852"></a>    getEncumberingWeight(actor)
<a name="5853"></a>    {
<a name="5854"></a>        return getWeight();
<a name="5855"></a>    }
<a name="5856"></a>
<a name="5857"></a>    /* get my state */
<a name="5858"></a>    getState = (isWorn() ? wornState : unwornState)
<a name="5859"></a>
<a name="5860"></a>    /* my list of possible states */
<a name="5861"></a>    allStates = [wornState, unwornState]
<a name="5862"></a>
<a name="5863"></a>
<a name="5864"></a>    /* -------------------------------------------------------------------- */
<a name="5865"></a>    /*
<a name="5866"></a>     *   Action processing
<a name="5867"></a>     */
<a name="5868"></a>
<a name="5869"></a>    dobjFor(Wear)
<a name="5870"></a>    {
<a name="5871"></a>        preCond = [objHeld]
<a name="5872"></a>        verify()
<a name="5873"></a>        {
<a name="5874"></a>            /* make sure the actor isn't already wearing the item */
<a name="5875"></a>            if (isWornBy(gActor))
<a name="5876"></a>                illogicalAlready(&amp;alreadyWearingMsg);
<a name="5877"></a>        }
<a name="5878"></a>        action()
<a name="5879"></a>        {
<a name="5880"></a>            /* make the item worn and describe what happened */
<a name="5881"></a>            makeWornBy(gActor);
<a name="5882"></a>            defaultReport(&amp;okayWearMsg);
<a name="5883"></a>        }
<a name="5884"></a>    }
<a name="5885"></a>
<a name="5886"></a>    dobjFor(Doff)
<a name="5887"></a>    {
<a name="5888"></a>        preCond = [roomToHoldObj]
<a name="5889"></a>        verify()
<a name="5890"></a>        {
<a name="5891"></a>            /*
<a name="5892"></a>             *   Make sure the actor is actually wearing the item.  If
<a name="5893"></a>             *   they're not, it's illogical, but if they are, it's an
<a name="5894"></a>             *   especially likely thing to remove.
<a name="5895"></a>             */
<a name="5896"></a>            if (!isWornBy(gActor))
<a name="5897"></a>                illogicalAlready(&amp;notWearingMsg);
<a name="5898"></a>            else
<a name="5899"></a>                logicalRank(150, 'worn');
<a name="5900"></a>        }
<a name="5901"></a>        action()
<a name="5902"></a>        {
<a name="5903"></a>            /* un-wear the item and describe what happened */
<a name="5904"></a>            makeWornBy(nil);
<a name="5905"></a>            defaultReport(&amp;okayDoffMsg);
<a name="5906"></a>        }
<a name="5907"></a>    }
<a name="5908"></a>
<a name="5909"></a>    /* "remove &lt;wearable&gt;" is the same as "doff &lt;wearable&gt;" */
<a name="5910"></a>    dobjFor(Remove) asDobjFor(Doff)
<a name="5911"></a>
<a name="5912"></a>    /*
<a name="5913"></a>     *   if a wearable is being worn, showing it off to someone doesn't
<a name="5914"></a>     *   require holding it
<a name="5915"></a>     */
<a name="5916"></a>    dobjFor(ShowTo)
<a name="5917"></a>    {
<a name="5918"></a>        preCond()
<a name="5919"></a>        {
<a name="5920"></a>            /* get the standard handling */
<a name="5921"></a>            local lst = inherited();
<a name="5922"></a>
<a name="5923"></a>            /* if we're being worn, don't require us to be held */
<a name="5924"></a>            if (isWornBy(gActor))
<a name="5925"></a>                lst -= objHeld;
<a name="5926"></a>
<a name="5927"></a>            /* return the result */
<a name="5928"></a>            return lst;
<a name="5929"></a>        }
<a name="5930"></a>    }
<a name="5931"></a>;
<a name="5932"></a>
<a name="5933"></a>/* ------------------------------------------------------------------------ */
<a name="5934"></a>/*
<a name="5935"></a> *   An item that can provide light.
<a name="5936"></a> *
<a name="5937"></a> *   Any Thing can provide light, but this class should be used for
<a name="5938"></a> *   objects that explicitly serve as light sources from the player's
<a name="5939"></a> *   perspective.  Objects of this class display a "providing light"
<a name="5940"></a> *   status message in inventory listings, and can be turned on and off
<a name="5941"></a> *   via the isLit property.
<a name="5942"></a> */
<a name="5943"></a>class LightSource: Thing
<a name="5944"></a>    /* is the light source currently turned on? */
<a name="5945"></a>    isLit = true
<a name="5946"></a>
<a name="5947"></a>    /*
<a name="5948"></a>     *   Turn the light source on or off.  Note that we don't have to make
<a name="5949"></a>     *   any special check for a change to the light level, because the
<a name="5950"></a>     *   main action handler always checks for a change in light/dark
<a name="5951"></a>     *   status over the course of the turn.
<a name="5952"></a>     */
<a name="5953"></a>    makeLit(lit)
<a name="5954"></a>    {
<a name="5955"></a>        /* change the status */
<a name="5956"></a>        isLit = lit;
<a name="5957"></a>    }
<a name="5958"></a>
<a name="5959"></a>    /*
<a name="5960"></a>     *   We can distinguish light sources according to their isLit status.
<a name="5961"></a>     *   Give the lit/unlit distinction higher priority than the normal
<a name="5962"></a>     *   ownership/containment distinction.
<a name="5963"></a>     */
<a name="5964"></a>    distinguishers = [basicDistinguisher, litUnlitDistinguisher,
<a name="5965"></a>                      ownershipDistinguisher, locationDistinguisher]
<a name="5966"></a>
<a name="5967"></a>    /* the brightness that the object has when it is on and off */
<a name="5968"></a>    brightnessOn = 3
<a name="5969"></a>    brightnessOff = 0
<a name="5970"></a>
<a name="5971"></a>    /*
<a name="5972"></a>     *   return the appropriate on/off brightness, depending on whether or
<a name="5973"></a>     *   not we're currently lit
<a name="5974"></a>     */
<a name="5975"></a>    brightness { return isLit ? brightnessOn : brightnessOff; }
<a name="5976"></a>
<a name="5977"></a>    /* get our current state: lit or unlit */
<a name="5978"></a>    getState = (brightness &gt; 1 ? lightSourceStateOn : lightSourceStateOff)
<a name="5979"></a>
<a name="5980"></a>    /* get our set of possible states */
<a name="5981"></a>    allStates = [lightSourceStateOn, lightSourceStateOff]
<a name="5982"></a>;
<a name="5983"></a>
<a name="5984"></a>/*
<a name="5985"></a> *   A Flashlight is a special kind of light source that can be switched
<a name="5986"></a> *   on and off.
<a name="5987"></a> *
<a name="5988"></a> *   To create a limited-use flashlight (with a limited battery life, for
<a name="5989"></a> *   example), you can combine this class with FueledLightSource.  The
<a name="5990"></a> *   flashlight's on/off switch status is a separate property from its
<a name="5991"></a> *   lit/unlit light-source status, so combining Flashlight with
<a name="5992"></a> *   FueledLightSource will actually allow the two to become decoupled: a
<a name="5993"></a> *   flashlight can be on without providing light, when the battery is
<a name="5994"></a> *   dead.  For this reason, you might want to override the decription,
<a name="5995"></a> *   and possibly the TurnOn action() handler, to customize the messages
<a name="5996"></a> *   for the case when the flashlight is switched on but out of power.
<a name="5997"></a> */
<a name="5998"></a>class Flashlight: LightSource, Switch
<a name="5999"></a>    /* our switch status - start in the 'off' position */
<a name="6000"></a>    isOn = nil
<a name="6001"></a>
<a name="6002"></a>    /*
<a name="6003"></a>     *   Change the on/off status.  Note that switching the flashlight on
<a name="6004"></a>     *   or off should always be done via makeOn - the makeLit inherited
<a name="6005"></a>     *   from the LightSource should never be called directly on a
<a name="6006"></a>     *   Flashlight object, because it doesn't keep the switch on/off and
<a name="6007"></a>     *   flashlight lit/unlit status in sync.  This routine is the one to
<a name="6008"></a>     *   call because it keeps everything properly synchronized.
<a name="6009"></a>     */
<a name="6010"></a>    makeOn(stat)
<a name="6011"></a>    {
<a name="6012"></a>        /* inherit the default handling */
<a name="6013"></a>        inherited(stat);
<a name="6014"></a>
<a name="6015"></a>        /*
<a name="6016"></a>         *   Set the 'lit' status to track the on/off status.  Note that
<a name="6017"></a>         *   we don't simply do this by deriving isLit from isOn because
<a name="6018"></a>         *   we want to invoke the side effects of changing the status by
<a name="6019"></a>         *   calling makeLit explicitly.  We also want to allow the two to
<a name="6020"></a>         *   be decoupled when necessary, such as might happen when the
<a name="6021"></a>         *   flashlight's bulb is burned out, or its battery has run down.
<a name="6022"></a>         */
<a name="6023"></a>        makeLit(stat);
<a name="6024"></a>    }
<a name="6025"></a>
<a name="6026"></a>    /* initialize */
<a name="6027"></a>    initializeThing()
<a name="6028"></a>    {
<a name="6029"></a>        /* inherit default handling */
<a name="6030"></a>        inherited();
<a name="6031"></a>
<a name="6032"></a>        /*
<a name="6033"></a>         *   Make sure our initial isLit setting (for the LightSource)
<a name="6034"></a>         *   matches our initial isOn steting (for the Switch).  The
<a name="6035"></a>         *   switch status drives the light source status, so initialize
<a name="6036"></a>         *   the latter from the former.
<a name="6037"></a>         */
<a name="6038"></a>        isLit = isOn;
<a name="6039"></a>    }
<a name="6040"></a>
<a name="6041"></a>    /* treat 'light' and 'extinguish' as 'turn on' and 'turn off' */
<a name="6042"></a>    dobjFor(Light) asDobjFor(TurnOn)
<a name="6043"></a>    dobjFor(Extinguish) asDobjFor(TurnOff)
<a name="6044"></a>
<a name="6045"></a>    /* if we turn on the flashlight, but it doesn't light, mention this */
<a name="6046"></a>    dobjFor(TurnOn)
<a name="6047"></a>    {
<a name="6048"></a>        action()
<a name="6049"></a>        {
<a name="6050"></a>            /* do the normal work */
<a name="6051"></a>            inherited();
<a name="6052"></a>
<a name="6053"></a>            /*
<a name="6054"></a>             *   If we're now on but not lit, mention this.  This can
<a name="6055"></a>             *   happen when we run out of power in the battery, or our
<a name="6056"></a>             *   bulb is missing or burned out, or we're simply broken.
<a name="6057"></a>             */
<a name="6058"></a>            if (isOn &amp;&amp; !isLit)
<a name="6059"></a>                mainReport(&amp;flashlightOnButDarkMsg);
<a name="6060"></a>        }
<a name="6061"></a>    }
<a name="6062"></a>;
<a name="6063"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
