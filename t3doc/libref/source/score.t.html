<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>score.t</title></head><body>
<table class=ban><tr><td><h1>score.t</h1><td align=right><a href="../file/score.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 by Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library - scoring
<a name="7"></a> *
<a name="8"></a> *   This module defines objects related to keeping track of the player's
<a name="9"></a> *   score, which indicates the player's progress through the game.
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>/* include the library header */
<a name="13"></a>#include "adv3.h"
<a name="14"></a>
<a name="15"></a>
<a name="16"></a>/* ------------------------------------------------------------------------ */
<a name="17"></a>/*
<a name="18"></a> *   An Achievement is an object used to award points in the score.  For
<a name="19"></a> *   most purposes, an achievement can be described simply by a string,
<a name="20"></a> *   but the Achievement object provides more flexibility in describing
<a name="21"></a> *   combined scores when a set of similar achievements are to be grouped.
<a name="22"></a> *
<a name="23"></a> *   There are two ways to use the scoring system.
<a name="24"></a> *
<a name="25"></a> *   1.  You can use a mix of string names and Achievement objects for
<a name="26"></a> *   scoring items; each time you award a scoring item, you call the
<a name="27"></a> *   function addToScore() to specify the achievement (by name or by
<a name="28"></a> *   Achievement object) and the number of points to award.  You can also
<a name="29"></a> *   call the method addToScoreOnce() on an Achievement object to award
<a name="30"></a> *   the scoring item, ensuring that the item is only awarded once in the
<a name="31"></a> *   entire game (saving you the trouble of checking to see if the event
<a name="32"></a> *   that triggered the scoring item has happened before already in the
<a name="33"></a> *   same game).  If you do this, you MUST set the property
<a name="34"></a> *   gameMain.maxScore to reflect the maximum score possible in the game.
<a name="35"></a> *
<a name="36"></a> *   2.  You can use EXCLUSIVELY Achievement objects to represents scoring
<a name="37"></a> *   items, and give each Achievement object a 'points' property
<a name="38"></a> *   indicating the number of points it's worth.  To award a scoring item,
<a name="39"></a> *   you call the method awardPoints() on an Achievement object.  If you
<a name="40"></a> *   use this style of scoring, the library AUTOMATICALLY computes the
<a name="41"></a> *   gameMain.maxScore value, by adding up the 'points' values of all of
<a name="42"></a> *   the Achievement objects in the game.  For this to work properly, you
<a name="43"></a> *   have to obey the following rules:
<a name="44"></a> *
<a name="45"></a> *.    - use ONLY Achievement objects (never strings) to award points;
<a name="46"></a> *.    - set the 'points' property of each Achievement to its score;
<a name="47"></a> *.    - define Achievement objects statically only (never use 'new' to
<a name="48"></a> *.      create an Achievement dynamically)
<a name="49"></a> *.    - if an Achievement can be awarded more than once, you must override
<a name="50"></a> *.      its 'maxPoints' property to reflect the total number of points it
<a name="51"></a> *.      will be worth when it is awarded the maximum number of times;
<a name="52"></a> *.    - always award an Achievement through its awardPoints() or
<a name="53"></a> *.      awardPointsOnce() method;
<a name="54"></a> *.    - there exists at least one solution of the game in which every
<a name="55"></a> *.      Achievement object is awarded
<a name="56"></a> */
<a name="57"></a>class Achievement: object
<a name="58"></a>    /*
<a name="59"></a>     *   The number of points this Achievement scores individually.  By
<a name="60"></a>     *   default, we set this to nil.  If you use the awardPoints() or
<a name="61"></a>     *   awardPointsOnce() methods, you MUST set this to a non-nil value.
<a name="62"></a>     *
<a name="63"></a>     *   If you set this to a non-nil value, the library will use it
<a name="64"></a>     *   pre-compute the maximum possible score in the game, saving you the
<a name="65"></a>     *   trouble of figuring out the maximum score by hand.
<a name="66"></a>     */
<a name="67"></a>    points = nil
<a name="68"></a>
<a name="69"></a>    /*
<a name="70"></a>     *   The MAXIMUM number of points this Achievement can award.  This is
<a name="71"></a>     *   by default just our 'points' value, on the assumption that the
<a name="72"></a>     *   achievement is scored only once.  The library uses this value
<a name="73"></a>     *   during pre-initialization to compute the maximum possible score in
<a name="74"></a>     *   the game.
<a name="75"></a>     */
<a name="76"></a>    maxPoints = (points)
<a name="77"></a>
<a name="78"></a>    /*
<a name="79"></a>     *   Describe the achievement - this must display a string explaining
<a name="80"></a>     *   the reason the points associated with this achievement were
<a name="81"></a>     *   awarded.
<a name="82"></a>     *
<a name="83"></a>     *   Note that this description can make use of the scoreCount
<a name="84"></a>     *   information to show different descriptions depending on how many
<a name="85"></a>     *   times the item has scored.  For example, an achievement for
<a name="86"></a>     *   finding various treasure items might want to display "finding a
<a name="87"></a>     *   treasure" if only one treasure was found and "finding five
<a name="88"></a>     *   treasures" if five were found.
<a name="89"></a>     *
<a name="90"></a>     *   In some cases, it might be desirable to keep track of additional
<a name="91"></a>     *   custom information, and use that information in generating the
<a name="92"></a>     *   description.  For example, the game might keep a list of
<a name="93"></a>     *   treasures found with the achievement, adding to the list each
<a name="94"></a>     *   time the achievement is scored, and displaying the contents of
<a name="95"></a>     *   the list when the description is shown.
<a name="96"></a>     */
<a name="97"></a>    desc = ""
<a name="98"></a>
<a name="99"></a>    /* show myself in a full-score listing */
<a name="100"></a>    listFullScoreItem()
<a name="101"></a>    {
<a name="102"></a>        /* show the number of points I'm worth */
<a name="103"></a>        gLibMessages.fullScoreItemPoints(totalPoints);
<a name="104"></a>
<a name="105"></a>        /* show my description */
<a name="106"></a>        desc;
<a name="107"></a>    }
<a name="108"></a>
<a name="109"></a>    /*
<a name="110"></a>     *   The number of times the achievement has been awarded.  Each time
<a name="111"></a>     *   the achievement is passed to addToScore(), this is incremented.
<a name="112"></a>     *   Note that this is distinct from the number of points.
<a name="113"></a>     */
<a name="114"></a>    scoreCount = 0
<a name="115"></a>
<a name="116"></a>    /*
<a name="117"></a>     *   the number of points awarded for the achievement; if this
<a name="118"></a>     *   achievement has been accomplished multiple times, this reflects
<a name="119"></a>     *   the aggregate number of points awarded for all of the times it
<a name="120"></a>     *   has been accomplished
<a name="121"></a>     */
<a name="122"></a>    totalPoints = 0
<a name="123"></a>
<a name="124"></a>    /*
<a name="125"></a>     *   Add this achievement to the score one time only, awarding the
<a name="126"></a>     *   given number of points.  This can be used to score an achievement
<a name="127"></a>     *   without separately tracking whether or not the achievement has
<a name="128"></a>     *   been accomplished previously.  If the achievement has already been
<a name="129"></a>     *   scored before, this will do nothing at all; otherwise, it'll score
<a name="130"></a>     *   the achievement with the given number of points.  Returns true if
<a name="131"></a>     *   we do award the points, nil if not (because we've awarded them
<a name="132"></a>     *   before).
<a name="133"></a>     */
<a name="134"></a>    addToScoreOnce(points)
<a name="135"></a>    {
<a name="136"></a>        /* if I've never been scored before, score me now */
<a name="137"></a>        if (scoreCount == 0)
<a name="138"></a>        {
<a name="139"></a>            /* add the points to the score */
<a name="140"></a>            addToScore(points, self);
<a name="141"></a>
<a name="142"></a>            /* tell the caller we awarded the points as requested */
<a name="143"></a>            return true;
<a name="144"></a>        }
<a name="145"></a>        else
<a name="146"></a>        {
<a name="147"></a>            /* tell the caller we didn't do anything */
<a name="148"></a>            return nil;
<a name="149"></a>        }
<a name="150"></a>    }
<a name="151"></a>
<a name="152"></a>    /*
<a name="153"></a>     *   Award this Achievement's score, using the score value specified in
<a name="154"></a>     *   my 'points' property.
<a name="155"></a>     */
<a name="156"></a>    awardPoints()
<a name="157"></a>    {
<a name="158"></a>        /* add me to the score, using my 'points' property */
<a name="159"></a>        addToScore(points, self);
<a name="160"></a>    }
<a name="161"></a>
<a name="162"></a>    /*
<a name="163"></a>     *   Award this Achievement's score, but ensure that we're never
<a name="164"></a>     *   awarded more than one time.  If this Achievement has already been
<a name="165"></a>     *   awarded, this does nothing at all.  Returns true if we do award
<a name="166"></a>     *   the points, nil if not (because we've awarded them before).
<a name="167"></a>     */
<a name="168"></a>    awardPointsOnce()
<a name="169"></a>    {
<a name="170"></a>        /* award my 'points' value only if we haven't score before */
<a name="171"></a>        return addToScoreOnce(points);
<a name="172"></a>    }
<a name="173"></a>;
<a name="174"></a>
<a name="175"></a>/*
<a name="176"></a> *   Generic text achievement.  When we add an achievement to the full
<a name="177"></a> *   score list and the achievement is a simple string description, we'll
<a name="178"></a> *   create one of these to encapsulate the achievement.
<a name="179"></a> */
<a name="180"></a>class SimpleAchievement: Achievement
<a name="181"></a>    /* create dynamically with a given string as our description */
<a name="182"></a>    construct(str) { desc_ = str; }
<a name="183"></a>
<a name="184"></a>    /* show my description */
<a name="185"></a>    desc { say(desc_); }
<a name="186"></a>
<a name="187"></a>    /* my description string */
<a name="188"></a>    desc_ = ''
<a name="189"></a>;
<a name="190"></a>
<a name="191"></a>/*
<a name="192"></a> *   List interface for showing the full score list
<a name="193"></a> */
<a name="194"></a>fullScoreLister: Lister
<a name="195"></a>    showListPrefixTall(itemCount, pov, parent)
<a name="196"></a>    {
<a name="197"></a>        /* showt he full score list intro message */
<a name="198"></a>        gLibMessages.showFullScorePrefix;
<a name="199"></a>    }
<a name="200"></a>
<a name="201"></a>    /* every achievement is listed */
<a name="202"></a>    isListed(obj) { return true; }
<a name="203"></a>
<a name="204"></a>    /* each item counts as a singular object grammatically */
<a name="205"></a>    listCardinality(obj) { return 1; }
<a name="206"></a>
<a name="207"></a>    /* achievements have no containment hierarchy */
<a name="208"></a>    getContents(obj) { return []; }
<a name="209"></a>    getListedContents(obj, infoTab) { return []; }
<a name="210"></a>    showContentsList(pov, obj, options, indent, infoTab) { }
<a name="211"></a>    showInlineContentsList(pov, obj, options, indent, infoTab) { }
<a name="212"></a>
<a name="213"></a>    /* show an item */
<a name="214"></a>    showListItem(obj, options, pov, infoTab) { obj.listFullScoreItem(); }
<a name="215"></a>;
<a name="216"></a>
<a name="217"></a>
<a name="218"></a>/*
<a name="219"></a> *   Score notification daemon handler.  We'll receive a
<a name="220"></a> *   checkNotification() call each turn; we'll display a notification
<a name="221"></a> *   message each time the score has changed since the last time we ran.
<a name="222"></a> */
<a name="223"></a>scoreNotifier: PreinitObject
<a name="224"></a>    /* the score as it was the last time we displayed a notification */
<a name="225"></a>    lastScore = static (libScore.totalScore)
<a name="226"></a>
<a name="227"></a>    /* we've never generated a notification about the score before */
<a name="228"></a>    everNotified = nil
<a name="229"></a>
<a name="230"></a>    /* daemon entrypoint */
<a name="231"></a>    checkNotification()
<a name="232"></a>    {
<a name="233"></a>        /*
<a name="234"></a>         *   if the score has changed since the last time we checked,
<a name="235"></a>         *   possibly generate a notification
<a name="236"></a>         */
<a name="237"></a>        if (libScore.totalScore != lastScore)
<a name="238"></a>        {
<a name="239"></a>            /* only show a message if we're allowed to */
<a name="240"></a>            if (libScore.scoreNotify.isOn)
<a name="241"></a>            {
<a name="242"></a>                local delta;
<a name="243"></a>
<a name="244"></a>                /* calculate the change since the last notification */
<a name="245"></a>                delta = libScore.totalScore - lastScore;
<a name="246"></a>
<a name="247"></a>                /*
<a name="248"></a>                 *   generate the first or non-first notification, as
<a name="249"></a>                 *   appropriate
<a name="250"></a>                 */
<a name="251"></a>                if (everNotified)
<a name="252"></a>                    gLibMessages.scoreChange(delta);
<a name="253"></a>                else
<a name="254"></a>                    gLibMessages.firstScoreChange(delta);
<a name="255"></a>
<a name="256"></a>                /*
<a name="257"></a>                 *   note that we've ever generated a score change
<a name="258"></a>                 *   notification, so that we don't generate the more
<a name="259"></a>                 *   verbose first-time message on subsequent
<a name="260"></a>                 *   notifications
<a name="261"></a>                 */
<a name="262"></a>                everNotified = true;
<a name="263"></a>            }
<a name="264"></a>
<a name="265"></a>            /*
<a name="266"></a>             *   Remember the current score, so that we don't generate
<a name="267"></a>             *   another notification until the score has changed again.
<a name="268"></a>             *   Note that we note the new score even if we aren't
<a name="269"></a>             *   displaying a message this time, because we don't want to
<a name="270"></a>             *   generate a message upon re-enabling notifications.
<a name="271"></a>             */
<a name="272"></a>            lastScore = libScore.totalScore;
<a name="273"></a>        }
<a name="274"></a>    }
<a name="275"></a>
<a name="276"></a>    /* execute pre-initialization */
<a name="277"></a>    execute()
<a name="278"></a>    {
<a name="279"></a>        /* initialize the score change notification daemon */
<a name="280"></a>        new PromptDaemon(self, &amp;checkNotification);
<a name="281"></a>    }
<a name="282"></a>;
<a name="283"></a>
<a name="284"></a>/*
<a name="285"></a> *   Add points to the total score.  This is a convenience function that
<a name="286"></a> *   simply calls libScore.addToScore_().
<a name="287"></a> */
<a name="288"></a>addToScore(points, desc)
<a name="289"></a>{
<a name="290"></a>    /* simply call the libScore method to handle it */
<a name="291"></a>    libScore.addToScore_(points, desc);
<a name="292"></a>}
<a name="293"></a>
<a name="294"></a>/*
<a name="295"></a> *   The main game score object.
<a name="296"></a> */
<a name="297"></a>libScore: PreinitObject
<a name="298"></a>    /*
<a name="299"></a>     *   Add to the score.  'points' is the number of points to add to the
<a name="300"></a>     *   score, and 'desc' is a string describing the reason the points
<a name="301"></a>     *   are being awarded, or an Achievement object describing the points.
<a name="302"></a>     *
<a name="303"></a>     *   We keep a list of each unique achievement.  If 'desc' is already
<a name="304"></a>     *   in this list, we'll simply add the given number of points to the
<a name="305"></a>     *   existing entry for the same description.
<a name="306"></a>     *
<a name="307"></a>     *   Note that, if 'desc' is an Achievement object, it will match a
<a name="308"></a>     *   previous item only if it's exactly the same Achievement instance.
<a name="309"></a>     */
<a name="310"></a>    addToScore_(points, desc)
<a name="311"></a>    {
<a name="312"></a>        local idx;
<a name="313"></a>
<a name="314"></a>        /*
<a name="315"></a>         *   if the description is a string, encapsulate it in a
<a name="316"></a>         *   SimpleAchievement object
<a name="317"></a>         */
<a name="318"></a>        if (dataType(desc) == TypeSString)
<a name="319"></a>        {
<a name="320"></a>            local newDesc;
<a name="321"></a>
<a name="322"></a>            /*
<a name="323"></a>             *   look for an existing SimpleAchievement in our list with
<a name="324"></a>             *   the same descriptive text - if we find one, reuse it,
<a name="325"></a>             *   since this is another instance of the same group of
<a name="326"></a>             *   achievements and thus can be combined into the same
<a name="327"></a>             *   achievement object
<a name="328"></a>             */
<a name="329"></a>            newDesc = fullScoreList.valWhich(
<a name="330"></a>                { x: x.ofKind(SimpleAchievement) &amp;&amp; x.desc_ == desc });
<a name="331"></a>
<a name="332"></a>            /*
<a name="333"></a>             *   if we didn't find it, create a new simple achievement to
<a name="334"></a>             *   wrap the descriptive text
<a name="335"></a>             */
<a name="336"></a>            if (newDesc == nil)
<a name="337"></a>                newDesc = new SimpleAchievement(desc);
<a name="338"></a>
<a name="339"></a>            /*
<a name="340"></a>             *   for the rest of our processing, use the wrapper simple
<a name="341"></a>             *   achievement object instead of the original text string
<a name="342"></a>             */
<a name="343"></a>            desc = newDesc;
<a name="344"></a>        }
<a name="345"></a>
<a name="346"></a>        /* increase the use count for the achievement */
<a name="347"></a>        desc.scoreCount++;
<a name="348"></a>
<a name="349"></a>        /* add the points to the total */
<a name="350"></a>        totalScore += points;
<a name="351"></a>
<a name="352"></a>        /* try to find a match in our list of past achievements */
<a name="353"></a>        idx = fullScoreList.indexOf(desc);
<a name="354"></a>
<a name="355"></a>        /* if we didn't find it, add it to the list */
<a name="356"></a>        if (idx == nil)
<a name="357"></a>            fullScoreList.append(desc);
<a name="358"></a>
<a name="359"></a>        /*
<a name="360"></a>         *   combine the points awarded this time into the total for this
<a name="361"></a>         *   achievement
<a name="362"></a>         */
<a name="363"></a>        desc.totalPoints += points;
<a name="364"></a>    }
<a name="365"></a>
<a name="366"></a>    /*
<a name="367"></a>     *   Explicitly run the score notification daemon.
<a name="368"></a>     */
<a name="369"></a>    runScoreNotifier()
<a name="370"></a>    {
<a name="371"></a>        /* explicitly run the notification */
<a name="372"></a>        scoreNotifier.checkNotification();
<a name="373"></a>    }
<a name="374"></a>
<a name="375"></a>    /*
<a name="376"></a>     *   Show the simple score
<a name="377"></a>     */
<a name="378"></a>    showScore()
<a name="379"></a>    {
<a name="380"></a>        /*
<a name="381"></a>         *   Show the basic score statistics.  Use the appropriate form of
<a name="382"></a>         *   the message, depending on whether or not there's a maximum
<a name="383"></a>         *   score value.
<a name="384"></a>         */
<a name="385"></a>        if (gameMain.maxScore != nil)
<a name="386"></a>            gLibMessages.showScoreMessage(totalScore,
<a name="387"></a>                                          gameMain.maxScore,
<a name="388"></a>                                          libGlobal.totalTurns);
<a name="389"></a>        else
<a name="390"></a>            gLibMessages.showScoreNoMaxMessage(totalScore,
<a name="391"></a>                                               libGlobal.totalTurns);
<a name="392"></a>
<a name="393"></a>        /* show the score ranking */
<a name="394"></a>        showScoreRank(totalScore);
<a name="395"></a>    }
<a name="396"></a>
<a name="397"></a>    /*
<a name="398"></a>     *   show the score rank message
<a name="399"></a>     */
<a name="400"></a>    showScoreRank(points)
<a name="401"></a>    {
<a name="402"></a>        local idx;
<a name="403"></a>        local tab = gameMain.scoreRankTable;
<a name="404"></a>
<a name="405"></a>        /* if there's no rank table, skip the ranking */
<a name="406"></a>        if (tab == nil)
<a name="407"></a>            return;
<a name="408"></a>
<a name="409"></a>        /*
<a name="410"></a>         *   find the last item for which our score is at least the
<a name="411"></a>         *   minimum - the table is in ascending order of minimum score,
<a name="412"></a>         *   so we want the last item for which our score is sufficient
<a name="413"></a>         */
<a name="414"></a>        idx = tab.lastIndexWhich({x: points &gt;= x[1]});
<a name="415"></a>
<a name="416"></a>        /* if we didn't find an item, use the first by default */
<a name="417"></a>        if (idx == nil)
<a name="418"></a>            idx = 1;
<a name="419"></a>
<a name="420"></a>        /* show the description from the item we found */
<a name="421"></a>        gLibMessages.showScoreRankMessage(tab[idx][2]);
<a name="422"></a>    }
<a name="423"></a>
<a name="424"></a>    /*
<a name="425"></a>     *   Display the full score.  'explicit' is true if the player asked
<a name="426"></a>     *   for the full score explicitly, as with a FULL SCORE command; if
<a name="427"></a>     *   we're showing the full score automatically in the course of some
<a name="428"></a>     *   other action, 'explicit' should be nil.
<a name="429"></a>     */
<a name="430"></a>    showFullScore()
<a name="431"></a>    {
<a name="432"></a>        /* show the basic score statistics */
<a name="433"></a>        showScore();
<a name="434"></a>
<a name="435"></a>        /* list the achievements in 'tall' mode */
<a name="436"></a>        fullScoreLister.showListAll(fullScoreList.toList(),
<a name="437"></a>                                    ListTall, 0);
<a name="438"></a>    }
<a name="439"></a>
<a name="440"></a>    /*
<a name="441"></a>     *   Vector for the full score achievement list.  This is a list of
<a name="442"></a>     *   all of the Achievement objects awarded for accomplishments so
<a name="443"></a>     *   far.
<a name="444"></a>     */
<a name="445"></a>    fullScoreList = static new Vector(32)
<a name="446"></a>
<a name="447"></a>    /* the total number of points scored so far */
<a name="448"></a>    totalScore = 0
<a name="449"></a>
<a name="450"></a>    /*
<a name="451"></a>     *   current score notification status - if on, we'll show a message at
<a name="452"></a>     *   the end of each turn where the score changes, otherwise we won't
<a name="453"></a>     *   mention anything
<a name="454"></a>     */
<a name="455"></a>    scoreNotify = scoreNotifySettingsItem
<a name="456"></a>
<a name="457"></a>    /*
<a name="458"></a>     *   Compute the sum of the maximum point values of the Achievement
<a name="459"></a>     *   objects in the game.  Point values are optional in Achievement
<a name="460"></a>     *   objects; if there are no Achievement objects with non-nil point
<a name="461"></a>     *   values, this will simply return nil.
<a name="462"></a>     */
<a name="463"></a>    calcMaxScore()
<a name="464"></a>    {
<a name="465"></a>        local sum;
<a name="466"></a>        local found;
<a name="467"></a>
<a name="468"></a>        /* start with a running total of zero */
<a name="469"></a>        sum = 0;
<a name="470"></a>
<a name="471"></a>        /* we haven't found any non-nil point values yet */
<a name="472"></a>        found = nil;
<a name="473"></a>
<a name="474"></a>        /*
<a name="475"></a>         *   Run through all of the Achievement objects to see if we can
<a name="476"></a>         *   derive a maximum score for the game.
<a name="477"></a>         */
<a name="478"></a>        forEachInstance(Achievement, function(obj) {
<a name="479"></a>            local m;
<a name="480"></a>
<a name="481"></a>            /*
<a name="482"></a>             *   If this object has a non-nil maxPoints value, add it to
<a name="483"></a>             *   the running total.
<a name="484"></a>             */
<a name="485"></a>            if ((m = obj.maxPoints) != nil)
<a name="486"></a>            {
<a name="487"></a>                /* add this one to the sum */
<a name="488"></a>                sum += m;
<a name="489"></a>
<a name="490"></a>                /* note that we found one with a non-nil point value */
<a name="491"></a>                found = true;
<a name="492"></a>            }
<a name="493"></a>        });
<a name="494"></a>
<a name="495"></a>        /*
<a name="496"></a>         *   If we found any Achievements with point values, return the sum
<a name="497"></a>         *   of those point values; otherwise, return nil.
<a name="498"></a>         */
<a name="499"></a>        return (found ? sum : nil);
<a name="500"></a>    }
<a name="501"></a>
<a name="502"></a>    /* execute pre-initialization */
<a name="503"></a>    execute()
<a name="504"></a>    {
<a name="505"></a>        /* register as the global score handler */
<a name="506"></a>        libGlobal.scoreObj = self;
<a name="507"></a>    }
<a name="508"></a>;
<a name="509"></a>
<a name="510"></a>/* settings item for score notification mode */
<a name="511"></a>scoreNotifySettingsItem: BinarySettingsItem
<a name="512"></a>    /* the "factory setting" for NOTIFY is ON */
<a name="513"></a>    isOn = true
<a name="514"></a>
<a name="515"></a>    /* our configuration file variable ID */
<a name="516"></a>    settingID = 'adv3.notify'
<a name="517"></a>
<a name="518"></a>    /* show our description */
<a name="519"></a>    settingDesc = (gLibMessages.shortNotifyStatus(isOn))
<a name="520"></a>;
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
