<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>resolver.t</title></head><body>
<table class=ban><tr><td><h1>resolver.t</h1><td align=right><a href="../file/resolver.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library: Resolvers.
<a name="7"></a> *
<a name="8"></a> *   This module defines the Resolver classes.  A Resolver is an abstract
<a name="9"></a> *   object that the parser uses to control the resolution of noun phrases
<a name="10"></a> *   to game objects.  Specialized Resolver subclasses allow noun phrases
<a name="11"></a> *   to be resolved differently according to their grammatical function in
<a name="12"></a> *   a command.
<a name="13"></a> */
<a name="14"></a>
<a name="15"></a>#include "adv3.h"
<a name="16"></a>
<a name="17"></a>
<a name="18"></a>/* ------------------------------------------------------------------------ */
<a name="19"></a>/*
<a name="20"></a> *   Basic object resolver.  An Action object creates an object resolver
<a name="21"></a> *   to mediate the process of resolving noun phrases to objects.
<a name="22"></a> *
<a name="23"></a> *   A resolver encapsulates a set of object resolution rules.  In most
<a name="24"></a> *   cases, an action that takes only a direct object can be its own
<a name="25"></a> *   resolver, because it needs only one set of resolution rules; for this
<a name="26"></a> *   reason, this basic Resolver implementation is designed to work with
<a name="27"></a> *   the direct object.  Actions with multiple objects will need separate
<a name="28"></a> *   resolvers for each object, since they might want to use different
<a name="29"></a> *   rules for the different objects.
<a name="30"></a> */
<a name="31"></a>class Resolver: object
<a name="32"></a>    construct(action, issuingActor, targetActor)
<a name="33"></a>    {
<a name="34"></a>        /* remember my action and actor objects */
<a name="35"></a>        action_ = action;
<a name="36"></a>        issuer_ = issuingActor;
<a name="37"></a>        actor_ = targetActor;
<a name="38"></a>
<a name="39"></a>        /* cache the scope list */
<a name="40"></a>        cacheScopeList();
<a name="41"></a>    }
<a name="42"></a>
<a name="43"></a>    /*
<a name="44"></a>     *   Are we a sub-phrase resolver?  This should return true if we're
<a name="45"></a>     *   being used to resolve a sub-phrase of the main phrase.
<a name="46"></a>     */
<a name="47"></a>    isSubResolver = nil
<a name="48"></a>
<a name="49"></a>    /*
<a name="50"></a>     *   Reset the resolver - this can be called if we are to re-use the
<a name="51"></a>     *   same resolver to resolve a list of noun phrases again.
<a name="52"></a>     */
<a name="53"></a>    resetResolver()
<a name="54"></a>    {
<a name="55"></a>        /* forget the equivalents we've resolved so far */
<a name="56"></a>        equivs_ = nil;
<a name="57"></a>    }
<a name="58"></a>
<a name="59"></a>    /* get the action we're resolving */
<a name="60"></a>    getAction() { return action_; }
<a name="61"></a>
<a name="62"></a>    /* get the target actor */
<a name="63"></a>    getTargetActor() { return actor_; }
<a name="64"></a>
<a name="65"></a>    /*
<a name="66"></a>     *   Match an object's name.  By default, we'll call the object's own
<a name="67"></a>     *   matchName method with the given original and adjusted token
<a name="68"></a>     *   lists.  Subclasses can override this to call different match
<a name="69"></a>     *   methods (such as matchNameDisambig).
<a name="70"></a>     */
<a name="71"></a>    matchName(obj, origTokens, adjustedTokens)
<a name="72"></a>    {
<a name="73"></a>        return obj.matchName(origTokens, adjustedTokens);
<a name="74"></a>    }
<a name="75"></a>
<a name="76"></a>    /*
<a name="77"></a>     *   Get the resolver for qualifier phrases.  By default, this simply
<a name="78"></a>     *   returns myself, since the resolver for qualifiers is in most
<a name="79"></a>     *   contexts the same as the main resolver.
<a name="80"></a>     *
<a name="81"></a>     *   This can be overridden in contexts where the qualifier resolver
<a name="82"></a>     *   is different from the main resolver.  In general, when a
<a name="83"></a>     *   sub-resolver narrows the scope for resolving a phrase, such as an
<a name="84"></a>     *   exclusion list or a disambiguation response, we will want to
<a name="85"></a>     *   resolve qualifiers in the context of the main resolution scope
<a name="86"></a>     *   rather than the narrowed scope.
<a name="87"></a>     */
<a name="88"></a>    getQualifierResolver() { return self; }
<a name="89"></a>
<a name="90"></a>    /*
<a name="91"></a>     *   Get the resolver for possessive phrases.  By default, we return a
<a name="92"></a>     *   standard possessive resolver.  This can be overridden in contexts
<a name="93"></a>     *   wher ethe possesive resolution context is special.
<a name="94"></a>     */
<a name="95"></a>    getPossessiveResolver() { return new PossessiveResolver(self); }
<a name="96"></a>
<a name="97"></a>    /*
<a name="98"></a>     *   Cache the scope list for this object.  By default, we cache the
<a name="99"></a>     *   standard physical scope list for our target actor.
<a name="100"></a>     *
<a name="101"></a>     *   Note that if a subclass uses completely different rules for
<a name="102"></a>     *   determining scope, it need not store a scope_ list at all.  The
<a name="103"></a>     *   scope_ list is purely an implementation detail of the base
<a name="104"></a>     *   Resolver class.  A subclass can use whatever internal
<a name="105"></a>     *   implementation it wants, as long as it overrides objInScope() and
<a name="106"></a>     *   getScopeList() to return consistent results.
<a name="107"></a>     */
<a name="108"></a>    cacheScopeList()
<a name="109"></a>    {
<a name="110"></a>        /* cache our actor's default scope list */
<a name="111"></a>        scope_ = actor_.scopeList();
<a name="112"></a>    }
<a name="113"></a>
<a name="114"></a>    /*
<a name="115"></a>     *   Determine if an object is in scope for the purposes of object
<a name="116"></a>     *   resolution.  By default, we'll return true if the object is in our
<a name="117"></a>     *   cached scope list - this ensures that we produce results that are
<a name="118"></a>     *   consistent with getScopeList().
<a name="119"></a>     *
<a name="120"></a>     *   Some subclasses might want to override this method to decide on
<a name="121"></a>     *   scope without reference to a cached scope list, for efficiency
<a name="122"></a>     *   reasons.  For example, if a command's scope is the set of all
<a name="123"></a>     *   objects, caching the full list would take a lot of memory; to save
<a name="124"></a>     *   the memory, you could override cacheScopeList() to do nothing at
<a name="125"></a>     *   all, and then override objInScope() to return true - this will
<a name="126"></a>     *   report that every object is in scope without bothering to store a
<a name="127"></a>     *   list of every object.
<a name="128"></a>     *
<a name="129"></a>     *   Be aware that if you override objInScope(), you should ensure that
<a name="130"></a>     *   getScopeList() yields consistent results.  In particular,
<a name="131"></a>     *   objInScope() should return true for every object in the list
<a name="132"></a>     *   returned by getScopeList() (although getScopeList() doesn't
<a name="133"></a>     *   necessarily have to return every object for which objInScope() is
<a name="134"></a>     *   true).
<a name="135"></a>     */
<a name="136"></a>    objInScope(obj) { return scope_.indexOf(obj) != nil; }
<a name="137"></a>
<a name="138"></a>    /*
<a name="139"></a>     *   Get the full list of objects in scope.  By default, this simply
<a name="140"></a>     *   returns our cached scope list.
<a name="141"></a>     *
<a name="142"></a>     *   For every object in the list that getScopeList() returns,
<a name="143"></a>     *   objInScope() must return true.  However, getScopeList() need not
<a name="144"></a>     *   return *all* objects that are in scope as far as objInScope() is
<a name="145"></a>     *   concerned - it can, but a subset of in-scope objects is
<a name="146"></a>     *   sufficient.
<a name="147"></a>     *
<a name="148"></a>     *   The default implementation returns the complete set of in-scope
<a name="149"></a>     *   objects by simply returning the cached scope list.  This is the
<a name="150"></a>     *   same scope list that the default objInScope() checks, which
<a name="151"></a>     *   ensures that the two methods produce consistent results.
<a name="152"></a>     *
<a name="153"></a>     *   The reason that it's okay for this method to return a subset of
<a name="154"></a>     *   in-scope objects is that the result is only used to resolve
<a name="155"></a>     *   "wildcard" phrases in input, and such phrases don't have to expand
<a name="156"></a>     *   to every possible object.  Examples of wildcard phrases include
<a name="157"></a>     *   ALL, missing phrases that need default objects, and locational
<a name="158"></a>     *   phrases ("the vase on the table" - which isn't superficially a
<a name="159"></a>     *   wildcard, but implicitly contains one in the form of "considering
<a name="160"></a>     *   only everything on the table").  It's perfectly reasonable for the
<a name="161"></a>     *   parser to expand a wildcard based on what's actually in sight, in
<a name="162"></a>     *   mind, or whatever's appropriate.  So, in cases where you define an
<a name="163"></a>     *   especially expansive objInScope() - for example, a universal scope
<a name="164"></a>     *   like the one TopicResolver uses - it's usually fine to use the
<a name="165"></a>     *   default definition of getScopeList(), which returns only the
<a name="166"></a>     *   objects that are in the smaller physical scope.
<a name="167"></a>     */
<a name="168"></a>    getScopeList() { return scope_; }
<a name="169"></a>
<a name="170"></a>    /*
<a name="171"></a>     *   Is this a "global" scope?  By default, the scope is local: it's
<a name="172"></a>     *   limited to what the actor can see, hear, etc.  In some cases, the
<a name="173"></a>     *   scope is broader, and extends beyond the senses; we call those
<a name="174"></a>     *   cases global scope.
<a name="175"></a>     *
<a name="176"></a>     *   This is an advisory status only.  The caller musn't take this to
<a name="177"></a>     *   mean that everything is in scope; objInScope() and getScopeList()
<a name="178"></a>     *   must still be used to make the exact determination of what objects
<a name="179"></a>     *   are in scope.  However, some noun phrase productions might wish to
<a name="180"></a>     *   know generally whether we're in a local or global sort of scope,
<a name="181"></a>     *   so that they can adjust their zeal at reducing ambiguity.  In
<a name="182"></a>     *   cases of global scope, we generally want to be more inclusive of
<a name="183"></a>     *   possible matches than in local scopes, because we have much less
<a name="184"></a>     *   of a basis to guess about what the player might mean.
<a name="185"></a>     */
<a name="186"></a>    isGlobalScope = nil
<a name="187"></a>
<a name="188"></a>    /*
<a name="189"></a>     *   Get the binding for a reflexive third-person pronoun (himself,
<a name="190"></a>     *   herself, itself, themselves).  By default, the reflexive binding
<a name="191"></a>     *   is the anaphoric binding from the action - that is, it refers
<a name="192"></a>     *   back to the preceding noun phrase in a verb phrase with multiple
<a name="193"></a>     *   noun slots (as in ASK BOB ABOUT HIMSELF: 'himself' refers back to
<a name="194"></a>     *   'bob', the previous noun phrase).
<a name="195"></a>     */
<a name="196"></a>    getReflexiveBinding(typ) { return getAction().getAnaphoricBinding(typ); }
<a name="197"></a>
<a name="198"></a>    /*
<a name="199"></a>     *   Resolve a pronoun antecedent, given a pronoun selector.  This
<a name="200"></a>     *   returns a list of ResolveInfo objects, for use in object
<a name="201"></a>     *   resolution.  'poss' is true if this is a possessive pronoun (his,
<a name="202"></a>     *   her, its, etc), nil if it's an ordinary, non-possessive pronoun
<a name="203"></a>     *   (him, her, it, etc).
<a name="204"></a>     */
<a name="205"></a>    resolvePronounAntecedent(typ, np, results, poss)
<a name="206"></a>    {
<a name="207"></a>        local lst;
<a name="208"></a>        local scopeLst;
<a name="209"></a>
<a name="210"></a>        /* check the Action for a special override for the pronoun */
<a name="211"></a>        lst = getAction().getPronounOverride(typ);
<a name="212"></a>
<a name="213"></a>        /* if there's no override, get the standard raw antecedent list */
<a name="214"></a>        if (lst == nil)
<a name="215"></a>            lst = getRawPronounAntecedent(typ);
<a name="216"></a>
<a name="217"></a>        /* if there is no antecedent, return an empty list */
<a name="218"></a>        if (lst != nil &amp;&amp; lst != [])
<a name="219"></a>        {
<a name="220"></a>            local cur;
<a name="221"></a>
<a name="222"></a>            /* if it's a single object, turn it into a list */
<a name="223"></a>            if (dataType(lst) == TypeObject)
<a name="224"></a>                lst = [lst];
<a name="225"></a>
<a name="226"></a>            /* add any extra objects for the pronoun binding */
<a name="227"></a>            foreach (cur in lst)
<a name="228"></a>                lst = cur.expandPronounList(typ, lst);
<a name="229"></a>
<a name="230"></a>            /* filter the list to keep only in-scope objects */
<a name="231"></a>            scopeLst = new Vector(lst.length());
<a name="232"></a>            foreach (cur in lst)
<a name="233"></a>            {
<a name="234"></a>                local facets;
<a name="235"></a>
<a name="236"></a>                /* get the object's facets */
<a name="237"></a>                facets = cur.getFacets();
<a name="238"></a>
<a name="239"></a>                /*
<a name="240"></a>                 *   If it has any, pick the best one that's in scope.  If
<a name="241"></a>                 *   not, keep the object only if it's in scope.
<a name="242"></a>                 */
<a name="243"></a>                if (facets.length() != 0)
<a name="244"></a>                {
<a name="245"></a>                    local best;
<a name="246"></a>
<a name="247"></a>                    /*
<a name="248"></a>                     *   This object has other facets, so we want to
<a name="249"></a>                     *   consider the other in-scope facets in case any are
<a name="250"></a>                     *   more suitable than the original one.  For example,
<a name="251"></a>                     *   we might have just referred to a door, and then
<a name="252"></a>                     *   traveled through the door to an adjoining room.
<a name="253"></a>                     *   We now want the antecedent to be the side (facet)
<a name="254"></a>                     *   of the door that's in the new location.
<a name="255"></a>                     */
<a name="256"></a>
<a name="257"></a>                    /* get the in-scope subset of the facets */
<a name="258"></a>                    facets = (facets + cur).subset({x: objInScope(x)});
<a name="259"></a>
<a name="260"></a>                    /* keep the best facet from the list */
<a name="261"></a>                    best = findBestFacet(actor_, facets);
<a name="262"></a>
<a name="263"></a>                    /*
<a name="264"></a>                     *   If we found a winner, use it instead of the
<a name="265"></a>                     *   original.
<a name="266"></a>                     */
<a name="267"></a>                    if (best != nil)
<a name="268"></a>                        cur = best;
<a name="269"></a>                }
<a name="270"></a>
<a name="271"></a>                /* if the object is in scope, include it in the results */
<a name="272"></a>                if (objInScope(cur))
<a name="273"></a>                    scopeLst.append(cur);
<a name="274"></a>            }
<a name="275"></a>
<a name="276"></a>            /* create a list of ResolveInfo objects from the antecedents */
<a name="277"></a>            lst = scopeLst.toList().mapAll({x: new ResolveInfo(x, 0, np)});
<a name="278"></a>        }
<a name="279"></a>
<a name="280"></a>        /*
<a name="281"></a>         *   If there's nothing matching in scope, try to find a default.
<a name="282"></a>         *   Look to see if there's a unique default object matching the
<a name="283"></a>         *   pronoun, and select it if so.
<a name="284"></a>         */
<a name="285"></a>        if (lst == nil || lst == [])
<a name="286"></a>            lst = getPronounDefault(typ, np);
<a name="287"></a>
<a name="288"></a>        /* run the normal resolution list filtering on the list */
<a name="289"></a>        lst = action_.finishResolveList(lst, whichObject, np, nil);
<a name="290"></a>
<a name="291"></a>        /* return the result */
<a name="292"></a>        return lst;
<a name="293"></a>    }
<a name="294"></a>
<a name="295"></a>    /*
<a name="296"></a>     *   Get the "raw" pronoun antecedent list for a given pronoun
<a name="297"></a>     *   selector.  This returns a list of objects matching the pronoun.
<a name="298"></a>     *   The list is raw in that it is given as a list of game objects
<a name="299"></a>     *   (not ResolveInfo objects), and it isn't filtered for scope.
<a name="300"></a>     */
<a name="301"></a>    getRawPronounAntecedent(typ)
<a name="302"></a>    {
<a name="303"></a>        /* check for pronouns that are relative to the issuer or target */
<a name="304"></a>        switch(typ)
<a name="305"></a>        {
<a name="306"></a>        case PronounMe:
<a name="307"></a>            /*
<a name="308"></a>             *   It's a first-person construction.  If the issuing actor is
<a name="309"></a>             *   the player character, and we don't treat you/me as
<a name="310"></a>             *   interchangeable, this refers to the player character only
<a name="311"></a>             *   if the game refers to the player character in the second
<a name="312"></a>             *   person (so, if the game calls the PC "you", the player
<a name="313"></a>             *   calls the PC "me").  If the issuing actor isn't the player
<a name="314"></a>             *   character, then a first-person pronoun refers to the
<a name="315"></a>             *   command's issuer.  If we allow you/me mixing, then "me"
<a name="316"></a>             *   always means the PC in input, no matter how the game
<a name="317"></a>             *   refers to the PC in output.
<a name="318"></a>             */
<a name="319"></a>            if (issuer_.isPlayerChar
<a name="320"></a>                &amp;&amp; issuer_.referralPerson != SecondPerson
<a name="321"></a>                &amp;&amp; !gameMain.allowYouMeMixing)
<a name="322"></a>            {
<a name="323"></a>                /*
<a name="324"></a>                 *   the issuer is the player, but the game doesn't call
<a name="325"></a>                 *   the PC "you", so "me" has no meaning
<a name="326"></a>                 */
<a name="327"></a>                return [];
<a name="328"></a>            }
<a name="329"></a>            else
<a name="330"></a>            {
<a name="331"></a>                /* "me" refers to the command's issuer */
<a name="332"></a>                return [issuer_];
<a name="333"></a>            }
<a name="334"></a>
<a name="335"></a>        case PronounYou:
<a name="336"></a>            /*
<a name="337"></a>             *   It's a second-person construction.  If the target actor is
<a name="338"></a>             *   the player character, and we don't treat you/me as
<a name="339"></a>             *   interchangeable, this refers to the player character only
<a name="340"></a>             *   if the game refers to the player character in the first
<a name="341"></a>             *   person (so, if the game calls the PC "me", then the player
<a name="342"></a>             *   calls the PC "you").  If we allow you/me mixing, "you" is
<a name="343"></a>             *   always the PC in input, no matter how the game refers to
<a name="344"></a>             *   the PC in output.
<a name="345"></a>             *
<a name="346"></a>             *   If the target actor isn't the player character, then a
<a name="347"></a>             *   second-person pronoun refers to either the target actor or
<a name="348"></a>             *   to the player character, depending on the referral person
<a name="349"></a>             *   of the current command that's targeting the actor.  If the
<a name="350"></a>             *   command is in the second person, then a second-person
<a name="351"></a>             *   pronoun refers to the actor ("bob, hit you" means for Bob
<a name="352"></a>             *   to hit himself).  If the command is in the third person,
<a name="353"></a>             *   then a second-person pronoun is a bit weird, but probably
<a name="354"></a>             *   refers to the player character ("tell bob to hit you"
<a name="355"></a>             *   means for Bob to hit the PC).
<a name="356"></a>             */
<a name="357"></a>            if (actor_.isPlayerChar
<a name="358"></a>                &amp;&amp; actor_.referralPerson != FirstPerson
<a name="359"></a>                &amp;&amp; !gameMain.allowYouMeMixing)
<a name="360"></a>            {
<a name="361"></a>                /*
<a name="362"></a>                 *   the target is the player character, but the game
<a name="363"></a>                 *   doesn't call the PC "me", so "you" has no meaning in
<a name="364"></a>                 *   this command
<a name="365"></a>                 */
<a name="366"></a>                return [];
<a name="367"></a>            }
<a name="368"></a>            else if (actor_.commandReferralPerson == ThirdPerson)
<a name="369"></a>            {
<a name="370"></a>                /*
<a name="371"></a>                 *   we're addressing the actor in the third person, so YOU
<a name="372"></a>                 *   probably doesn't refer to the target actor; the only
<a name="373"></a>                 *   other real possibility is that it refers to the player
<a name="374"></a>                 *   character
<a name="375"></a>                 */
<a name="376"></a>                return [gPlayerChar];
<a name="377"></a>            }
<a name="378"></a>            else
<a name="379"></a>            {
<a name="380"></a>                /* in other cases, "you" refers to the command's target */
<a name="381"></a>                return [actor_];
<a name="382"></a>            }
<a name="383"></a>
<a name="384"></a>        default:
<a name="385"></a>            /*
<a name="386"></a>             *   it's not a relative pronoun, so ask the target actor for
<a name="387"></a>             *   the antecedent based on recent commands
<a name="388"></a>             */
<a name="389"></a>            return actor_.getPronounAntecedent(typ);
<a name="390"></a>        }
<a name="391"></a>    }
<a name="392"></a>
<a name="393"></a>    /*
<a name="394"></a>     *   Determine if "all" is allowed for the noun phrase we're resolving.
<a name="395"></a>     *   By default, we'll just ask the action.
<a name="396"></a>     */
<a name="397"></a>    allowAll()
<a name="398"></a>    {
<a name="399"></a>        /* ask the action to determine whether or not "all" is allowed */
<a name="400"></a>        return action_.actionAllowsAll;
<a name="401"></a>    }
<a name="402"></a>
<a name="403"></a>    /*
<a name="404"></a>     *   Get the "all" list - this is the list of objects that we should
<a name="405"></a>     *   use when the object of the command is the special word "all".
<a name="406"></a>     *   We'll ask the action to resolve 'all' for the direct object,
<a name="407"></a>     *   since we are by default a direct object resolver.
<a name="408"></a>     */
<a name="409"></a>    getAll(np)
<a name="410"></a>    {
<a name="411"></a>        /*
<a name="412"></a>         *   ask the action to resolve 'all' for the direct object, and
<a name="413"></a>         *   then filter the list and return the result
<a name="414"></a>         */
<a name="415"></a>        return filterAll(action_.getAllDobj(actor_, getScopeList()),
<a name="416"></a>                         DirectObject, np);
<a name="417"></a>    }
<a name="418"></a>
<a name="419"></a>    /*
<a name="420"></a>     *   Filter an 'all' list to remove things that don't belong.  We
<a name="421"></a>     *   always remove the actor executing the command, as well as any
<a name="422"></a>     *   objects explicitly marked as hidden from 'all' lists.
<a name="423"></a>     *
<a name="424"></a>     *   Returns a ResolveInfo list, with each entry marked with the
<a name="425"></a>     *   MatchedAll flag.
<a name="426"></a>     */
<a name="427"></a>    filterAll(lst, whichObj, np)
<a name="428"></a>    {
<a name="429"></a>        local result;
<a name="430"></a>
<a name="431"></a>        /* set up a vector to hold the result */
<a name="432"></a>        result = new Vector(lst.length());
<a name="433"></a>
<a name="434"></a>        /*
<a name="435"></a>         *   run through the list and include elements that we don't want
<a name="436"></a>         *   to exclude
<a name="437"></a>         */
<a name="438"></a>        foreach (local cur in lst)
<a name="439"></a>        {
<a name="440"></a>            /*
<a name="441"></a>             *   if this item isn't the actor, and isn't marked for
<a name="442"></a>             *   exclusion from 'all' lists in general, include it
<a name="443"></a>             */
<a name="444"></a>            if (cur != actor_ &amp;&amp; !cur.hideFromAll(getAction()))
<a name="445"></a>                result.append(cur);
<a name="446"></a>        }
<a name="447"></a>
<a name="448"></a>        /*
<a name="449"></a>         *   create a ResolveInfo for each object, with the 'MatchedAll'
<a name="450"></a>         *   flag set for each object
<a name="451"></a>         */
<a name="452"></a>        result.applyAll({x: new ResolveInfo(x, MatchedAll, np)});
<a name="453"></a>
<a name="454"></a>        /* run through the list and apply each object's own filtering */
<a name="455"></a>        result = getAction().finishResolveList(result, whichObject, np, nil);
<a name="456"></a>
<a name="457"></a>        /* return the result as a list */
<a name="458"></a>        return result.toList();
<a name="459"></a>    }
<a name="460"></a>
<a name="461"></a>    /*
<a name="462"></a>     *   Get the list of potential default objects.  This is simply the
<a name="463"></a>     *   basic 'all' list, not filtered for exclusion with hideFromAll.
<a name="464"></a>     */
<a name="465"></a>    getAllDefaults()
<a name="466"></a>    {
<a name="467"></a>        /* ask the action to resolve 'all' for the direct object */
<a name="468"></a>        local lst = action_.getAllDobj(actor_, getScopeList());
<a name="469"></a>
<a name="470"></a>        /* return the results as ResolveInfo objects */
<a name="471"></a>        return lst.mapAll({x: new ResolveInfo(x, 0, nil)});
<a name="472"></a>    }
<a name="473"></a>
<a name="474"></a>    /*
<a name="475"></a>     *   Filter an ambiguous list of objects ('lst') resolving to a noun
<a name="476"></a>     *   phrase.  If the objects in the list vary in the degree of
<a name="477"></a>     *   suitability for the command, returns a list consisting only of the
<a name="478"></a>     *   most suitable objects.  If the objects are all equally suitable -
<a name="479"></a>     *   or equally unsuitable - the whole list should be returned
<a name="480"></a>     *   unchanged.
<a name="481"></a>     *
<a name="482"></a>     *   'requiredNum' is the number of objects required in the final list
<a name="483"></a>     *   by the caller; if the result list is larger than this, the caller
<a name="484"></a>     *   will consider the results ambiguous.
<a name="485"></a>     *
<a name="486"></a>     *   'np' is the noun phrase production that we're resolving.  This is
<a name="487"></a>     *   usually a subclass of NounPhraseProd.
<a name="488"></a>     *
<a name="489"></a>     *   This routine does NOT perform any interactive disambiguation, but
<a name="490"></a>     *   is merely a first attempt at reducing the number of matching
<a name="491"></a>     *   objects by removing the obviously unsuitable ones.
<a name="492"></a>     *
<a name="493"></a>     *   For example, for an "open" command, if the list consists of one
<a name="494"></a>     *   object that's open and one object that's currently closed, the
<a name="495"></a>     *   result list should include only the closed one, since it is
<a name="496"></a>     *   obvious that the one that's already open does not need to be
<a name="497"></a>     *   opened again.  On the other hand, if the list consists only of
<a name="498"></a>     *   open objects, they should all be returned, since they're all
<a name="499"></a>     *   equally unsuitable.
<a name="500"></a>     *
<a name="501"></a>     *   It is not necessary to reduce the list to a single entry; it is
<a name="502"></a>     *   adequate merely to reduce the ambiguity by removing any items that
<a name="503"></a>     *   are clearly less suitable than the survivors.
<a name="504"></a>     */
<a name="505"></a>    filterAmbiguousNounPhrase(lst, requiredNum, np)
<a name="506"></a>    {
<a name="507"></a>        return withGlobals(
<a name="508"></a>            {:action_.filterAmbiguousDobj(lst, requiredNum, np)});
<a name="509"></a>    }
<a name="510"></a>
<a name="511"></a>    /*
<a name="512"></a>     *   Filter an ambiguous noun phrase list using the strength of
<a name="513"></a>     *   possessive qualification, if any.  If we have subsets at
<a name="514"></a>     *   different possessive strengths, choose the strongest subset that
<a name="515"></a>     *   has at least the required number of objects.
<a name="516"></a>     */
<a name="517"></a>    filterPossRank(lst, num)
<a name="518"></a>    {
<a name="519"></a>        local sub1 = lst.subset({x: x.possRank_ &gt;= 1});
<a name="520"></a>        local sub2 = lst.subset({x: x.possRank_ &gt;= 2});
<a name="521"></a>
<a name="522"></a>        /*
<a name="523"></a>         *   sub2 is the subset with rank 2; if this meets our needs,
<a name="524"></a>         *   return it.  If sub2 doesn't meet our needs, then check to see
<a name="525"></a>         *   if sub1 does; sub1 is the subset with rank 1 or higher.  If
<a name="526"></a>         *   neither subset meets our needs, use the original list.
<a name="527"></a>         */
<a name="528"></a>        if (sub2.length() &gt;= num)
<a name="529"></a>            return sub2;
<a name="530"></a>        else if (sub1.length() &gt;= num)
<a name="531"></a>            return sub1;
<a name="532"></a>        else
<a name="533"></a>            return lst;
<a name="534"></a>    }
<a name="535"></a>
<a name="536"></a>    /*
<a name="537"></a>     *   Filter a list of ambiguous matches ('lst') for a noun phrase, to
<a name="538"></a>     *   reduce each set of equivalent items to a single such item, if
<a name="539"></a>     *   desired.  If no equivalent reduction is desired for this type of
<a name="540"></a>     *   resolver, this can simply return the original list.
<a name="541"></a>     *
<a name="542"></a>     *   'np' is the noun phrase production that we're resolving.  This is
<a name="543"></a>     *   usually a subclass of NounPhraseProd.
<a name="544"></a>     */
<a name="545"></a>    filterAmbiguousEquivalents(lst, np)
<a name="546"></a>    {
<a name="547"></a>        /* if we have only one item, there's obviously nothing redundant */
<a name="548"></a>        if (lst.length() == 1)
<a name="549"></a>            return lst;
<a name="550"></a>
<a name="551"></a>        /* scan the list, looking for equivalents */
<a name="552"></a>        for (local i = 1, local len = lst.length() ; i &lt;= len ; ++i)
<a name="553"></a>        {
<a name="554"></a>            /*
<a name="555"></a>             *   if this item is marked as equivalent, check for others
<a name="556"></a>             *   like it
<a name="557"></a>             */
<a name="558"></a>            if (lst[i].obj_.isEquivalent)
<a name="559"></a>            {
<a name="560"></a>                /*
<a name="561"></a>                 *   If this object is in our list of previously-used
<a name="562"></a>                 *   equivalents, and we have more equivalents to this
<a name="563"></a>                 *   object in our list, then omit this one, so that we
<a name="564"></a>                 *   keep a different equivalent this time.  This way, if
<a name="565"></a>                 *   we have a noun list such as "take coin and coin",
<a name="566"></a>                 *   we'll return different equivalent items for each
<a name="567"></a>                 *   equivalent noun phrase.
<a name="568"></a>                 */
<a name="569"></a>                if (equivs_ != nil
<a name="570"></a>                    &amp;&amp; equivs_.indexOf(lst[i].obj_) != nil
<a name="571"></a>                    &amp;&amp; lst.lastIndexWhich(
<a name="572"></a>                       {x: x.obj_.isVocabEquivalent(lst[i].obj_)}) &gt; i)
<a name="573"></a>                {
<a name="574"></a>                    /*
<a name="575"></a>                     *   we've already returned this one, and we have
<a name="576"></a>                     *   another equivalent later in the list that we can
<a name="577"></a>                     *   use instead this time - remove this one from the
<a name="578"></a>                     *   list
<a name="579"></a>                     */
<a name="580"></a>                    lst = lst.removeElementAt(i);
<a name="581"></a>
<a name="582"></a>                    /* adjust the our counters for the removal */
<a name="583"></a>                    --len;
<a name="584"></a>                    --i;
<a name="585"></a>                }
<a name="586"></a>                else
<a name="587"></a>                {
<a name="588"></a>                    /*
<a name="589"></a>                     *   We've decided to keep this element, either
<a name="590"></a>                     *   because we haven't already returned it as a match
<a name="591"></a>                     *   for this noun phrase, or because it's the last
<a name="592"></a>                     *   one of its kind.  Add it to the list of
<a name="593"></a>                     *   equivalents we've previously returned.
<a name="594"></a>                     */
<a name="595"></a>                    if (equivs_ == nil)
<a name="596"></a>                        equivs_ = new Vector(10);
<a name="597"></a>                    equivs_.append(lst[i].obj_);
<a name="598"></a>
<a name="599"></a>                    /*
<a name="600"></a>                     *   check each object at a higher index to see if
<a name="601"></a>                     *   it's equivalent to this one
<a name="602"></a>                     */
<a name="603"></a>                    for (local j = i + 1 ; j &lt;= len ; ++j)
<a name="604"></a>                    {
<a name="605"></a>                        /* check this object */
<a name="606"></a>                        if (lst[i].obj_.isVocabEquivalent(lst[j].obj_))
<a name="607"></a>                        {
<a name="608"></a>                            /* they match - remove the other one */
<a name="609"></a>                            lst = lst.removeElementAt(j);
<a name="610"></a>
<a name="611"></a>                            /* reduce the list length accordingly */
<a name="612"></a>                            --len;
<a name="613"></a>
<a name="614"></a>                            /* back up our scanning index as well */
<a name="615"></a>                            --j;
<a name="616"></a>                        }
<a name="617"></a>                    }
<a name="618"></a>                }
<a name="619"></a>            }
<a name="620"></a>        }
<a name="621"></a>
<a name="622"></a>        /* return the updated list */
<a name="623"></a>        return lst;
<a name="624"></a>    }
<a name="625"></a>
<a name="626"></a>    /*
<a name="627"></a>     *   Filter a plural phrase to reduce the set to the logical subset, if
<a name="628"></a>     *   possible.  If there is no logical subset, simply return the
<a name="629"></a>     *   original set.
<a name="630"></a>     *
<a name="631"></a>     *   'np' is the noun phrase we're resolving; this is usually a
<a name="632"></a>     *   subclass of PluralProd.
<a name="633"></a>     */
<a name="634"></a>    filterPluralPhrase(lst, np)
<a name="635"></a>    {
<a name="636"></a>        return withGlobals({:action_.filterPluralDobj(lst, np)});
<a name="637"></a>    }
<a name="638"></a>
<a name="639"></a>    /*
<a name="640"></a>     *   Select a resolution for an indefinite noun phrase ("a coin"),
<a name="641"></a>     *   given a list of possible matches.  The matches will be given to
<a name="642"></a>     *   us sorted from most likely to least likely, as done by
<a name="643"></a>     *   filterAmbiguousNounPhrase().
<a name="644"></a>     *
<a name="645"></a>     *   By default, we simply select the first 'n' items from the list
<a name="646"></a>     *   (which are the most likely matches), because in most contexts, an
<a name="647"></a>     *   indefinite noun phrase means that we should arbitrarily select
<a name="648"></a>     *   any matching object.  This can be overridden for contexts in
<a name="649"></a>     *   which indefinite noun phrases must be handled differently.
<a name="650"></a>     */
<a name="651"></a>    selectIndefinite(results, lst, requiredNumber)
<a name="652"></a>    {
<a name="653"></a>        /*
<a name="654"></a>         *   arbitrarily choose the first 'requiredNumber' item(s) from
<a name="655"></a>         *   the list
<a name="656"></a>         */
<a name="657"></a>        return lst.sublist(1, requiredNumber);
<a name="658"></a>    }
<a name="659"></a>
<a name="660"></a>    /*
<a name="661"></a>     *   Get the default object or objects for this phrase.  Returns a list
<a name="662"></a>     *   of ResolveInfo objects if a default is available, or nil if no
<a name="663"></a>     *   default is available.  This routine does not interact with the
<a name="664"></a>     *   user; it should merely determine if the command implies a default
<a name="665"></a>     *   strongly enough to assume it without asking the user.
<a name="666"></a>     *
<a name="667"></a>     *   By default, we ask the action for a default direct object.
<a name="668"></a>     *   Resolver subclasses should override this as appropriate for the
<a name="669"></a>     *   specific objects they're used to resolve.
<a name="670"></a>     */
<a name="671"></a>    getDefaultObject(np)
<a name="672"></a>    {
<a name="673"></a>        /* ask the action to provide a default direct object */
<a name="674"></a>        return withGlobals({:action_.getDefaultDobj(np, self)});
<a name="675"></a>    }
<a name="676"></a>
<a name="677"></a>    /*
<a name="678"></a>     *   Resolve a noun phrase involving unknown words, if possible.  If
<a name="679"></a>     *   it is not possible to resolve such a phrase, return nil;
<a name="680"></a>     *   otherwise, return a list of resolved objects.  This routine does
<a name="681"></a>     *   not interact with the user - "oops" prompting is handled
<a name="682"></a>     *   separately.
<a name="683"></a>     *
<a name="684"></a>     *   'tokList' is the token list for the phrase, in the canonical
<a name="685"></a>     *   format as returned from the tokenizer.  Each element of 'tokList'
<a name="686"></a>     *   is a sublist representing one token.
<a name="687"></a>     *
<a name="688"></a>     *   Note that this routine allows for specialized unknown word
<a name="689"></a>     *   resolution separately from the more general matchName mechanism.
<a name="690"></a>     *   The purpose of this method is to allow the specific type of
<a name="691"></a>     *   resolver to deal with unknown words specially, rather than using
<a name="692"></a>     *   the matchName mechanism.  This routine is called as a last
<a name="693"></a>     *   resort, only after the matchName mechanism fails to find any
<a name="694"></a>     *   matches.
<a name="695"></a>     */
<a name="696"></a>    resolveUnknownNounPhrase(tokList)
<a name="697"></a>    {
<a name="698"></a>        /* by default, we can't resolve an unknown noun phrase */
<a name="699"></a>        return nil;
<a name="700"></a>    }
<a name="701"></a>
<a name="702"></a>    /*
<a name="703"></a>     *   Execute a callback function in the global context of our actor
<a name="704"></a>     *   and action - we'll set gActor and gAction to our own stored actor
<a name="705"></a>     *   and action values, then call the callback, then restore the old
<a name="706"></a>     *   globals.
<a name="707"></a>     */
<a name="708"></a>    withGlobals(func)
<a name="709"></a>    {
<a name="710"></a>        /* invoke the function with our action and actor in the globals */
<a name="711"></a>        return withParserGlobals(issuer_, actor_, action_, func);
<a name="712"></a>    }
<a name="713"></a>
<a name="714"></a>    /* the role played by this object, if any */
<a name="715"></a>    whichObject = DirectObject
<a name="716"></a>
<a name="717"></a>    /*
<a name="718"></a>     *   Get an indication of which object we're resolving, for message
<a name="719"></a>     *   generation purposes.  By default, we'll indicate direct object;
<a name="720"></a>     *   this should be overridden for resolvers of indirect and other
<a name="721"></a>     *   types of objects.
<a name="722"></a>     */
<a name="723"></a>    whichMessageObject = DirectObject
<a name="724"></a>
<a name="725"></a>    /*
<a name="726"></a>     *   The cached scope list, if we have one.  Note that this is an
<a name="727"></a>     *   internal implementation detail of the base class; subclasses can
<a name="728"></a>     *   dispense with the cached scope list if they define their own
<a name="729"></a>     *   objInScope() and getScopeList() overrides.
<a name="730"></a>     *
<a name="731"></a>     *   Note that any subclasses (including Actions) that make changes to
<a name="732"></a>     *   this list MUST ensure that the result only contains unique
<a name="733"></a>     *   entries.  The library assumes in several places that there are no
<a name="734"></a>     *   duplicate entries in the list; subtle problems can occur if the
<a name="735"></a>     *   list contains any duplicates.
<a name="736"></a>     */
<a name="737"></a>    scope_ = []
<a name="738"></a>
<a name="739"></a>    /* my action */
<a name="740"></a>    action_ = nil
<a name="741"></a>
<a name="742"></a>    /* the issuing actor */
<a name="743"></a>    issuer_ = nil
<a name="744"></a>
<a name="745"></a>    /* the target actor object */
<a name="746"></a>    actor_ = nil
<a name="747"></a>
<a name="748"></a>    /*
<a name="749"></a>     *   List of equivalent objects we've resolved so far.  We use this to
<a name="750"></a>     *   try to return different equivalent objects when multiple noun
<a name="751"></a>     *   phrases refer to the same set of equivalents.
<a name="752"></a>     */
<a name="753"></a>    equivs_ = nil
<a name="754"></a>;
<a name="755"></a>
<a name="756"></a>/* ------------------------------------------------------------------------ */
<a name="757"></a>/*
<a name="758"></a> *   Proxy Resolver - this is used to create resolvers that refer methods
<a name="759"></a> *   not otherwise overridden back to an underlying resolver
<a name="760"></a> */
<a name="761"></a>class ProxyResolver: object
<a name="762"></a>    construct(origResolver)
<a name="763"></a>    {
<a name="764"></a>        /* remember my underlying resolver */
<a name="765"></a>        self.origResolver = origResolver;
<a name="766"></a>    }
<a name="767"></a>
<a name="768"></a>    /* delegate methods we don't override to the underlying resolver */
<a name="769"></a>    propNotDefined(prop, [args])
<a name="770"></a>    {
<a name="771"></a>        /* delegate the call to the original resolver */
<a name="772"></a>        return origResolver.(prop)(args...);
<a name="773"></a>    }
<a name="774"></a>
<a name="775"></a>    /* base our possessive resolver on the proxy */
<a name="776"></a>    getPossessiveResolver() { return new PossessiveResolver(self); }
<a name="777"></a>;
<a name="778"></a>
<a name="779"></a>/* ------------------------------------------------------------------------ */
<a name="780"></a>/*
<a name="781"></a> *   Basic resolver for indirect objects
<a name="782"></a> */
<a name="783"></a>class IobjResolver: Resolver
<a name="784"></a>    /*
<a name="785"></a>     *   we resolve indirect objects for message generation purposes
<a name="786"></a>     */
<a name="787"></a>    whichObject = IndirectObject
<a name="788"></a>    whichMessageObject = IndirectObject
<a name="789"></a>
<a name="790"></a>    /* resolve 'all' for the indirect object */
<a name="791"></a>    getAll(np)
<a name="792"></a>    {
<a name="793"></a>        /*
<a name="794"></a>         *   ask the action to resolve 'all' for the indirect object, and
<a name="795"></a>         *   then filter the list and return the result
<a name="796"></a>         */
<a name="797"></a>        return filterAll(action_.getAllIobj(actor_, getScopeList()),
<a name="798"></a>                         IndirectObject, np);
<a name="799"></a>    }
<a name="800"></a>
<a name="801"></a>    /* get all possible default objects */
<a name="802"></a>    getAllDefaults()
<a name="803"></a>    {
<a name="804"></a>        /* ask the action to resolve 'all' for the indirect object */
<a name="805"></a>        local lst = action_.getAllIobj(actor_, getScopeList());
<a name="806"></a>
<a name="807"></a>        /* return the results as ResolveInfo objects */
<a name="808"></a>        return lst.mapAll({x: new ResolveInfo(x, 0, nil)});
<a name="809"></a>    }
<a name="810"></a>
<a name="811"></a>    /* filter an ambiguous noun phrase */
<a name="812"></a>    filterAmbiguousNounPhrase(lst, requiredNum, np)
<a name="813"></a>    {
<a name="814"></a>        return withGlobals(
<a name="815"></a>            {:action_.filterAmbiguousIobj(lst, requiredNum, np)});
<a name="816"></a>    }
<a name="817"></a>
<a name="818"></a>    /*
<a name="819"></a>     *   Filter a plural phrase to reduce the set to the logical subset,
<a name="820"></a>     *   if possible.  If there is no logical subset, simply return the
<a name="821"></a>     *   original set.
<a name="822"></a>     */
<a name="823"></a>    filterPluralPhrase(lst, np)
<a name="824"></a>    {
<a name="825"></a>        return withGlobals({:action_.filterPluralIobj(lst, np)});
<a name="826"></a>    }
<a name="827"></a>
<a name="828"></a>    /*
<a name="829"></a>     *   Get the default object or objects for this phrase.  Since we
<a name="830"></a>     *   resolve indirect objects, we'll ask the action for a default
<a name="831"></a>     *   indirect object.
<a name="832"></a>     */
<a name="833"></a>    getDefaultObject(np)
<a name="834"></a>    {
<a name="835"></a>        /* ask the action to provide a default indirect object */
<a name="836"></a>        return withGlobals({:action_.getDefaultIobj(np, self)});
<a name="837"></a>    }
<a name="838"></a>;
<a name="839"></a>
<a name="840"></a>/* ------------------------------------------------------------------------ */
<a name="841"></a>/*
<a name="842"></a> *   Basic topic qualifier resolver.  This can be used to resolve qualifier
<a name="843"></a> *   phrases (such as possessives or locationals) within topic phrases.
<a name="844"></a> */
<a name="845"></a>class TopicQualifierResolver: Resolver
<a name="846"></a>    getAll(np)
<a name="847"></a>    {
<a name="848"></a>        /* 'all' doesn't make sense as a qualifier; return an empty list */
<a name="849"></a>        return [];
<a name="850"></a>    }
<a name="851"></a>
<a name="852"></a>    getAllDefaults()
<a name="853"></a>    {
<a name="854"></a>        /* we don't need defaults for a qualifier */
<a name="855"></a>        return [];
<a name="856"></a>    }
<a name="857"></a>
<a name="858"></a>    filterAmbiguousNounPhrase(lst, requiredNum, np)
<a name="859"></a>    {
<a name="860"></a>        /* we have no basis for any filtering; return the list unchanged */
<a name="861"></a>        return lst;
<a name="862"></a>    }
<a name="863"></a>
<a name="864"></a>    filterPluralPhrase(lst, np)
<a name="865"></a>    {
<a name="866"></a>        /* we have no basis for any filtering */
<a name="867"></a>        return lst;
<a name="868"></a>    }
<a name="869"></a>
<a name="870"></a>    getDefaultObject(np)
<a name="871"></a>    {
<a name="872"></a>        /* have have no way to pick a default */
<a name="873"></a>        return nil;
<a name="874"></a>    }
<a name="875"></a>;
<a name="876"></a>
<a name="877"></a>/* ------------------------------------------------------------------------ */
<a name="878"></a>/*
<a name="879"></a> *   Actor Resolver.  We use this to resolve the actor to whom a command
<a name="880"></a> *   is directed: the actor must be in scope for the player character.
<a name="881"></a> */
<a name="882"></a>class ActorResolver: Resolver
<a name="883"></a>    construct(issuingActor)
<a name="884"></a>    {
<a name="885"></a>        /* remember the issuing actor */
<a name="886"></a>        actor_ = issuingActor;
<a name="887"></a>
<a name="888"></a>        /*
<a name="889"></a>         *   Use our pseudo-action for "command actor" - this represents
<a name="890"></a>         *   the intermediate step where the issuing actor is doing
<a name="891"></a>         *   whatever physical activity is needed (such as talking) to give
<a name="892"></a>         *   the command to the target actor.  This isn't a real action;
<a name="893"></a>         *   it's just an implied intermediate step in the overall action.
<a name="894"></a>         *   We need this mostly because there are assumptions elsewhere in
<a name="895"></a>         *   the resolution process that there's a valid Action object
<a name="896"></a>         *   available.
<a name="897"></a>         */
<a name="898"></a>        action_ = CommandActorAction;
<a name="899"></a>
<a name="900"></a>        /* ...and the action needs an actor */
<a name="901"></a>        action_.actor_ = actor_;
<a name="902"></a>
<a name="903"></a>        /* cache the scope list for the actor who issued the command */
<a name="904"></a>        cacheScopeList();
<a name="905"></a>    }
<a name="906"></a>
<a name="907"></a>    /*
<a name="908"></a>     *   Get the "all" list - this is the list of objects that we should
<a name="909"></a>     *   use when the object of the command is the special word "all".  By
<a name="910"></a>     *   default, we'll return everything in scope.
<a name="911"></a>     */
<a name="912"></a>    getAll(np)
<a name="913"></a>    {
<a name="914"></a>        /* we can't address 'all' */
<a name="915"></a>        throw new ParseFailureException(&amp;cannotAddressMultiple);
<a name="916"></a>    }
<a name="917"></a>
<a name="918"></a>    /* get the default object list */
<a name="919"></a>    getAllDefaults()
<a name="920"></a>    {
<a name="921"></a>        /* there are no default actors */
<a name="922"></a>        return [];
<a name="923"></a>    }
<a name="924"></a>
<a name="925"></a>    /*
<a name="926"></a>     *   Filter an ambiguous list of objects.  We will filter according to
<a name="927"></a>     *   which objects are most logical as targets of commands.
<a name="928"></a>     */
<a name="929"></a>    filterAmbiguousNounPhrase(lst, requiredNum, np)
<a name="930"></a>    {
<a name="931"></a>        local likelyCnt;
<a name="932"></a>
<a name="933"></a>        /* give each object in the list a chance to filter the list */
<a name="934"></a>        lst = getAction().finishResolveList(lst, ActorObject,
<a name="935"></a>                                            np, requiredNum);
<a name="936"></a>
<a name="937"></a>        /*
<a name="938"></a>         *   Run through the list and see how many objects are likely
<a name="939"></a>         *   command targets.
<a name="940"></a>         */
<a name="941"></a>        likelyCnt = 0;
<a name="942"></a>        foreach (local cur in lst)
<a name="943"></a>        {
<a name="944"></a>            /* if it's a likely command target, count it */
<a name="945"></a>            if (cur.obj_.isLikelyCommandTarget)
<a name="946"></a>                ++likelyCnt;
<a name="947"></a>        }
<a name="948"></a>
<a name="949"></a>        /*
<a name="950"></a>         *   If some of the targets are likely and others aren't, and we
<a name="951"></a>         *   have at least the required number of likely targets, keep
<a name="952"></a>         *   only the likely ones.  If they're all likely or all unlikely,
<a name="953"></a>         *   it doesn't help us because we still have no basis for
<a name="954"></a>         *   choosing some over others; if removing unlikely ones would
<a name="955"></a>         *   not give us enough to meet the minimum number required it
<a name="956"></a>         *   also doesn't help, because we don't have a basis for
<a name="957"></a>         *   selecting as many as are needed.
<a name="958"></a>         */
<a name="959"></a>        if (likelyCnt != 0 &amp;&amp; likelyCnt != lst.length()
<a name="960"></a>            &amp;&amp; likelyCnt &gt;= requiredNum)
<a name="961"></a>        {
<a name="962"></a>            /*
<a name="963"></a>             *   we have a useful subset of likely ones - filter the list
<a name="964"></a>             *   down to the likely subset
<a name="965"></a>             */
<a name="966"></a>            lst = lst.subset({cur: cur.obj_.isLikelyCommandTarget});
<a name="967"></a>        }
<a name="968"></a>
<a name="969"></a>        /* return the result */
<a name="970"></a>        return lst;
<a name="971"></a>    }
<a name="972"></a>
<a name="973"></a>    /*
<a name="974"></a>     *   Filter a plural list
<a name="975"></a>     */
<a name="976"></a>    filterPluralPhrase(lst, np)
<a name="977"></a>    {
<a name="978"></a>        /*
<a name="979"></a>         *   Use the same filtering that we use for ambiguous nouns.  This
<a name="980"></a>         *   simply reduces the set to the likely command targets if any
<a name="981"></a>         *   are likely command targets.
<a name="982"></a>         */
<a name="983"></a>        return filterAmbiguousNounPhrase(lst, 1, np);
<a name="984"></a>    }
<a name="985"></a>
<a name="986"></a>    /* get a default object */
<a name="987"></a>    getDefaultObject(np)
<a name="988"></a>    {
<a name="989"></a>        /* there is never a default for the target actor */
<a name="990"></a>        return nil;
<a name="991"></a>    }
<a name="992"></a>
<a name="993"></a>    /* resolve a noun phrase involving unknown words */
<a name="994"></a>    resolveUnknownNounPhrase(tokList)
<a name="995"></a>    {
<a name="996"></a>        /* we can't resolve an unknown noun phrase used as an actor target */
<a name="997"></a>        return nil;
<a name="998"></a>    }
<a name="999"></a>
<a name="1000"></a>    /*
<a name="1001"></a>     *   Get a raw pronoun antecedent list.  Since we are resolving the
<a name="1002"></a>     *   target actor, pronouns are relative to the issuing actor.
<a name="1003"></a>     */
<a name="1004"></a>    getRawPronounAntecedent(typ)
<a name="1005"></a>    {
<a name="1006"></a>        /* check for pronouns that are relative to the issuer */
<a name="1007"></a>        switch(typ)
<a name="1008"></a>        {
<a name="1009"></a>        case PronounMe:
<a name="1010"></a>            /*
<a name="1011"></a>             *   It's a first-person construction.  If the issuing actor
<a name="1012"></a>             *   is the player character, and the PC is in the second
<a name="1013"></a>             *   person, this refers to the player character (the game
<a name="1014"></a>             *   calls the PC "you", so the player calls the PC "me").  If
<a name="1015"></a>             *   the issuing actor is an NPC, this is unconditionally the
<a name="1016"></a>             *   PC.
<a name="1017"></a>             */
<a name="1018"></a>            if (actor_.isPlayerChar &amp;&amp; actor_.referralPerson != SecondPerson)
<a name="1019"></a>                return [];
<a name="1020"></a>            else
<a name="1021"></a>                return [actor_];
<a name="1022"></a>
<a name="1023"></a>        case PronounYou:
<a name="1024"></a>            /*
<a name="1025"></a>             *   It's a second-person construction.  If the issuer is the
<a name="1026"></a>             *   player character, and the player character is in the
<a name="1027"></a>             *   first person, this refers to the player character (the
<a name="1028"></a>             *   game calls the PC "me", so the player calls the PC
<a name="1029"></a>             *   "you").  If the issuer isn't the player character, "you"
<a name="1030"></a>             *   has no meaning.
<a name="1031"></a>             */
<a name="1032"></a>            if (!actor_.isPlayerChar || actor_.referralPerson != FirstPerson)
<a name="1033"></a>                return [];
<a name="1034"></a>            else
<a name="1035"></a>                return [actor_];
<a name="1036"></a>
<a name="1037"></a>        default:
<a name="1038"></a>            /*
<a name="1039"></a>             *   it's not a relative pronoun, so ask the issuing actor for
<a name="1040"></a>             *   the antecedent based on recent commands
<a name="1041"></a>             */
<a name="1042"></a>            return actor_.getPronounAntecedent(typ);
<a name="1043"></a>        }
<a name="1044"></a>    }
<a name="1045"></a>
<a name="1046"></a>    /* we resolve target actors */
<a name="1047"></a>    whichObject = ActorObject
<a name="1048"></a>    whichMessageObject = ActorObject
<a name="1049"></a>;
<a name="1050"></a>
<a name="1051"></a>/*
<a name="1052"></a> *   A pseudo-action for "command actor."  This represents the act of one
<a name="1053"></a> *   actor (usually the PC) giving a command to another, as in "BOB, GO
<a name="1054"></a> *   NORTH".  This isn't a real action that the player can type; it's just
<a name="1055"></a> *   an internal construct that we use to represent the partially resolved
<a name="1056"></a> *   action, when we know that we're addressing another actor but we're
<a name="1057"></a> *   still working on figuring out what we're saying.
<a name="1058"></a> */
<a name="1059"></a>class CommandActorAction: Action
<a name="1060"></a>;
<a name="1061"></a>
<a name="1062"></a>/* ------------------------------------------------------------------------ */
<a name="1063"></a>/*
<a name="1064"></a> *   A possessive resolver is a proxy to a main resolver that considers an
<a name="1065"></a> *   object in scope if (a) it's in scope in the base resolver, or (b) the
<a name="1066"></a> *   object is known to the actor.
<a name="1067"></a> */
<a name="1068"></a>class PossessiveResolver: ProxyResolver
<a name="1069"></a>    objInScope(obj)
<a name="1070"></a>    {
<a name="1071"></a>        /*
<a name="1072"></a>         *   An object is in scope for the purposes of a possessive phrase
<a name="1073"></a>         *   if it's in scope in the base resolver, or it's known to the
<a name="1074"></a>         *   actor.  An object is only in scope for a possessive qualifier
<a name="1075"></a>         *   phrase if its canResolvePossessive property is true.
<a name="1076"></a>         */
<a name="1077"></a>        return (obj.canResolvePossessive
<a name="1078"></a>                &amp;&amp; (origResolver.objInScope(obj)
<a name="1079"></a>                    || origResolver.getTargetActor().knowsAbout(obj)));
<a name="1080"></a>    }
<a name="1081"></a>
<a name="1082"></a>    /* this is a sub-resolver */
<a name="1083"></a>    isSubResolver = true
<a name="1084"></a>;
<a name="1085"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
