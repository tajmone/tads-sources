<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>precond.t</title></head><body>
<table class=ban><tr><td><h1>precond.t</h1><td align=right><a href="../file/precond.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library: Pre-Conditions.
<a name="7"></a> *
<a name="8"></a> *   This module defines the library pre-conditions.  A pre-condition is an
<a name="9"></a> *   abstract object that encapsulates a condition that is required to
<a name="10"></a> *   apply before a command can be executed, and optionally an implied
<a name="11"></a> *   command that can bring the condition into effect.  Pre-conditions can
<a name="12"></a> *   be associated with actions or with the objects of an action.
<a name="13"></a> */
<a name="14"></a>
<a name="15"></a>#include "adv3.h"
<a name="16"></a>
<a name="17"></a>
<a name="18"></a>/* ------------------------------------------------------------------------ */
<a name="19"></a>/*
<a name="20"></a> *   An action pre-condition object.  Each condition of an action is
<a name="21"></a> *   represented by a subclass of this class.
<a name="22"></a> */
<a name="23"></a>class PreCondition: object
<a name="24"></a>    /*
<a name="25"></a>     *   Check the condition on the given object (which may be nil, if
<a name="26"></a>     *   this condition doesn't apply specifically to one of the objects
<a name="27"></a>     *   in the command).  If it is possible to meet the condition with an
<a name="28"></a>     *   implicit command, and allowImplicit is true, try to execute the
<a name="29"></a>     *   command.  If the condition cannot be met, report a failure and
<a name="30"></a>     *   use 'exit' to terminate the command.
<a name="31"></a>     *
<a name="32"></a>     *   If allowImplicit is nil, an implicit command may not be
<a name="33"></a>     *   attempted.  In this case, if the condition is not met, we must
<a name="34"></a>     *   simply report a failure and use 'exit' to terminate the command.
<a name="35"></a>     */
<a name="36"></a>    checkPreCondition(obj, allowImplicit) { }
<a name="37"></a>
<a name="38"></a>    /*
<a name="39"></a>     *   Verify the condition.  This is called during the object
<a name="40"></a>     *   verification step so that the pre-condition can add verifications
<a name="41"></a>     *   of its own.  This can be used, for example, to add likelihood to
<a name="42"></a>     *   objects that already meet the condition.  Note that it is
<a name="43"></a>     *   generally not desirable to report illogical for conditions that
<a name="44"></a>     *   checkPreCondition() enforces, because doing so will prevent
<a name="45"></a>     *   checkPreCondition() from ever being reached and thus will prevent
<a name="46"></a>     *   checkPreCondition() from attempting to carry out implicit actions
<a name="47"></a>     *   to meet the condition.
<a name="48"></a>     *
<a name="49"></a>     *   'obj' is the object being checked.  Note that because this is
<a name="50"></a>     *   called during verification, the explicitly passed-in object must
<a name="51"></a>     *   be used in the check rather than the current object in the global
<a name="52"></a>     *   current action.
<a name="53"></a>     */
<a name="54"></a>    verifyPreCondition(obj) { }
<a name="55"></a>
<a name="56"></a>    /*
<a name="57"></a>     *   Precondition execution order.  When we execute preconditions for a
<a name="58"></a>     *   given action, we'll sort the list of all applicable preconditions
<a name="59"></a>     *   in ascending execution order.
<a name="60"></a>     *
<a name="61"></a>     *   For the most part, the relative order of two preconditions is
<a name="62"></a>     *   arbitrary.  In some unusual cases, though, the order is important,
<a name="63"></a>     *   such as when applying one precondition can destroy the conditions
<a name="64"></a>     *   that the other would try to create but not vice versa.  When the
<a name="65"></a>     *   order doesn't matter, this can be left at the default setting.
<a name="66"></a>     */
<a name="67"></a>    preCondOrder = 100
<a name="68"></a>;
<a name="69"></a>
<a name="70"></a>/* ------------------------------------------------------------------------ */
<a name="71"></a>/*
<a name="72"></a> *   A pre-condition that applies to a specific, pre-determined object,
<a name="73"></a> *   rather than the direct/indirect object of the command.
<a name="74"></a> */
<a name="75"></a>class ObjectPreCondition: PreCondition
<a name="76"></a>    construct(obj, cond)
<a name="77"></a>    {
<a name="78"></a>        /*
<a name="79"></a>         *   remember the specific object I act upon, and the underlying
<a name="80"></a>         *   precondition to apply to that object
<a name="81"></a>         */
<a name="82"></a>        obj_ = obj;
<a name="83"></a>        cond_ = cond;
<a name="84"></a>    }
<a name="85"></a>
<a name="86"></a>    /* route our check to the pre-condition using our specific object */
<a name="87"></a>    checkPreCondition(obj, allowImplicit)
<a name="88"></a>    {
<a name="89"></a>        /* check the precondition */
<a name="90"></a>        return cond_.checkPreCondition(obj_, allowImplicit);
<a name="91"></a>    }
<a name="92"></a>
<a name="93"></a>    /* route our verification check to the pre-condition */
<a name="94"></a>    verifyPreCondition(obj)
<a name="95"></a>    {
<a name="96"></a>        cond_.verifyPreCondition(obj_);
<a name="97"></a>    }
<a name="98"></a>
<a name="99"></a>    /* use the same order as our underlying condition */
<a name="100"></a>    preCondOrder = (cond_.preCondOrder)
<a name="101"></a>
<a name="102"></a>    /* the object we check with the condition */
<a name="103"></a>    obj_ = nil
<a name="104"></a>
<a name="105"></a>    /* the pre-condition we check */
<a name="106"></a>    cond_ = nil
<a name="107"></a>;
<a name="108"></a>
<a name="109"></a>
<a name="110"></a>/* ------------------------------------------------------------------------ */
<a name="111"></a>/*
<a name="112"></a> *   Pre-condition: object must be visible.  This condition doesn't
<a name="113"></a> *   attempt any implied command to make the object visible, but merely
<a name="114"></a> *   enforces visibility before allowing the command.
<a name="115"></a> *
<a name="116"></a> *   This condition is useful for commands that rely on visibly inspecting
<a name="117"></a> *   the object, such as "examine" or "look in".  It is possible for an
<a name="118"></a> *   object to be in scope without being visible, since an object can be
<a name="119"></a> *   in scope by way of a non-visual sense.
<a name="120"></a> *
<a name="121"></a> *   We enforce visibility with a verification test, not a precondition
<a name="122"></a> *   check.
<a name="123"></a> */
<a name="124"></a>objVisible: PreCondition
<a name="125"></a>    verifyPreCondition(obj)
<a name="126"></a>    {
<a name="127"></a>        /* if the object isn't visible, disallow the command */
<a name="128"></a>        if (obj != nil &amp;&amp; !gActor.canSee(obj))
<a name="129"></a>        {
<a name="130"></a>            /*
<a name="131"></a>             *   If the actor is in the dark, that must be the problem.
<a name="132"></a>             *   Otherwise, if the object can be heard or smelled but not
<a name="133"></a>             *   seen, say so.  In any other case, issue a generic message
<a name="134"></a>             *   that we can't see the object.
<a name="135"></a>             */
<a name="136"></a>            if (!gActor.isLocationLit())
<a name="137"></a>                inaccessible(&amp;tooDarkMsg);
<a name="138"></a>            else if (obj.soundPresence &amp;&amp; gActor.canHear(obj))
<a name="139"></a>                inaccessible(&amp;heardButNotSeenMsg, obj);
<a name="140"></a>            else if (obj.smellPresence &amp;&amp; gActor.canSmell(obj))
<a name="141"></a>                inaccessible(&amp;smelledButNotSeenMsg, obj);
<a name="142"></a>            else
<a name="143"></a>                inaccessible(&amp;mustBeVisibleMsg, obj);
<a name="144"></a>        }
<a name="145"></a>    }
<a name="146"></a>;
<a name="147"></a>
<a name="148"></a>/* ------------------------------------------------------------------------ */
<a name="149"></a>/*
<a name="150"></a> *   Pre-condition: object must be audible; that is, it must be within
<a name="151"></a> *   hearing range of the actor.  This condition doesn't attempt any
<a name="152"></a> *   implied command to make the object audible, but merely enforces
<a name="153"></a> *   audibility before allowing the command.
<a name="154"></a> *
<a name="155"></a> *   It is possible for an object to be in scope without being audible,
<a name="156"></a> *   since an object can be inside a container that is transparent to
<a name="157"></a> *   light but blocks all sound.
<a name="158"></a> *
<a name="159"></a> *   We enforce this condition with a verification test.
<a name="160"></a> */
<a name="161"></a>objAudible: PreCondition
<a name="162"></a>    verifyPreCondition(obj)
<a name="163"></a>    {
<a name="164"></a>        /* if the object isn't audible, disallow the command */
<a name="165"></a>        if (obj != nil &amp;&amp; !gActor.canHear(obj))
<a name="166"></a>            inaccessible(&amp;cannotHearMsg, obj);
<a name="167"></a>    }
<a name="168"></a>;
<a name="169"></a>
<a name="170"></a>/* ------------------------------------------------------------------------ */
<a name="171"></a>/*
<a name="172"></a> *   Pre-condition: object must be within smelling range of the actor.
<a name="173"></a> *   This condition doesn't attempt any implied command to make the object
<a name="174"></a> *   smellable, but merely enforces the condition before allowing the
<a name="175"></a> *   command.
<a name="176"></a> *
<a name="177"></a> *   It is possible for an object to be in scope without being smellable,
<a name="178"></a> *   since an object can be inside a container that is transparent to
<a name="179"></a> *   light but blocks all odors.
<a name="180"></a> *
<a name="181"></a> *   We enforce this condition with a verification test.
<a name="182"></a> */
<a name="183"></a>objSmellable: PreCondition
<a name="184"></a>    verifyPreCondition(obj)
<a name="185"></a>    {
<a name="186"></a>        /* if the object isn't within sense range, disallow the command */
<a name="187"></a>        if (obj != nil &amp;&amp; !gActor.canSmell(obj))
<a name="188"></a>            inaccessible(&amp;cannotSmellMsg, obj);
<a name="189"></a>    }
<a name="190"></a>;
<a name="191"></a>
<a name="192"></a>/* ------------------------------------------------------------------------ */
<a name="193"></a>/*
<a name="194"></a> *   Pre-condition: actor must be standing.  This is useful for travel
<a name="195"></a> *   commands to ensure that the actor is free of any entanglements from
<a name="196"></a> *   nested rooms prior to travel.
<a name="197"></a> */
<a name="198"></a>actorStanding: PreCondition
<a name="199"></a>    checkPreCondition(obj, allowImplicit)
<a name="200"></a>    {
<a name="201"></a>        /* check to see if the actor is standing - if so, we're done */
<a name="202"></a>        if (gActor.posture == standing)
<a name="203"></a>            return nil;
<a name="204"></a>
<a name="205"></a>        /* the actor isn't standing - try a "stand up" command */
<a name="206"></a>        if (allowImplicit &amp;&amp; tryImplicitAction(Stand))
<a name="207"></a>        {
<a name="208"></a>            /*
<a name="209"></a>             *   make sure that leaves the actor standing - if not,
<a name="210"></a>             *   exit silently, since the reason for failure will have
<a name="211"></a>             *   been reported by the "stand up" action
<a name="212"></a>             */
<a name="213"></a>            if (gActor.posture != standing)
<a name="214"></a>                exit;
<a name="215"></a>
<a name="216"></a>            /* indicate that we executed an implicit command */
<a name="217"></a>            return true;
<a name="218"></a>        }
<a name="219"></a>
<a name="220"></a>        /* we can't stand up implicitly - report the problem and exit */
<a name="221"></a>        reportFailure(&amp;mustBeStandingMsg);
<a name="222"></a>        exit;
<a name="223"></a>    }
<a name="224"></a>;
<a name="225"></a>
<a name="226"></a>/*
<a name="227"></a> *   Pre-condition: actor must be "travel ready."  The exact meaning of
<a name="228"></a> *   "travel ready" is provided by the actor's immediately container.  The
<a name="229"></a> *   'obj' argument is always the travel connector to be traversed.
<a name="230"></a> */
<a name="231"></a>actorTravelReady: PreCondition
<a name="232"></a>    checkPreCondition(obj, allowImplicit)
<a name="233"></a>    {
<a name="234"></a>        local loc = gActor.location;
<a name="235"></a>
<a name="236"></a>        /* check to see if the actor is standing - if so, we're done */
<a name="237"></a>        if (loc.isActorTravelReady(obj))
<a name="238"></a>            return nil;
<a name="239"></a>
<a name="240"></a>        /* the actor isn't standing - try a "stand up" command */
<a name="241"></a>        if (allowImplicit &amp;&amp; gActor.location.tryMakingTravelReady(obj))
<a name="242"></a>        {
<a name="243"></a>            /*
<a name="244"></a>             *   make sure that the actor really is travel-ready now - if
<a name="245"></a>             *   not, exit silently, since the reason for failure will have
<a name="246"></a>             *   been reported by the implicit action
<a name="247"></a>             */
<a name="248"></a>            if (!loc.isActorTravelReady(obj))
<a name="249"></a>                exit;
<a name="250"></a>
<a name="251"></a>            /* indicate that we executed an implicit command */
<a name="252"></a>            return true;
<a name="253"></a>        }
<a name="254"></a>
<a name="255"></a>        /* we can't make the actor travel-ready - report failure and exit */
<a name="256"></a>        reportFailure(loc.notTravelReadyMsg);
<a name="257"></a>        exit;
<a name="258"></a>    }
<a name="259"></a>;
<a name="260"></a>
<a name="261"></a>/* ------------------------------------------------------------------------ */
<a name="262"></a>/*
<a name="263"></a> *   Pre-condition: the traveler is directly in the given room.  This will
<a name="264"></a> *   attempt to remove the traveler from any nested rooms within the given
<a name="265"></a> *   room, but cannot perform travel between rooms not related by
<a name="266"></a> *   containment.
<a name="267"></a> *
<a name="268"></a> *   Note that the traveler is not necessarily the actor, because the actor
<a name="269"></a> *   could be in a vehicle.
<a name="270"></a> *
<a name="271"></a> *   This is a class, because it has to be instantiated with more
<a name="272"></a> *   parameters than just a single 'obj' passed by default when evaluating
<a name="273"></a> *   preconditions.  In particular, we need to know the actor performing
<a name="274"></a> *   the travel, the connector being traversed, and the room we need to be
<a name="275"></a> *   directly in.
<a name="276"></a> */
<a name="277"></a>class TravelerDirectlyInRoom: PreCondition
<a name="278"></a>    construct(actor, conn, loc)
<a name="279"></a>    {
<a name="280"></a>        /* remember the actor, connector, and room */
<a name="281"></a>        actor_ = actor;
<a name="282"></a>        conn_ = conn;
<a name="283"></a>        loc_ = loc;
<a name="284"></a>    }
<a name="285"></a>
<a name="286"></a>    checkPreCondition(obj, allowImplicit)
<a name="287"></a>    {
<a name="288"></a>        /* ask the traveler to do the work */
<a name="289"></a>        return actor_.getTraveler(conn_)
<a name="290"></a>            .checkDirectlyInRoom(loc_, allowImplicit);
<a name="291"></a>    }
<a name="292"></a>
<a name="293"></a>    /* the actor doing the travel */
<a name="294"></a>    actor_ = nil
<a name="295"></a>
<a name="296"></a>    /* the connector being traversed */
<a name="297"></a>    conn_ = nil
<a name="298"></a>
<a name="299"></a>    /* the room we need to be directly in  */
<a name="300"></a>    loc_ = nil
<a name="301"></a>;
<a name="302"></a>
<a name="303"></a>/*
<a name="304"></a> *   Pre-condition: the actor is directly in the given room.  This differs
<a name="305"></a> *   from TravelerDirectlyInRoom in that this operates directly on the
<a name="306"></a> *   actor, regardless of whether the actor is in a vehicle.
<a name="307"></a> */
<a name="308"></a>actorDirectlyInRoom: PreCondition
<a name="309"></a>    checkPreCondition(obj, allowImplicit)
<a name="310"></a>    {
<a name="311"></a>        /* ask the actor to do the work */
<a name="312"></a>        return gActor.checkDirectlyInRoom(obj, allowImplicit);
<a name="313"></a>    }
<a name="314"></a>;
<a name="315"></a>
<a name="316"></a>/* ------------------------------------------------------------------------ */
<a name="317"></a>/*
<a name="318"></a> *   Pre-condition: actor is ready to enter a nested location.  This is
<a name="319"></a> *   useful for commands that cause travel within a location, such as "sit
<a name="320"></a> *   on chair": this ensures that the actor is either already in the given
<a name="321"></a> *   nested location, or is in the main location; and that the actor is
<a name="322"></a> *   standing.  We simply call the actor to do the work.
<a name="323"></a> */
<a name="324"></a>actorReadyToEnterNestedRoom: PreCondition
<a name="325"></a>    checkPreCondition(obj, allowImplicit)
<a name="326"></a>    {
<a name="327"></a>        /* ask the actor to make the determination */
<a name="328"></a>        return gActor.checkReadyToEnterNestedRoom(obj, allowImplicit);
<a name="329"></a>    }
<a name="330"></a>;
<a name="331"></a>
<a name="332"></a>/* ------------------------------------------------------------------------ */
<a name="333"></a>/*
<a name="334"></a> *   Pre-condition: the target actor must be able to talk to the object.
<a name="335"></a> *   This is useful for actions that require communications, such as ASK
<a name="336"></a> *   ABOUT, TELL ABOUT, and TALK TO.
<a name="337"></a> */
<a name="338"></a>canTalkToObj: PreCondition
<a name="339"></a>    checkPreCondition(obj, allowImplicit)
<a name="340"></a>    {
<a name="341"></a>        /*
<a name="342"></a>         *   if the current actor can't talk to the given object, disallow
<a name="343"></a>         *   the command
<a name="344"></a>         */
<a name="345"></a>        if (obj != nil &amp;&amp; !gActor.canTalkTo(obj))
<a name="346"></a>        {
<a name="347"></a>            reportFailure(&amp;objCannotHearActorMsg, obj);
<a name="348"></a>            exit;
<a name="349"></a>        }
<a name="350"></a>
<a name="351"></a>        /* we don't perform any implicit commands */
<a name="352"></a>        return nil;
<a name="353"></a>    }
<a name="354"></a>;
<a name="355"></a>
<a name="356"></a>/* ------------------------------------------------------------------------ */
<a name="357"></a>/*
<a name="358"></a> *   Pre-condition: object must be held.  This condition requires that an
<a name="359"></a> *   object of a command must be held by the actor.  If it is not, we will
<a name="360"></a> *   attempt a recursive "take" command on the object.
<a name="361"></a> *
<a name="362"></a> *   This condition is useful for commands where the object is to be
<a name="363"></a> *   manipulated in some way, or used to manipulate some other object.
<a name="364"></a> *   For example, the key in "unlock door with key" would normally have to
<a name="365"></a> *   be held.
<a name="366"></a> */
<a name="367"></a>objHeld: PreCondition
<a name="368"></a>    checkPreCondition(obj, allowImplicit)
<a name="369"></a>    {
<a name="370"></a>        /* if the object is already held, there's nothing we need to do */
<a name="371"></a>        if (obj == nil || obj.meetsObjHeld(gActor))
<a name="372"></a>            return nil;
<a name="373"></a>
<a name="374"></a>        /* the object isn't being held - try an implicit 'take' command */
<a name="375"></a>        if (allowImplicit &amp;&amp; obj.tryHolding())
<a name="376"></a>        {
<a name="377"></a>            /*
<a name="378"></a>             *   we successfully executed the command; check to make sure
<a name="379"></a>             *   it worked, and if not, abort the command without further
<a name="380"></a>             *   comment (if the command failed, presumably the command
<a name="381"></a>             *   showed an explanation as to why)
<a name="382"></a>             */
<a name="383"></a>            if (!obj.meetsObjHeld(gActor))
<a name="384"></a>                exit;
<a name="385"></a>
<a name="386"></a>            /* tell the caller we executed an implicit command */
<a name="387"></a>            return true;
<a name="388"></a>        }
<a name="389"></a>
<a name="390"></a>        /* it's not held and we can't take it - fail */
<a name="391"></a>        reportFailure(&amp;mustBeHoldingMsg, obj);
<a name="392"></a>
<a name="393"></a>        /* make it the pronoun */
<a name="394"></a>        gActor.setPronounObj(obj);
<a name="395"></a>
<a name="396"></a>        /* abort the command */
<a name="397"></a>        exit;
<a name="398"></a>    }
<a name="399"></a>
<a name="400"></a>    /* lower the likelihood rating for anything not being held */
<a name="401"></a>    verifyPreCondition(obj)
<a name="402"></a>    {
<a name="403"></a>        /* if the object isn't being held, reduce its likelihood rating */
<a name="404"></a>        if (obj != nil &amp;&amp; !obj.meetsObjHeld(gActor))
<a name="405"></a>            logicalRankOrd(80, 'implied take', 150);
<a name="406"></a>    }
<a name="407"></a>;
<a name="408"></a>
<a name="409"></a>/* ------------------------------------------------------------------------ */
<a name="410"></a>/*
<a name="411"></a> *   Pre-condition: a given source object must be able to touch the
<a name="412"></a> *   object.  This requires that the source object (given by our property
<a name="413"></a> *   'sourceObj') has a clear 'touch' path to the target object.
<a name="414"></a> *
<a name="415"></a> *   This is a base class for arbitrary object-to-object touch conditions.
<a name="416"></a> *   In most cases, you'll want to use the more specific touchObj, which
<a name="417"></a> *   tests that the current actor can touch the current object.
<a name="418"></a> */
<a name="419"></a>class TouchObjCondition: PreCondition
<a name="420"></a>    /* construct with a given source object */
<a name="421"></a>    construct(src) { sourceObj = src; }
<a name="422"></a>
<a name="423"></a>    /*
<a name="424"></a>     *   the source object - this is the object that is attempting to
<a name="425"></a>     *   touch the target object
<a name="426"></a>     */
<a name="427"></a>    sourceObj = nil
<a name="428"></a>
<a name="429"></a>    /* check the condition */
<a name="430"></a>    checkPreCondition(obj, allowImplicit)
<a name="431"></a>    {
<a name="432"></a>        local pastObs;
<a name="433"></a>
<a name="434"></a>        /*
<a name="435"></a>         *   If we can touch the object, we can proceed with no implicit
<a name="436"></a>         *   actions.
<a name="437"></a>         */
<a name="438"></a>        if (sourceObj.canTouch(obj))
<a name="439"></a>            return nil;
<a name="440"></a>
<a name="441"></a>        /* we haven't tried removing any obstructors yet */
<a name="442"></a>        pastObs = new Vector(8);
<a name="443"></a>
<a name="444"></a>        /*
<a name="445"></a>         *   Repeatedly look for and attempt to remove obstructions.
<a name="446"></a>         *   There could be multiple things in the way, so try to remove
<a name="447"></a>         *   each one we find until either we fail to remove an
<a name="448"></a>         *   obstruction or we run out of obstructions.
<a name="449"></a>         */
<a name="450"></a>        for (;;)
<a name="451"></a>        {
<a name="452"></a>            local stat;
<a name="453"></a>            local path;
<a name="454"></a>            local result;
<a name="455"></a>            local obs;
<a name="456"></a>
<a name="457"></a>            /* get the path for reaching out and touching the object */
<a name="458"></a>            path = sourceObj.getTouchPathTo(obj);
<a name="459"></a>
<a name="460"></a>            /* if we have a path, look for an obstructor */
<a name="461"></a>            if (path != nil)
<a name="462"></a>            {
<a name="463"></a>                /* traverse the path to find what blocks our touch */
<a name="464"></a>                stat = sourceObj.traversePath(path, function(ele, op)
<a name="465"></a>                {
<a name="466"></a>                    /*
<a name="467"></a>                     *   If we can continue the reach via this path element,
<a name="468"></a>                     *   simply keep going.  Otherwise, stop the reach here.
<a name="469"></a>                     */
<a name="470"></a>                    result = ele.checkTouchViaPath(sourceObj, obj, op);
<a name="471"></a>                    if (result.isSuccess)
<a name="472"></a>                    {
<a name="473"></a>                        /* no objection here - keep going */
<a name="474"></a>                        return true;
<a name="475"></a>                    }
<a name="476"></a>                    else
<a name="477"></a>                    {
<a name="478"></a>                        /* stop here, noting the obstruction */
<a name="479"></a>                        obs = ele;
<a name="480"></a>                        return nil;
<a name="481"></a>                    }
<a name="482"></a>                });
<a name="483"></a>
<a name="484"></a>                /*
<a name="485"></a>                 *   if we now have a clear path, we're done - simply return
<a name="486"></a>                 *   true to indicate that we ran one or more implicit
<a name="487"></a>                 *   commands
<a name="488"></a>                 */
<a name="489"></a>                if (stat)
<a name="490"></a>                    return true;
<a name="491"></a>            }
<a name="492"></a>            else
<a name="493"></a>            {
<a name="494"></a>                /*
<a name="495"></a>                 *   we have no path, so the object must be in an
<a name="496"></a>                 *   unconnected location; we don't know the obstructor in
<a name="497"></a>                 *   this case
<a name="498"></a>                 */
<a name="499"></a>                obs = nil;
<a name="500"></a>            }
<a name="501"></a>
<a name="502"></a>            /*
<a name="503"></a>             *   'result' is a CheckStatus object explaining why we can't
<a name="504"></a>             *   reach past 'obs', which is the first object that
<a name="505"></a>             *   obstructs our reach.
<a name="506"></a>             *
<a name="507"></a>             *   If the obstructor is not visible or we couldn't find one,
<a name="508"></a>             *   we can't do anything to try to remove it; simply report
<a name="509"></a>             *   that we can't reach the target object and give up.
<a name="510"></a>             */
<a name="511"></a>            if (obs == nil || !gActor.canSee(obs))
<a name="512"></a>            {
<a name="513"></a>                reportFailure(&amp;cannotReachObjectMsg, obj);
<a name="514"></a>                exit;
<a name="515"></a>            }
<a name="516"></a>
<a name="517"></a>            /*
<a name="518"></a>             *   Ask the obstructor to get out of the way if possible.
<a name="519"></a>             *
<a name="520"></a>             *   If we've already tried to remove this same obstructor on
<a name="521"></a>             *   a past iteration, don't try again, as there's no reason
<a name="522"></a>             *   to think an implicit command will work any better this
<a name="523"></a>             *   time.
<a name="524"></a>             */
<a name="525"></a>            if (pastObs.indexOf(obs) != nil
<a name="526"></a>                || !allowImplicit
<a name="527"></a>                || !obs.tryImplicitRemoveObstructor(touch, obj))
<a name="528"></a>            {
<a name="529"></a>                /*
<a name="530"></a>                 *   We can't remove the obstruction - either we've tried
<a name="531"></a>                 *   an implicit command on this same obstructor and
<a name="532"></a>                 *   failed, or we can't try an implicit command at all.
<a name="533"></a>                 *   In any case, use the explanation of the problem from
<a name="534"></a>                 *   the CheckStatus result object.
<a name="535"></a>                 */
<a name="536"></a>                reportFailure(result.msgProp, result.msgParams...);
<a name="537"></a>                exit;
<a name="538"></a>            }
<a name="539"></a>
<a name="540"></a>            /*
<a name="541"></a>             *   if the implied command failed, simply give up now -
<a name="542"></a>             *   there's no need to go on, since the implied command will
<a name="543"></a>             *   have already explained why it failed
<a name="544"></a>             */
<a name="545"></a>            if (gTranscript.currentActionHasReport({x: x.isFailure}))
<a name="546"></a>                exit;
<a name="547"></a>
<a name="548"></a>            /*
<a name="549"></a>             *   We've tried an implied command to remove this obstructor,
<a name="550"></a>             *   but that isn't guaranteed to make the target touchable,
<a name="551"></a>             *   as there could be further obstrutions, or the implied
<a name="552"></a>             *   command could have failed to actually remove the
<a name="553"></a>             *   obstruction.  Keep iterating.  To avoid looping forever
<a name="554"></a>             *   in the event the implicit command we just tried isn't
<a name="555"></a>             *   good enough to remove this obstruction, make a note of
<a name="556"></a>             *   the obstruction we just tried to remove; if we find it
<a name="557"></a>             *   again on a subsequent iteration, we'll know that we've
<a name="558"></a>             *   tried before to remove it and failed, and thus we'll know
<a name="559"></a>             *   to give up without making the same doomed attempt again.
<a name="560"></a>             */
<a name="561"></a>            pastObs.append(obs);
<a name="562"></a>        }
<a name="563"></a>    }
<a name="564"></a>
<a name="565"></a>    verifyPreCondition(obj)
<a name="566"></a>    {
<a name="567"></a>        /*
<a name="568"></a>         *   If there's no source object, do nothing at this point.  We can
<a name="569"></a>         *   have a nil source object when we're resolving nouns for a
<a name="570"></a>         *   two-object action, and we have a cross-object condition (for
<a name="571"></a>         *   example, we require that the indirect object can touch the
<a name="572"></a>         *   direct object).  In these cases, when we're resolving the
<a name="573"></a>         *   first-resolved noun phrase, the second-resolved noun phrase
<a name="574"></a>         *   won't be known yet.  The only purpose of verification at times
<a name="575"></a>         *   like these is to improve our guess about an ambiguous match,
<a name="576"></a>         *   but we have nothing to add at such times, so we can simply
<a name="577"></a>         *   return without doing anything.
<a name="578"></a>         */
<a name="579"></a>        if (sourceObj == nil)
<a name="580"></a>            return;
<a name="581"></a>
<a name="582"></a>        /* if we can't touch the object, make it less likely */
<a name="583"></a>        if (!sourceObj.canTouch(obj))
<a name="584"></a>        {
<a name="585"></a>            /*
<a name="586"></a>             *   If we can't see the object, we must be able to sense it
<a name="587"></a>             *   by some means other than sight, so it must have a
<a name="588"></a>             *   sufficiently distinctive sound or odor to put it in
<a name="589"></a>             *   scope.  Explain this: "you can hear it but you can't see
<a name="590"></a>             *   it", or the like.
<a name="591"></a>             */
<a name="592"></a>            if (gActor.canSee(obj))
<a name="593"></a>            {
<a name="594"></a>                local info;
<a name="595"></a>
<a name="596"></a>                /*
<a name="597"></a>                 *   It's visible but cannot be reached from here, so it
<a name="598"></a>                 *   must be too far away, inside a closed but transparent
<a name="599"></a>                 *   container, or something like that.
<a name="600"></a>                 *
<a name="601"></a>                 *   If it's at a distance, rule it illogical, since
<a name="602"></a>                 *   there's not usually anything automatic we can do to
<a name="603"></a>                 *   remove the distance obstruction.
<a name="604"></a>                 *
<a name="605"></a>                 *   If it's not distant, don't rule it illogical, but do
<a name="606"></a>                 *   reduce the likelihood ranking, so that we'll prefer a
<a name="607"></a>                 *   different object that can readily be touched.  Since
<a name="608"></a>                 *   we can see where the object is, we might know how to
<a name="609"></a>                 *   remove the obstruction to reachability.
<a name="610"></a>                 */
<a name="611"></a>                info = gActor.bestVisualInfo(obj);
<a name="612"></a>                if (info != nil &amp;&amp; info.trans == distant)
<a name="613"></a>                {
<a name="614"></a>                    /* it's distant - assume we can't fix this */
<a name="615"></a>                    inaccessible(&amp;tooDistantMsg, obj);
<a name="616"></a>                }
<a name="617"></a>                else
<a name="618"></a>                {
<a name="619"></a>                    /*
<a name="620"></a>                     *   it's not distant; rank it logical (since we might
<a name="621"></a>                     *   be able to clear the obstruction with an implied
<a name="622"></a>                     *   action), but at reduced likelihood (in case
<a name="623"></a>                     *   there's something that doesn't need any prior
<a name="624"></a>                     *   implied action to reach)
<a name="625"></a>                     */
<a name="626"></a>                    logicalRankOrd(80, 'unreachable but visible', 150);
<a name="627"></a>                }
<a name="628"></a>            }
<a name="629"></a>            else
<a name="630"></a>            {
<a name="631"></a>                /*
<a name="632"></a>                 *   if it has a sound presence, then "you can hear it but
<a name="633"></a>                 *   you can't see it"; if it has a smell presence, then
<a name="634"></a>                 *   "you can smell it but you can't see it"; otherwise,
<a name="635"></a>                 *   you simply can't see it
<a name="636"></a>                 */
<a name="637"></a>                if (obj.soundPresence &amp;&amp; gActor.canHear(obj))
<a name="638"></a>                {
<a name="639"></a>                    /* it can be heard but not seen */
<a name="640"></a>                    inaccessible(&amp;heardButNotSeenMsg, obj);
<a name="641"></a>                }
<a name="642"></a>                else if (obj.smellPresence &amp;&amp; gActor.canSmell(obj))
<a name="643"></a>                {
<a name="644"></a>                    /* it can be smelled but not seen */
<a name="645"></a>                    inaccessible(&amp;smelledButNotSeenMsg, obj);
<a name="646"></a>                }
<a name="647"></a>                else if (!gActor.isLocationLit())
<a name="648"></a>                {
<a name="649"></a>                    /* it's too dark to see the object */
<a name="650"></a>                    inaccessible(&amp;tooDarkMsg);
<a name="651"></a>                }
<a name="652"></a>                else
<a name="653"></a>                {
<a name="654"></a>                    /* it simply cannot be seen */
<a name="655"></a>                    inaccessible(&amp;mustBeVisibleMsg, obj);
<a name="656"></a>                }
<a name="657"></a>            }
<a name="658"></a>        }
<a name="659"></a>    }
<a name="660"></a>
<a name="661"></a>    /*
<a name="662"></a>     *   This condition tends to be fragile, in the sense that other
<a name="663"></a>     *   preconditions for the same action have the potential to undo any
<a name="664"></a>     *   implicit action that we perform to make an object touchable.  This
<a name="665"></a>     *   is most likely to happen when we implicitly move the actor (moving
<a name="666"></a>     *   in or out of a nested room, for example) to put the actor within
<a name="667"></a>     *   reach of the target object.  To reduce the likelihood that this
<a name="668"></a>     *   fragility will be visible to a player, try to execute this
<a name="669"></a>     *   condition after other conditions.  Most other preconditions tend
<a name="670"></a>     *   to be "stickier" - less likely to be undone by subsequent
<a name="671"></a>     *   preconditions.
<a name="672"></a>     */
<a name="673"></a>    preCondOrder = 200
<a name="674"></a>;
<a name="675"></a>
<a name="676"></a>/* ------------------------------------------------------------------------ */
<a name="677"></a>/*
<a name="678"></a> *   Pre-condition: actor must be able to touch the object.  This doesn't
<a name="679"></a> *   require that the actor is actually holding the object, but the actor
<a name="680"></a> *   must be able to physically touch the object.  This ensures that the
<a name="681"></a> *   actor and object are not, for example, separated by a transparent
<a name="682"></a> *   barrier.
<a name="683"></a> *
<a name="684"></a> *   If there is a transparent barrier, we will attempt to remove the
<a name="685"></a> *   barrier by calling the barrier object's tryImplicitRemoveObstructor
<a name="686"></a> *   method.  Objects that can be opened in an obvious fashion will
<a name="687"></a> *   perform an implicit recursive "open" command, and other types of
<a name="688"></a> *   objects can provide customized behavior as appropriate.
<a name="689"></a> */
<a name="690"></a>touchObj: TouchObjCondition
<a name="691"></a>    /* we want to test reaching from the current actor to the target object */
<a name="692"></a>    sourceObj = (gActor)
<a name="693"></a>;
<a name="694"></a>
<a name="695"></a>/*
<a name="696"></a> *   Pre-condition: the indirect object must be able to touch the target
<a name="697"></a> *   object.  This can be used for actions where the direct object is going
<a name="698"></a> *   to be manipulated by an "agent" of the action (i.e., the indirect
<a name="699"></a> *   object), rather than directly by the actor: MOVE X WITH Y, for
<a name="700"></a> *   example.
<a name="701"></a> *
<a name="702"></a> *   Note that the target object of this condition should be the direct
<a name="703"></a> *   object in most cases, so this condition should usually be used like
<a name="704"></a> *   this:
<a name="705"></a> *
<a name="706"></a> *   dobjFor(MoveWith) { preCond = [iobjTouchObj] }
<a name="707"></a> *
<a name="708"></a> *   In other words, this is a precondition that we apply in most cases to
<a name="709"></a> *   the *direct* object.
<a name="710"></a> */
<a name="711"></a>iobjTouchObj: TouchObjCondition
<a name="712"></a>    /* the indirect object has to be able to touch the target object */
<a name="713"></a>    sourceObj = (gIobj)
<a name="714"></a>;
<a name="715"></a>
<a name="716"></a>/*
<a name="717"></a> *   Pre-condition: the direct object can touch the target object.  This
<a name="718"></a> *   is useful for situations where the direct object is being manipulated
<a name="719"></a> *   directly and the indirect object is more of a passive participant in
<a name="720"></a> *   the action, such as PLUG CORD INTO OUTLET.
<a name="721"></a> */
<a name="722"></a>dobjTouchObj: TouchObjCondition
<a name="723"></a>    /* the direct object has to be able to touch the target object */
<a name="724"></a>    sourceObj = (gDobj)
<a name="725"></a>;
<a name="726"></a>
<a name="727"></a>/* ------------------------------------------------------------------------ */
<a name="728"></a>/*
<a name="729"></a> *   A precondition ensuring that the target object is in the same
<a name="730"></a> *   immediate location as a given object.
<a name="731"></a> */
<a name="732"></a>class SameLocationCondition: PreCondition
<a name="733"></a>    /*
<a name="734"></a>     *   construct dynamically, setting the other object whose location we
<a name="735"></a>     *   must match
<a name="736"></a>     */
<a name="737"></a>    construct(obj) { sourceObj = obj; }
<a name="738"></a>
<a name="739"></a>    /* the object whose location we must match */
<a name="740"></a>    sourceObj = nil
<a name="741"></a>
<a name="742"></a>    /* check the condition */
<a name="743"></a>    checkPreCondition(obj, allowImplicit)
<a name="744"></a>    {
<a name="745"></a>        local moveObj;
<a name="746"></a>        local targetLoc;
<a name="747"></a>
<a name="748"></a>        /* if we're in the same container, we're fine */
<a name="749"></a>        if (obj.location == sourceObj.location)
<a name="750"></a>            return nil;
<a name="751"></a>
<a name="752"></a>        /*
<a name="753"></a>         *   Pick an object to move.  By default, pick the target object;
<a name="754"></a>         *   but if the target object is non-portable, then trying to move
<a name="755"></a>         *   it will fail, so pick the source object.
<a name="756"></a>         */
<a name="757"></a>        if (obj.ofKind(NonPortable))
<a name="758"></a>        {
<a name="759"></a>            /* 'obj' is unportable, so try moving the source object */
<a name="760"></a>            moveObj = sourceObj;
<a name="761"></a>            targetLoc = obj.location;
<a name="762"></a>        }
<a name="763"></a>        else
<a name="764"></a>        {
<a name="765"></a>            /* 'obj' is portable, so try moving it by default */
<a name="766"></a>            moveObj = obj;
<a name="767"></a>            targetLoc = sourceObj.location;
<a name="768"></a>        }
<a name="769"></a>
<a name="770"></a>        /* try moving the object, and return the result */
<a name="771"></a>        if (allowImplicit &amp;&amp; targetLoc.tryMovingObjInto(moveObj))
<a name="772"></a>        {
<a name="773"></a>            /* if it didn't work, abort the action */
<a name="774"></a>            if (obj.location != sourceObj.location)
<a name="775"></a>                exit;
<a name="776"></a>
<a name="777"></a>            /* tell the caller we executed an implied action */
<a name="778"></a>            return true;
<a name="779"></a>        }
<a name="780"></a>
<a name="781"></a>        /* we can't move it - report the failure and abort the action */
<a name="782"></a>        targetLoc.mustMoveObjInto(moveObj);
<a name="783"></a>        exit;
<a name="784"></a>    }
<a name="785"></a>;
<a name="786"></a>
<a name="787"></a>/*
<a name="788"></a> *   require that the target object be in the same immediate location as
<a name="789"></a> *   the direct object
<a name="790"></a> */
<a name="791"></a>sameLocationAsDobj: SameLocationCondition
<a name="792"></a>    sourceObj = (gDobj)
<a name="793"></a>;
<a name="794"></a>
<a name="795"></a>/*
<a name="796"></a> *   require that the target object be in the same immediate location as
<a name="797"></a> *   the indirect object
<a name="798"></a> */
<a name="799"></a>sameLocationAsIobj: SameLocationCondition
<a name="800"></a>    sourceObj = (gIobj)
<a name="801"></a>;
<a name="802"></a>
<a name="803"></a>/* ------------------------------------------------------------------------ */
<a name="804"></a>/*
<a name="805"></a> *   Pre-condition: actor must have room to hold the object directly (such
<a name="806"></a> *   as in the actor's hands).  We'll let the actor do the work.
<a name="807"></a> */
<a name="808"></a>roomToHoldObj: PreCondition
<a name="809"></a>    checkPreCondition(obj, allowImplicit)
<a name="810"></a>    {
<a name="811"></a>        /* let the actor check the precondition */
<a name="812"></a>        return gActor.tryMakingRoomToHold(obj, allowImplicit);
<a name="813"></a>    }
<a name="814"></a>;
<a name="815"></a>
<a name="816"></a>/* ------------------------------------------------------------------------ */
<a name="817"></a>/*
<a name="818"></a> *   Pre-condition: the actor must not be wearing the object.  If the
<a name="819"></a> *   actor is currently wearing the object, we'll try asking the actor to
<a name="820"></a> *   doff the object.
<a name="821"></a> *
<a name="822"></a> *   Note that this pre-condition never needs to be combined with objHeld,
<a name="823"></a> *   because an object being worn is not considered to be held, and
<a name="824"></a> *   Wearable implicitly doffs an article when it must be held.
<a name="825"></a> */
<a name="826"></a>objNotWorn: PreCondition
<a name="827"></a>    checkPreCondition(obj, allowImplicit)
<a name="828"></a>    {
<a name="829"></a>        /* if the object isn't being worn, we have nothing to do */
<a name="830"></a>        if (obj == nil || !obj.isWornBy(gActor))
<a name="831"></a>            return nil;
<a name="832"></a>
<a name="833"></a>        /* try an implicit 'doff' command */
<a name="834"></a>        if (allowImplicit &amp;&amp; tryImplicitAction(Doff, obj))
<a name="835"></a>        {
<a name="836"></a>            /*
<a name="837"></a>             *   we executed the command - make sure it worked, and abort
<a name="838"></a>             *   if it didn't
<a name="839"></a>             */
<a name="840"></a>            if (obj.isWornBy(gActor))
<a name="841"></a>                exit;
<a name="842"></a>
<a name="843"></a>            /* tell the caller we executed an implicit command */
<a name="844"></a>            return true;
<a name="845"></a>        }
<a name="846"></a>
<a name="847"></a>        /* report the problem and terminate the command */
<a name="848"></a>        reportFailure(&amp;cannotBeWearingMsg, obj);
<a name="849"></a>
<a name="850"></a>        /* make it the pronoun */
<a name="851"></a>        gActor.setPronounObj(obj);
<a name="852"></a>
<a name="853"></a>        /* abort the command */
<a name="854"></a>        exit;
<a name="855"></a>    }
<a name="856"></a>
<a name="857"></a>    /* lower the likelihood rating for anything being worn */
<a name="858"></a>    verifyPreCondition(obj)
<a name="859"></a>    {
<a name="860"></a>        /* if the object is being worn, reduce its likelihood rating */
<a name="861"></a>        if (obj != nil &amp;&amp; obj.isWornBy(gActor))
<a name="862"></a>            logicalRankOrd(80, 'implied doff', 150);
<a name="863"></a>    }
<a name="864"></a>;
<a name="865"></a>
<a name="866"></a>/* ------------------------------------------------------------------------ */
<a name="867"></a>/*
<a name="868"></a> *   Pre-condition: the object is open.
<a name="869"></a> */
<a name="870"></a>class ObjOpenCondition: PreCondition
<a name="871"></a>    checkPreCondition(obj, allowImplicit)
<a name="872"></a>    {
<a name="873"></a>        /* if the object is already open, we're already done */
<a name="874"></a>        if (obj == nil || obj.isOpen)
<a name="875"></a>            return nil;
<a name="876"></a>
<a name="877"></a>        /* try an implicit 'open' command on the object */
<a name="878"></a>        if (allowImplicit &amp;&amp; tryImplicitAction(Open, obj))
<a name="879"></a>        {
<a name="880"></a>            /*
<a name="881"></a>             *   we executed the command - make sure it worked, and abort
<a name="882"></a>             *   if it didn't
<a name="883"></a>             */
<a name="884"></a>            if (!obj.isOpen)
<a name="885"></a>                exit;
<a name="886"></a>
<a name="887"></a>            /* tell the caller we executed an implied command */
<a name="888"></a>            return true;
<a name="889"></a>        }
<a name="890"></a>
<a name="891"></a>        /* can't open it implicitly - report the failure */
<a name="892"></a>        conditionFailed(obj);
<a name="893"></a>        exit;
<a name="894"></a>    }
<a name="895"></a>
<a name="896"></a>    /*
<a name="897"></a>     *   The condition failed - report the failure and give up.  We
<a name="898"></a>     *   separate this to allow subclasses to report failure differently
<a name="899"></a>     *   for specialized types of opening.
<a name="900"></a>     */
<a name="901"></a>    conditionFailed(obj)
<a name="902"></a>    {
<a name="903"></a>        /* can't open it implicitly - report failure and give up */
<a name="904"></a>        reportFailure(&amp;mustBeOpenMsg, obj);
<a name="905"></a>
<a name="906"></a>        /* make it the pronoun */
<a name="907"></a>        gActor.setPronounObj(obj);
<a name="908"></a>    }
<a name="909"></a>
<a name="910"></a>    /* reduce the likelihood rating for anything that isn't already open */
<a name="911"></a>    verifyPreCondition(obj)
<a name="912"></a>    {
<a name="913"></a>        /* if the object is closed, reduce its likelihood rating */
<a name="914"></a>        if (obj != nil &amp;&amp; !obj.isOpen)
<a name="915"></a>            logicalRankOrd(80, 'implied open', 150);
<a name="916"></a>    }
<a name="917"></a>;
<a name="918"></a>
<a name="919"></a>/*
<a name="920"></a> *   The basic object-open condition
<a name="921"></a> */
<a name="922"></a>objOpen: ObjOpenCondition;
<a name="923"></a>
<a name="924"></a>/*
<a name="925"></a> *   Pre-condition: a door must be open.  This differs from the regular
<a name="926"></a> *   objOpen condition only in that we use a customized version of the
<a name="927"></a> *   failure report.
<a name="928"></a> */
<a name="929"></a>doorOpen: ObjOpenCondition
<a name="930"></a>    conditionFailed(obj)
<a name="931"></a>    {
<a name="932"></a>        /*
<a name="933"></a>         *   We can generate implicit open-door commands as a result of
<a name="934"></a>         *   travel, which means that the actor issuing the command might
<a name="935"></a>         *   never have explicitly referred to the door.  (This is not the
<a name="936"></a>         *   case for most preconditions, which refer to objects directly
<a name="937"></a>         *   used in the command and thus within the actor's awareness, at
<a name="938"></a>         *   least initially.)  So, if the door isn't visible to the
<a name="939"></a>         *   actor, don't tell the actor they have to open the door;
<a name="940"></a>         *   instead, just show the standard no-travel message for the
<a name="941"></a>         *   door.
<a name="942"></a>         */
<a name="943"></a>        if (gActor.canSee(obj))
<a name="944"></a>        {
<a name="945"></a>            /* they can see the door, so tell them they need to open it */
<a name="946"></a>            reportFailure(&amp;mustOpenDoorMsg, obj);
<a name="947"></a>
<a name="948"></a>            /* set this as the pronoun antecedent */
<a name="949"></a>            gActor.setPronounObj(obj);
<a name="950"></a>        }
<a name="951"></a>        else
<a name="952"></a>        {
<a name="953"></a>            /*
<a name="954"></a>             *   they can't see the door - call the door's routine to
<a name="955"></a>             *   indicate that travel is not possible
<a name="956"></a>             */
<a name="957"></a>            obj.cannotTravel();
<a name="958"></a>        }
<a name="959"></a>    }
<a name="960"></a>;
<a name="961"></a>
<a name="962"></a>/* ------------------------------------------------------------------------ */
<a name="963"></a>/*
<a name="964"></a> *   Pre-condition: the object is closed.
<a name="965"></a> */
<a name="966"></a>objClosed: PreCondition
<a name="967"></a>    checkPreCondition(obj, allowImplicit)
<a name="968"></a>    {
<a name="969"></a>        /* if the object is already closed, we're already done */
<a name="970"></a>        if (obj == nil || !obj.isOpen)
<a name="971"></a>            return nil;
<a name="972"></a>
<a name="973"></a>        /* try an implicit 'close' command on the object */
<a name="974"></a>        if (allowImplicit &amp;&amp; tryImplicitAction(Close, obj))
<a name="975"></a>        {
<a name="976"></a>            /*
<a name="977"></a>             *   we executed the command - make sure it worked, and abort
<a name="978"></a>             *   if it didn't
<a name="979"></a>             */
<a name="980"></a>            if (obj.isOpen)
<a name="981"></a>                exit;
<a name="982"></a>
<a name="983"></a>            /* tell the caller we executed an implied command */
<a name="984"></a>            return true;
<a name="985"></a>        }
<a name="986"></a>
<a name="987"></a>        /* can't close it implicitly - report failure and give up */
<a name="988"></a>        reportFailure(&amp;mustBeClosedMsg, obj);
<a name="989"></a>
<a name="990"></a>        /* make it the pronoun */
<a name="991"></a>        gActor.setPronounObj(obj);
<a name="992"></a>
<a name="993"></a>        /* abort the command */
<a name="994"></a>        exit;
<a name="995"></a>    }
<a name="996"></a>
<a name="997"></a>    /* reduce the likelihood rating for anything that isn't already closed */
<a name="998"></a>    verifyPreCondition(obj)
<a name="999"></a>    {
<a name="1000"></a>        /* if the object is closed, reduce its likelihood rating */
<a name="1001"></a>        if (obj != nil &amp;&amp; obj.isOpen)
<a name="1002"></a>            logicalRankOrd(80, 'implied close', 150);
<a name="1003"></a>    }
<a name="1004"></a>;
<a name="1005"></a>
<a name="1006"></a>/* ------------------------------------------------------------------------ */
<a name="1007"></a>/*
<a name="1008"></a> *   Pre-condition: the object is unlocked.
<a name="1009"></a> */
<a name="1010"></a>objUnlocked: PreCondition
<a name="1011"></a>    checkPreCondition(obj, allowImplicit)
<a name="1012"></a>    {
<a name="1013"></a>        /* if the object is already unlocked, we're already done */
<a name="1014"></a>        if (obj == nil || !obj.isLocked)
<a name="1015"></a>            return nil;
<a name="1016"></a>
<a name="1017"></a>        /* try an implicit 'unlock' command on the object */
<a name="1018"></a>        if (allowImplicit &amp;&amp; tryImplicitAction(Unlock, obj))
<a name="1019"></a>        {
<a name="1020"></a>            /*
<a name="1021"></a>             *   we executed the command - make sure it worked, and abort
<a name="1022"></a>             *   if it didn't
<a name="1023"></a>             */
<a name="1024"></a>            if (obj.isLocked)
<a name="1025"></a>                exit;
<a name="1026"></a>
<a name="1027"></a>            /* tell the caller we executed an implied command */
<a name="1028"></a>            return true;
<a name="1029"></a>        }
<a name="1030"></a>
<a name="1031"></a>        /* can't unlock it implicitly - report failure and give up */
<a name="1032"></a>        reportFailure(&amp;mustBeUnlockedMsg, obj);
<a name="1033"></a>
<a name="1034"></a>        /* make it the pronoun */
<a name="1035"></a>        gActor.setPronounObj(obj);
<a name="1036"></a>
<a name="1037"></a>        /* abort the command */
<a name="1038"></a>        exit;
<a name="1039"></a>    }
<a name="1040"></a>
<a name="1041"></a>    /* reduce the likelihood rating for anything that's locked */
<a name="1042"></a>    verifyPreCondition(obj)
<a name="1043"></a>    {
<a name="1044"></a>        /* if the object is locked, reduce its likelihood rating */
<a name="1045"></a>        if (obj != nil &amp;&amp; obj.isLocked)
<a name="1046"></a>            logicalRankOrd(80, 'implied unlock', 150);
<a name="1047"></a>    }
<a name="1048"></a>;
<a name="1049"></a>
<a name="1050"></a>/* ------------------------------------------------------------------------ */
<a name="1051"></a>/*
<a name="1052"></a> *   Pre-condition: destination for "drop" is an outermost room.  If the
<a name="1053"></a> *   drop destination is a nested room, we'll try returning the actor to
<a name="1054"></a> *   the outermost room via an implicit command.
<a name="1055"></a> */
<a name="1056"></a>dropDestinationIsOuterRoom: PreCondition
<a name="1057"></a>    checkPreCondition(obj, allowImplicit)
<a name="1058"></a>    {
<a name="1059"></a>        local dest;
<a name="1060"></a>
<a name="1061"></a>        /*
<a name="1062"></a>         *   if the actor's location's drop location is the outermost
<a name="1063"></a>         *   room, we don't need to do anything special
<a name="1064"></a>         */
<a name="1065"></a>        dest = gActor.getDropDestination(obj, nil);
<a name="1066"></a>        if (dest.getOutermostRoom() == dest)
<a name="1067"></a>            return nil;
<a name="1068"></a>
<a name="1069"></a>        /*
<a name="1070"></a>         *   the default drop destination is not an outermost room; try an
<a name="1071"></a>         *   implicit command to return the actor to an outermost room
<a name="1072"></a>         */
<a name="1073"></a>        return actorDirectlyInRoom.checkPreCondition(
<a name="1074"></a>            dest.getOutermostRoom(), allowImplicit);
<a name="1075"></a>    }
<a name="1076"></a>;
<a name="1077"></a>
<a name="1078"></a>/* ------------------------------------------------------------------------ */
<a name="1079"></a>/*
<a name="1080"></a> *   Pre-condition: object is burning.  This can be used for matches,
<a name="1081"></a> *   candles, and the like.  If the object's isLit is nil, we'll attempt a
<a name="1082"></a> *   "burn" command on the object.
<a name="1083"></a> */
<a name="1084"></a>objBurning: PreCondition
<a name="1085"></a>    checkPreCondition(obj, allowImplicit)
<a name="1086"></a>    {
<a name="1087"></a>        /* if it's already burning, there's nothing to do */
<a name="1088"></a>        if (obj == nil || obj.isLit)
<a name="1089"></a>            return nil;
<a name="1090"></a>
<a name="1091"></a>        /* try an implicit 'burn' command */
<a name="1092"></a>        if (allowImplicit &amp;&amp; tryImplicitAction(Burn, obj))
<a name="1093"></a>        {
<a name="1094"></a>            /* we executed a 'burn' - give up if it didn't work */
<a name="1095"></a>            if (!obj.isLit)
<a name="1096"></a>                exit;
<a name="1097"></a>
<a name="1098"></a>            /* tell the caller we executed an implied command */
<a name="1099"></a>            return true;
<a name="1100"></a>        }
<a name="1101"></a>
<a name="1102"></a>        /* we can't burn it implicitly - report failure and give up */
<a name="1103"></a>        reportFailure(&amp;mustBeBurningMsg, obj);
<a name="1104"></a>
<a name="1105"></a>        /* make it the pronoun */
<a name="1106"></a>        gActor.setPronounObj(obj);
<a name="1107"></a>
<a name="1108"></a>        /* abort the command */
<a name="1109"></a>        exit;
<a name="1110"></a>    }
<a name="1111"></a>
<a name="1112"></a>    verifyPreCondition(obj)
<a name="1113"></a>    {
<a name="1114"></a>        /* if the object is not already burning, reduce its likelihood */
<a name="1115"></a>        if (obj != nil &amp;&amp; !obj.isLit)
<a name="1116"></a>            logicalRankOrd(80, 'implied burn', 150);
<a name="1117"></a>    }
<a name="1118"></a>;
<a name="1119"></a>
<a name="1120"></a>
<a name="1121"></a>/* ------------------------------------------------------------------------ */
<a name="1122"></a>/*
<a name="1123"></a> *   Pre-condition: the object is empty.  This ensures that the object
<a name="1124"></a> *   does not contain any other objects.
<a name="1125"></a> *
<a name="1126"></a> *   Note that we unconditionally try to remove all objects.  If a
<a name="1127"></a> *   container needs to have some objects that can be removed and others
<a name="1128"></a> *   that can't (such as components within the container), then the
<a name="1129"></a> *   container will have to be implemented as a ComplexContainer - the
<a name="1130"></a> *   non-removable components should be made contents of the enclosing
<a name="1131"></a> *   ComplexContainer, and the secret inner container should be the one
<a name="1132"></a> *   subject to this precondition.
<a name="1133"></a> */
<a name="1134"></a>objEmpty: PreCondition
<a name="1135"></a>    checkPreCondition(obj, allowImplicit)
<a name="1136"></a>    {
<a name="1137"></a>        local chi;
<a name="1138"></a>
<a name="1139"></a>        /*
<a name="1140"></a>         *   if there's no object, or the object already has no contents,
<a name="1141"></a>         *   there's nothing to do
<a name="1142"></a>         */
<a name="1143"></a>        if (obj == nil || obj.contents.length() == 0)
<a name="1144"></a>            return nil;
<a name="1145"></a>
<a name="1146"></a>        /*
<a name="1147"></a>         *   Try an implicit 'take x' on the object's first child.
<a name="1148"></a>         *
<a name="1149"></a>         *   Note that we only try this on the first object, because the
<a name="1150"></a>         *   precondition mechanism automatically re-applies all
<a name="1151"></a>         *   preconditions after any one of them performs an implied
<a name="1152"></a>         *   command.  If we have multiple objects that must be removed,
<a name="1153"></a>         *   that basic loop will ensure that we'll come back here as many
<a name="1154"></a>         *   times as necessary.
<a name="1155"></a>         */
<a name="1156"></a>        chi = obj.contents[1];
<a name="1157"></a>        if (allowImplicit &amp;&amp; tryImplicitAction(TakeFrom, chi, obj))
<a name="1158"></a>        {
<a name="1159"></a>            /* make sure it worked */
<a name="1160"></a>            if (chi.isIn(obj))
<a name="1161"></a>                exit;
<a name="1162"></a>
<a name="1163"></a>            /* tell the caller we tried an implied command */
<a name="1164"></a>            return true;
<a name="1165"></a>        }
<a name="1166"></a>
<a name="1167"></a>        /* we can't remove the objects implicitly, so give up */
<a name="1168"></a>        reportFailure(&amp;mustBeEmptyMsg, obj);
<a name="1169"></a>
<a name="1170"></a>        /* make it the pronoun */
<a name="1171"></a>        gActor.setPronounObj(obj);
<a name="1172"></a>
<a name="1173"></a>        /* abort the command */
<a name="1174"></a>        exit;
<a name="1175"></a>    }
<a name="1176"></a>;
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
