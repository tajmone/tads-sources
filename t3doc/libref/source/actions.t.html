<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>actions.t</title></head><body>
<table class=ban><tr><td><h1>actions.t</h1><td align=right><a href="../file/actions.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library: Actions.
<a name="7"></a> *
<a name="8"></a> *   This module defines the set of built-in library actions.
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>#include "adv3.h"
<a name="12"></a>#include "tok.h"
<a name="13"></a>
<a name="14"></a>/* ------------------------------------------------------------------------ */
<a name="15"></a>/*
<a name="16"></a> *   Special "debug" action - this simply breaks into the debugger, if the
<a name="17"></a> *   debugger is present.
<a name="18"></a> */
<a name="19"></a>DefineIAction(Debug)
<a name="20"></a>    execAction()
<a name="21"></a>    {
<a name="22"></a>        /* if the debugger is present, break into it */
<a name="23"></a>        if (t3DebugTrace(T3DebugCheck))
<a name="24"></a>            t3DebugTrace(T3DebugBreak);
<a name="25"></a>        else
<a name="26"></a>            "Debugger not present. ";
<a name="27"></a>    }
<a name="28"></a>;
<a name="29"></a>
<a name="30"></a>/* ------------------------------------------------------------------------ */
<a name="31"></a>/*
<a name="32"></a> *   Special internal action to note a change to the darkness level.  This
<a name="33"></a> *   command is invoked internally when a change to the darkness level
<a name="34"></a> *   occurs.
<a name="35"></a> */
<a name="36"></a>DefineIAction(NoteDarkness)
<a name="37"></a>    execAction()
<a name="38"></a>    {
<a name="39"></a>        /*
<a name="40"></a>         *   if we're in the dark, note that darkness has fallen;
<a name="41"></a>         *   otherwise, show the player character's room description as
<a name="42"></a>         *   though the player had typed "look"
<a name="43"></a>         */
<a name="44"></a>        if (gActor.isLocationLit())
<a name="45"></a>        {
<a name="46"></a>            /* look around */
<a name="47"></a>            gActor.lookAround(true);
<a name="48"></a>        }
<a name="49"></a>        else
<a name="50"></a>        {
<a name="51"></a>            /* it is now dark */
<a name="52"></a>            mainReport(&amp;newlyDarkMsg);
<a name="53"></a>        }
<a name="54"></a>    }
<a name="55"></a>
<a name="56"></a>    /* this is an internal command that takes no time */
<a name="57"></a>    actionTime = 0
<a name="58"></a>
<a name="59"></a>    /* this isn't a real action, so it's not repeatable */
<a name="60"></a>    isRepeatable = nil
<a name="61"></a>
<a name="62"></a>    /* this action doesn't do anything; don't include it in undo */
<a name="63"></a>    includeInUndo = nil
<a name="64"></a>;
<a name="65"></a>
<a name="66"></a>/* ------------------------------------------------------------------------ */
<a name="67"></a>/*
<a name="68"></a> *   Special "again" action.  This command repeats the previous command.
<a name="69"></a> */
<a name="70"></a>DefineIAction(Again)
<a name="71"></a>    /* for obvious reasons, 'again' is not itself repeatable with 'again' */
<a name="72"></a>    isRepeatable = nil
<a name="73"></a>
<a name="74"></a>    /*
<a name="75"></a>     *   the undo command itself is not undoable (but the underlying
<a name="76"></a>     *   command that we repeat might be)
<a name="77"></a>     */
<a name="78"></a>    includeInUndo = nil
<a name="79"></a>
<a name="80"></a>    /* information on the most recent command */
<a name="81"></a>    lastIssuingActor = nil
<a name="82"></a>    lastTargetActor = nil
<a name="83"></a>    lastTargetActorPhrase = nil
<a name="84"></a>    lastAction = nil
<a name="85"></a>
<a name="86"></a>    /* save the most recent command so that it can be repeated if desired */
<a name="87"></a>    saveForAgain(issuingActor, targetActor, targetActorPhrase, action)
<a name="88"></a>    {
<a name="89"></a>        /* save the information */
<a name="90"></a>        lastIssuingActor = issuingActor;
<a name="91"></a>        lastTargetActor = targetActor;
<a name="92"></a>        lastTargetActorPhrase = targetActorPhrase;
<a name="93"></a>        lastAction = action.createClone();
<a name="94"></a>    }
<a name="95"></a>
<a name="96"></a>    /* forget the last command, so that AGAIN cannot be used */
<a name="97"></a>    clearForAgain() { lastAction = nil; }
<a name="98"></a>
<a name="99"></a>    /*
<a name="100"></a>     *   Execute the 'again' command.  This action is special enough that
<a name="101"></a>     *   we override its entire action processing sequence - this is
<a name="102"></a>     *   necessary in case we're repeating another special command, such
<a name="103"></a>     *   as 'again', and in any case is desirable because we don't want
<a name="104"></a>     *   'again' to count as a command in its own right; it's essentially
<a name="105"></a>     *   just a macro that we replace with the original command.
<a name="106"></a>     */
<a name="107"></a>    doAction(issuingActor, targetActor, targetActorPhrase,
<a name="108"></a>             countsAsIssuerTurn)
<a name="109"></a>    {
<a name="110"></a>        /* if there's nothing to repeat, show an error and give up */
<a name="111"></a>        if (lastAction == nil)
<a name="112"></a>        {
<a name="113"></a>            gLibMessages.noCommandForAgain();
<a name="114"></a>            return;
<a name="115"></a>        }
<a name="116"></a>
<a name="117"></a>        /*
<a name="118"></a>         *   'again' cannot be executed with a target actor - the target
<a name="119"></a>         *   actor must be the player character
<a name="120"></a>         */
<a name="121"></a>        if (!targetActor.isPlayerChar)
<a name="122"></a>        {
<a name="123"></a>            gLibMessages.againCannotChangeActor();
<a name="124"></a>            return;
<a name="125"></a>        }
<a name="126"></a>
<a name="127"></a>        /*
<a name="128"></a>         *   if the issuing actor isn't the same as the target actor, make
<a name="129"></a>         *   sure the issuer can still talk to the target
<a name="130"></a>         */
<a name="131"></a>        if (lastIssuingActor != lastTargetActor
<a name="132"></a>            &amp;&amp; !lastIssuingActor.canTalkTo(lastTargetActor))
<a name="133"></a>        {
<a name="134"></a>            /* complain that we can no longer talk to the target */
<a name="135"></a>            gLibMessages.againCannotTalkToTarget(
<a name="136"></a>                lastIssuingActor, lastTargetActor);
<a name="137"></a>            return;
<a name="138"></a>        }
<a name="139"></a>
<a name="140"></a>        /*
<a name="141"></a>         *   If the last issuing actor is different from the last target
<a name="142"></a>         *   actor, then the command counts as an issuer turn, because
<a name="143"></a>         *   we're effectively repeating the entire last command, including
<a name="144"></a>         *   the target actor specification.  That is, after a command like
<a name="145"></a>         *   "bob, go east", saying "again" is just like saying "bob, go
<a name="146"></a>         *   east" again, which counts as an issuer turn.
<a name="147"></a>         */
<a name="148"></a>        if (lastTargetActor != lastIssuingActor)
<a name="149"></a>            countsAsIssuerTurn = true;
<a name="150"></a>
<a name="151"></a>        /* reset any cached information for the new command context */
<a name="152"></a>        lastAction.resetAction();
<a name="153"></a>
<a name="154"></a>        /* repeat the action */
<a name="155"></a>        lastAction.repeatAction(lastTargetActor, lastTargetActorPhrase,
<a name="156"></a>                                lastIssuingActor, countsAsIssuerTurn);
<a name="157"></a>
<a name="158"></a>        /*
<a name="159"></a>         *   If the command was directed from the issuer to a different
<a name="160"></a>         *   target actor, and the issuer wants to wait for the full set of
<a name="161"></a>         *   issued commands to complete before getting another turn, tell
<a name="162"></a>         *   the issuer to begin waiting.
<a name="163"></a>         */
<a name="164"></a>        if (lastTargetActor != lastIssuingActor)
<a name="165"></a>            lastIssuingActor.waitForIssuedCommand(lastTargetActor);
<a name="166"></a>    }
<a name="167"></a>
<a name="168"></a>    /*
<a name="169"></a>     *   this command itself consumes no time on the game clock (although
<a name="170"></a>     *   the action we perform might)
<a name="171"></a>     */
<a name="172"></a>    actionTime = 0
<a name="173"></a>;
<a name="174"></a>
<a name="175"></a>/* ------------------------------------------------------------------------ */
<a name="176"></a>/*
<a name="177"></a> *   PreSaveObject - every instance of this class is notified, via its
<a name="178"></a> *   execute() method, just before we save the game.  This uses the
<a name="179"></a> *   ModuleExecObject framework, so the sequencing lists (execBeforeMe,
<a name="180"></a> *   execAfterMe) can be used to control relative ordering of execution
<a name="181"></a> *   among instances.
<a name="182"></a> */
<a name="183"></a>class PreSaveObject: ModuleExecObject
<a name="184"></a>    /*
<a name="185"></a>     *   Each instance must override execute() with its specific pre-save
<a name="186"></a>     *   code.
<a name="187"></a>     */
<a name="188"></a>;
<a name="189"></a>
<a name="190"></a>/*
<a name="191"></a> *   PostRestoreObject - every instance of this class is notified, via its
<a name="192"></a> *   execute() method, immediately after we restore the game.
<a name="193"></a> */
<a name="194"></a>class PostRestoreObject: ModuleExecObject
<a name="195"></a>    /*
<a name="196"></a>     *   note: each instance must override execute() with its post-restore
<a name="197"></a>     *   code
<a name="198"></a>     */
<a name="199"></a>
<a name="200"></a>    /*
<a name="201"></a>     *   The "restore code," which is the (normally integer) value passed
<a name="202"></a>     *   as the second argument to restoreGame().  The restore code gives
<a name="203"></a>     *   us some idea of what triggered the restoration.  By default, we
<a name="204"></a>     *   define the following restore codes:
<a name="205"></a>     *
<a name="206"></a>     *   1 - the system is restoring a game as part of interpreter
<a name="207"></a>     *   startup, usually because the user explicitly specified a game to
<a name="208"></a>     *   restore on the interpreter command line or via a GUI shell
<a name="209"></a>     *   mechanism, such as double-clicking on a saved game file from the
<a name="210"></a>     *   desktop.
<a name="211"></a>     *
<a name="212"></a>     *   2 - the user is explicitly restoring a game via a RESTORE command.
<a name="213"></a>     *
<a name="214"></a>     *   Games and library extensions can use their own additional restore
<a name="215"></a>     *   codes in their calls to restoreGame().
<a name="216"></a>     */
<a name="217"></a>    restoreCode = nil
<a name="218"></a>;
<a name="219"></a>
<a name="220"></a>/*
<a name="221"></a> *   PreRestartObject - every instance of this class is notified, via its
<a name="222"></a> *   execute() method, just before we restart the game (with a RESTART
<a name="223"></a> *   command, for example).
<a name="224"></a> */
<a name="225"></a>class PreRestartObject: ModuleExecObject
<a name="226"></a>    /*
<a name="227"></a>     *   Each instance must override execute() with its specific
<a name="228"></a>     *   pre-restart code.
<a name="229"></a>     */
<a name="230"></a>;
<a name="231"></a>
<a name="232"></a>/*
<a name="233"></a> *   PostUndoObject - every instance of this class is notified, via its
<a name="234"></a> *   execute() method, immediately after we perform an 'undo' command.
<a name="235"></a> */
<a name="236"></a>class PostUndoObject: ModuleExecObject
<a name="237"></a>    /*
<a name="238"></a>     *   Each instance must override execute() with its specific post-undo
<a name="239"></a>     *   code.
<a name="240"></a>     */
<a name="241"></a>;
<a name="242"></a>
<a name="243"></a>/* ------------------------------------------------------------------------ */
<a name="244"></a>/*
<a name="245"></a> *   Special "save" action.  This command saves the current game state to
<a name="246"></a> *   an external file for later restoration.
<a name="247"></a> */
<a name="248"></a>DefineAction(Save, FileOpAction)
<a name="249"></a>    /* the file dialog prompt */
<a name="250"></a>    filePromptMsg = (gLibMessages.getSavePrompt())
<a name="251"></a>
<a name="252"></a>    /* we're asking for a file to save, or type t3-save */
<a name="253"></a>    fileDisposition = InFileSave
<a name="254"></a>    fileTypeID = FileTypeT3Save
<a name="255"></a>
<a name="256"></a>    /* cancel message */
<a name="257"></a>    showCancelMsg() { gLibMessages.saveCanceled(); }
<a name="258"></a>
<a name="259"></a>    /* perform a save */
<a name="260"></a>    performFileOp(fname, ack, desc:?)
<a name="261"></a>    {
<a name="262"></a>        /* before saving the game, notify all PreSaveObject instances */
<a name="263"></a>        PreSaveObject.classExec();
<a name="264"></a>
<a name="265"></a>        /*
<a name="266"></a>         *   Save the game to the given file.  If an error occurs, the
<a name="267"></a>         *   save routine will throw a runtime error.
<a name="268"></a>         */
<a name="269"></a>        try
<a name="270"></a>        {
<a name="271"></a>            /* try saving the game */
<a name="272"></a>            saveGame(fname, gameMain.getSaveDesc(desc));
<a name="273"></a>        }
<a name="274"></a>        catch (StorageServerError sse)
<a name="275"></a>        {
<a name="276"></a>            /* the save failed due to a storage server problem - explain */
<a name="277"></a>            gLibMessages.saveFailedOnServer(sse);
<a name="278"></a>
<a name="279"></a>            /* done */
<a name="280"></a>            return;
<a name="281"></a>        }
<a name="282"></a>        catch (RuntimeError err)
<a name="283"></a>        {
<a name="284"></a>            /* the save failed - mention the problem */
<a name="285"></a>            gLibMessages.saveFailed(err);
<a name="286"></a>
<a name="287"></a>            /* done */
<a name="288"></a>            return;
<a name="289"></a>        }
<a name="290"></a>
<a name="291"></a>        /* note the successful save */
<a name="292"></a>        gLibMessages.saveOkay();
<a name="293"></a>    }
<a name="294"></a>
<a name="295"></a>    /*
<a name="296"></a>     *   Saving has no effect on game state, so it's irrelevant whether or
<a name="297"></a>     *   not it's undoable; but it might be confusing to say we undid a
<a name="298"></a>     *   "save" command, because the player might think we deleted the
<a name="299"></a>     *   saved file.  To avoid such confusion, do not include "save"
<a name="300"></a>     *   commands in the undo log.
<a name="301"></a>     */
<a name="302"></a>    includeInUndo = nil
<a name="303"></a>
<a name="304"></a>    /*
<a name="305"></a>     *   Don't allow this to be repeated with AGAIN.  There's no point in
<a name="306"></a>     *   repeating a SAVE immediately, as nothing will have changed in the
<a name="307"></a>     *   game state to warrant saving again.
<a name="308"></a>     */
<a name="309"></a>    isRepeatable = nil
<a name="310"></a>;
<a name="311"></a>
<a name="312"></a>/*
<a name="313"></a> *   Subclass of Save action that takes a literal string as part of the
<a name="314"></a> *   command.  The filename must be a literal enclosed in quotes, and the
<a name="315"></a> *   string (with the quotes) must be stored in our fname_ property by
<a name="316"></a> *   assignment of a quotedStringPhrase production in the grammar rule.
<a name="317"></a> */
<a name="318"></a>DefineAction(SaveString, SaveAction)
<a name="319"></a>    execSystemAction()
<a name="320"></a>    {
<a name="321"></a>        /*
<a name="322"></a>         *   Perform the save, using the filename given in our fname_
<a name="323"></a>         *   parameter, trimmed of quotes.
<a name="324"></a>         */
<a name="325"></a>        performFileOp(fname_.getStringText(), true);
<a name="326"></a>    }
<a name="327"></a>;
<a name="328"></a>
<a name="329"></a>
<a name="330"></a>/* ------------------------------------------------------------------------ */
<a name="331"></a>/*
<a name="332"></a> *   Special "restore" action.  This action restores game state previously
<a name="333"></a> *   saved with the "save" action.
<a name="334"></a> */
<a name="335"></a>DefineSystemAction(Restore)
<a name="336"></a>    execSystemAction()
<a name="337"></a>    {
<a name="338"></a>        /* ask for a file and restore it */
<a name="339"></a>        askAndRestore();
<a name="340"></a>
<a name="341"></a>        /*
<a name="342"></a>         *   regardless of what happened, abandon any additional commands
<a name="343"></a>         *   on the same command line
<a name="344"></a>         */
<a name="345"></a>        throw new TerminateCommandException();
<a name="346"></a>    }
<a name="347"></a>
<a name="348"></a>    /*
<a name="349"></a>     *   Ask for a file and try to restore it.  Returns true on success,
<a name="350"></a>     *   nil on failure.  (Failure could indicate that the user chose to
<a name="351"></a>     *   cancel out of the file selector, that we couldn't find the file to
<a name="352"></a>     *   restore, or that the file isn't a valid saved state file.  In any
<a name="353"></a>     *   case, we show an appropriate message on failure.)
<a name="354"></a>     */
<a name="355"></a>    askAndRestore()
<a name="356"></a>    {
<a name="357"></a>        local succ;
<a name="358"></a>        local result;
<a name="359"></a>        local origElapsedTime;
<a name="360"></a>
<a name="361"></a>        /* presume failure */
<a name="362"></a>        succ = nil;
<a name="363"></a>
<a name="364"></a>        /* note the current elapsed game time */
<a name="365"></a>        origElapsedTime = realTimeManager.getElapsedTime();
<a name="366"></a>
<a name="367"></a>        /* ask for a file */
<a name="368"></a>        result = getInputFile(gLibMessages.getRestorePrompt(), InFileOpen,
<a name="369"></a>                              FileTypeT3Save, 0);
<a name="370"></a>
<a name="371"></a>        /*
<a name="372"></a>         *   restore the real-time clock, so that the time spent in the
<a name="373"></a>         *   file selector dialog doesn't count against the game time
<a name="374"></a>         */
<a name="375"></a>        realTimeManager.setElapsedTime(origElapsedTime);
<a name="376"></a>
<a name="377"></a>        /* check the inputFile response */
<a name="378"></a>        switch(result[1])
<a name="379"></a>        {
<a name="380"></a>        case InFileSuccess:
<a name="381"></a>            /*
<a name="382"></a>             *   try restoring the file; use code 2 to indicate that the
<a name="383"></a>             *   restoration was performed by an explicit RESTORE command
<a name="384"></a>             */
<a name="385"></a>            if (performRestore(result[2], 2))
<a name="386"></a>            {
<a name="387"></a>                /* note that we succeeded */
<a name="388"></a>                succ = true;
<a name="389"></a>            }
<a name="390"></a>            else
<a name="391"></a>            {
<a name="392"></a>                /*
<a name="393"></a>                 *   failed - in case the failed restore took some time,
<a name="394"></a>                 *   restore the real-time clock, so that the file-reading
<a name="395"></a>                 *   time doesn't count against the game time
<a name="396"></a>                 */
<a name="397"></a>                realTimeManager.setElapsedTime(origElapsedTime);
<a name="398"></a>            }
<a name="399"></a>
<a name="400"></a>            /* done */
<a name="401"></a>            break;
<a name="402"></a>
<a name="403"></a>        case InFileFailure:
<a name="404"></a>            /* advise of the failure of the prompt */
<a name="405"></a>            if (result.length() &gt; 1)
<a name="406"></a>                gLibMessages.filePromptFailedMsg(result[2]);
<a name="407"></a>            else
<a name="408"></a>                gLibMessages.filePromptFailed();
<a name="409"></a>            break;
<a name="410"></a>
<a name="411"></a>        case InFileCancel:
<a name="412"></a>            /* acknowledge the cancellation */
<a name="413"></a>            gLibMessages.restoreCanceled();
<a name="414"></a>            break;
<a name="415"></a>        }
<a name="416"></a>
<a name="417"></a>        /*
<a name="418"></a>         *   If we were successful, clear out the AGAIN memory.  This
<a name="419"></a>         *   avoids any confusion about whether we're repeating the RESTORE
<a name="420"></a>         *   command itself, the command just before RESTORE from the
<a name="421"></a>         *   current session, or the last command before SAVE from the
<a name="422"></a>         *   restored game.
<a name="423"></a>         */
<a name="424"></a>        if (succ)
<a name="425"></a>            AgainAction.clearForAgain();
<a name="426"></a>
<a name="427"></a>        /* return the success/failure indication */
<a name="428"></a>        return succ;
<a name="429"></a>    }
<a name="430"></a>
<a name="431"></a>    /*
<a name="432"></a>     *   Restore a game on startup.  This can be called from mainRestore()
<a name="433"></a>     *   to restore a saved game directly as part of loading the game.
<a name="434"></a>     *   (Most interpreters provide a way of starting the interpreter
<a name="435"></a>     *   directly with a saved game to be restored, skipping the
<a name="436"></a>     *   intermediate step of running the game and using a RESTORE
<a name="437"></a>     *   command.)
<a name="438"></a>     *
<a name="439"></a>     *   Returns true on success, nil on failure.  On failure, the caller
<a name="440"></a>     *   should simply exit the program.  On success, the caller should
<a name="441"></a>     *   start the game running, usually using runGame(), after showing any
<a name="442"></a>     *   desired introductory messages.
<a name="443"></a>     */
<a name="444"></a>    startupRestore(fname)
<a name="445"></a>    {
<a name="446"></a>        /*
<a name="447"></a>         *   try restoring the game, using code 1 to indicate that this is
<a name="448"></a>         *   a direct startup restore
<a name="449"></a>         */
<a name="450"></a>        if (performRestore(fname, 1))
<a name="451"></a>        {
<a name="452"></a>            /* success - tell the caller to proceed with the restored game */
<a name="453"></a>            return true;
<a name="454"></a>        }
<a name="455"></a>        else
<a name="456"></a>        {
<a name="457"></a>            /*
<a name="458"></a>             *   Failure.  We've described the problem, so ask the user
<a name="459"></a>             *   what they want to do about it.
<a name="460"></a>             */
<a name="461"></a>            try
<a name="462"></a>            {
<a name="463"></a>                /* show options and read the response */
<a name="464"></a>                failedRestoreOptions();
<a name="465"></a>
<a name="466"></a>                /* if we get here, proceed with the game */
<a name="467"></a>                return true;
<a name="468"></a>            }
<a name="469"></a>            catch (QuittingException qe)
<a name="470"></a>            {
<a name="471"></a>                /* quitting - tell the caller to terminate */
<a name="472"></a>                return nil;
<a name="473"></a>            }
<a name="474"></a>        }
<a name="475"></a>    }
<a name="476"></a>
<a name="477"></a>
<a name="478"></a>    /*
<a name="479"></a>     *   Restore a file.  'code' is the restoreCode value for the
<a name="480"></a>     *   PostRestoreObject notifications.  Returns true on success, nil on
<a name="481"></a>     *   failure.
<a name="482"></a>     */
<a name="483"></a>    performRestore(fname, code)
<a name="484"></a>    {
<a name="485"></a>        try
<a name="486"></a>        {
<a name="487"></a>            /* restore the file */
<a name="488"></a>            restoreGame(fname);
<a name="489"></a>        }
<a name="490"></a>        catch (StorageServerError sse)
<a name="491"></a>        {
<a name="492"></a>            /* failed due to a storage server error - explain the problem */
<a name="493"></a>            gLibMessages.restoreFailedOnServer(sse);
<a name="494"></a>
<a name="495"></a>            /* indicate failure */
<a name="496"></a>            return nil;
<a name="497"></a>        }
<a name="498"></a>        catch (RuntimeError err)
<a name="499"></a>        {
<a name="500"></a>            /* failed - check the error to see what went wrong */
<a name="501"></a>            switch(err.errno_)
<a name="502"></a>            {
<a name="503"></a>            case 1201:
<a name="504"></a>                /* not a saved state file */
<a name="505"></a>                gLibMessages.restoreInvalidFile();
<a name="506"></a>                break;
<a name="507"></a>
<a name="508"></a>            case 1202:
<a name="509"></a>                /* saved by different game or different version */
<a name="510"></a>                gLibMessages.restoreInvalidMatch();
<a name="511"></a>                break;
<a name="512"></a>
<a name="513"></a>            case 1207:
<a name="514"></a>                /* corrupted saved state file */
<a name="515"></a>                gLibMessages.restoreCorruptedFile();
<a name="516"></a>                break;
<a name="517"></a>
<a name="518"></a>            default:
<a name="519"></a>                /* some other failure */
<a name="520"></a>                gLibMessages.restoreFailed(err);
<a name="521"></a>                break;
<a name="522"></a>            }
<a name="523"></a>
<a name="524"></a>            /* indicate failure */
<a name="525"></a>            return nil;
<a name="526"></a>        }
<a name="527"></a>
<a name="528"></a>        /* note that we've successfully restored the game */
<a name="529"></a>        gLibMessages.restoreOkay();
<a name="530"></a>
<a name="531"></a>        /* set the appropriate restore-action code */
<a name="532"></a>        PostRestoreObject.restoreCode = code;
<a name="533"></a>
<a name="534"></a>        /* notify all PostRestoreObject instances */
<a name="535"></a>        PostRestoreObject.classExec();
<a name="536"></a>
<a name="537"></a>        /*
<a name="538"></a>         *   look around, to refresh the player's memory of the state the
<a name="539"></a>         *   game was in when saved
<a name="540"></a>         */
<a name="541"></a>        "\b";
<a name="542"></a>        libGlobal.playerChar.lookAround(true);
<a name="543"></a>
<a name="544"></a>        /* indicate success */
<a name="545"></a>        return true;
<a name="546"></a>    }
<a name="547"></a>
<a name="548"></a>    /*
<a name="549"></a>     *   There's no point in including this in undo.  If the command
<a name="550"></a>     *   succeeds, it's not undoable itself, and there won't be any undo
<a name="551"></a>     *   information in the newly restored state.  If the command fails, it
<a name="552"></a>     *   won't make any changes to the game state, so there won't be
<a name="553"></a>     *   anything to undo.
<a name="554"></a>     */
<a name="555"></a>    includeInUndo = nil
<a name="556"></a>;
<a name="557"></a>
<a name="558"></a>/*
<a name="559"></a> *   Subclass of Restore action that takes a literal string as part of the
<a name="560"></a> *   command.  The filename must be a literal enclosed in quotes, and the
<a name="561"></a> *   string (with the quotes) must be stored in our fname_ property by
<a name="562"></a> *   assignment of a quotedStringPhrase production in the grammar rule.
<a name="563"></a> */
<a name="564"></a>DefineAction(RestoreString, RestoreAction)
<a name="565"></a>    execSystemAction()
<a name="566"></a>    {
<a name="567"></a>        /*
<a name="568"></a>         *   Perform the restore, using the filename given in our fname_
<a name="569"></a>         *   parameter, trimmed of quotes.  Use code 2, the same as any
<a name="570"></a>         *   other explicit RESTORE command.
<a name="571"></a>         */
<a name="572"></a>        performRestore(fname_.getStringText(), 2);
<a name="573"></a>
<a name="574"></a>        /* abandon any additional commands on the same command line */
<a name="575"></a>        throw new TerminateCommandException();
<a name="576"></a>    }
<a name="577"></a>;
<a name="578"></a>
<a name="579"></a>/* ------------------------------------------------------------------------ */
<a name="580"></a>/*
<a name="581"></a> *   Restart the game from the beginning.
<a name="582"></a> */
<a name="583"></a>DefineSystemAction(Restart)
<a name="584"></a>    execSystemAction()
<a name="585"></a>    {
<a name="586"></a>        /* confirm that they really want to restart */
<a name="587"></a>        gLibMessages.confirmRestart();
<a name="588"></a>        if (yesOrNo())
<a name="589"></a>        {
<a name="590"></a>            /*
<a name="591"></a>             *   The confirmation input will have put us into
<a name="592"></a>             *   start-of-command mode for sequencing purposes; force the
<a name="593"></a>             *   sequencer back to mid-command mode, so we can show
<a name="594"></a>             *   inter-command separation before the restart.
<a name="595"></a>             */
<a name="596"></a>
<a name="597"></a>            /* restart the game */
<a name="598"></a>            doRestartGame();
<a name="599"></a>        }
<a name="600"></a>        else
<a name="601"></a>        {
<a name="602"></a>            /* confirm that we're not really restarting */
<a name="603"></a>            gLibMessages.notRestarting();
<a name="604"></a>        }
<a name="605"></a>    }
<a name="606"></a>
<a name="607"></a>    /* carry out the restart action */
<a name="608"></a>    doRestartGame()
<a name="609"></a>    {
<a name="610"></a>        /*
<a name="611"></a>         *   Show a command separator, to provide separation from any
<a name="612"></a>         *   introductory text that we'll show on restarting.  Note that
<a name="613"></a>         *   we probably just asked for confirmation, which means that the
<a name="614"></a>         *   command sequencer will be in start-of-command mode; force it
<a name="615"></a>         *   back to mid-command mode so we show inter-command separation.
<a name="616"></a>         */
<a name="617"></a>        commandSequencer.setCommandMode();
<a name="618"></a>        "&lt;.commandsep&gt;";
<a name="619"></a>
<a name="620"></a>        /* before restarting, notify anyone interested of our intentions */
<a name="621"></a>        PreRestartObject.classExec();
<a name="622"></a>
<a name="623"></a>        /*
<a name="624"></a>         *   Throw a 'restart' signal; the main entrypoint loop will catch
<a name="625"></a>         *   this and actually perform the restart.
<a name="626"></a>         *
<a name="627"></a>         *   Note that we *could* do the VM reset (via restartGame()) here,
<a name="628"></a>         *   but there's an advantage to doing it in the main loop: we
<a name="629"></a>         *   won't be in the stack context of whatever command we're
<a name="630"></a>         *   performing.  If we did the restart here, it's possible that
<a name="631"></a>         *   some useless objects would survive the VM reset just because
<a name="632"></a>         *   they're referenced from within a caller's stack frame.  Those
<a name="633"></a>         *   objects would immediately go out of scope when we get back to
<a name="634"></a>         *   the main loop, but they might survive long enough to create
<a name="635"></a>         *   apparent inconsistencies.  In particular, if we did a
<a name="636"></a>         *   firstObj/nextObj loop, we could discover those objects and
<a name="637"></a>         *   re-establish more lasting references to them, which we
<a name="638"></a>         *   certainly don't want to do.  By deferring the VM reset until
<a name="639"></a>         *   we get back to the main loop, we'll ensure that objects won't
<a name="640"></a>         *   survive the reset just because they're on the stack
<a name="641"></a>         *   momentarily here.
<a name="642"></a>         */
<a name="643"></a>        throw new RestartSignal();
<a name="644"></a>    }
<a name="645"></a>
<a name="646"></a>    /* there's no point in including this in undo */
<a name="647"></a>    includeInUndo = nil
<a name="648"></a>;
<a name="649"></a>
<a name="650"></a>/* ------------------------------------------------------------------------ */
<a name="651"></a>/*
<a name="652"></a> *   Undo one turn.
<a name="653"></a> */
<a name="654"></a>DefineSystemAction(Undo)
<a name="655"></a>    /*
<a name="656"></a>     *   "Undo" is so special that we must override the entire action
<a name="657"></a>     *   processing sequence.  We do this because undoing will restore the
<a name="658"></a>     *   game state as of the previous savepoint, which would leave all
<a name="659"></a>     *   sorts of things unsynchronized in the normal action sequence.  To
<a name="660"></a>     *   avoid problems, we simply leave out any other action processing
<a name="661"></a>     *   and perform the 'undo' directly.
<a name="662"></a>     */
<a name="663"></a>    doAction(issuingActor, targetActor, targetActorPhrase,
<a name="664"></a>             countsAsIssuerTurn)
<a name="665"></a>    {
<a name="666"></a>        /*
<a name="667"></a>         *   the player obviously knows about UNDO, so there's no need for
<a name="668"></a>         *   a tip about it
<a name="669"></a>         */
<a name="670"></a>        undoTip.makeShown();
<a name="671"></a>
<a name="672"></a>        /*
<a name="673"></a>         *   don't allow this unless the player character is performing
<a name="674"></a>         *   the command directly
<a name="675"></a>         */
<a name="676"></a>        if (!targetActor.isPlayerChar)
<a name="677"></a>        {
<a name="678"></a>            /*
<a name="679"></a>             *   tell them this command cannot be directed to another
<a name="680"></a>             *   actor, and give up
<a name="681"></a>             */
<a name="682"></a>            gLibMessages.systemActionToNPC();
<a name="683"></a>            return;
<a name="684"></a>        }
<a name="685"></a>
<a name="686"></a>        /* perform the undo */
<a name="687"></a>        performUndo(true);
<a name="688"></a>    }
<a name="689"></a>
<a name="690"></a>    /*
<a name="691"></a>     *   Perform undo.  Returns true if we were successful, nil if not.
<a name="692"></a>     *
<a name="693"></a>     *   'asCommand' indicates whether or not the undo is being performed
<a name="694"></a>     *   as an explicit command: if so, we'll save the UNDO command for use
<a name="695"></a>     *   in AGAIN.
<a name="696"></a>     */
<a name="697"></a>    performUndo(asCommand)
<a name="698"></a>    {
<a name="699"></a>        /* try undoing to the previous savepoint */
<a name="700"></a>        if (undo())
<a name="701"></a>        {
<a name="702"></a>            local oldActor;
<a name="703"></a>            local oldIssuer;
<a name="704"></a>            local oldAction;
<a name="705"></a>
<a name="706"></a>            /* notify all PostUndoObject instances */
<a name="707"></a>            PostUndoObject.classExec();
<a name="708"></a>
<a name="709"></a>            /* set up the globals for the command */
<a name="710"></a>            oldActor = gActor;
<a name="711"></a>            oldIssuer = gIssuingActor;
<a name="712"></a>            oldAction = gAction;
<a name="713"></a>
<a name="714"></a>            /* set the new globals */
<a name="715"></a>            gActor = gPlayerChar;
<a name="716"></a>            gIssuingActor = gPlayerChar;
<a name="717"></a>            gAction = self;
<a name="718"></a>
<a name="719"></a>            /* make sure we reset globals on the way out */
<a name="720"></a>            try
<a name="721"></a>            {
<a name="722"></a>                /* success - mention what we did */
<a name="723"></a>                gLibMessages.undoOkay(libGlobal.lastActorForUndo,
<a name="724"></a>                                      libGlobal.lastCommandForUndo);
<a name="725"></a>
<a name="726"></a>                /* look around, to refresh the player's memory */
<a name="727"></a>                libGlobal.playerChar.lookAround(true);
<a name="728"></a>            }
<a name="729"></a>            finally
<a name="730"></a>            {
<a name="731"></a>                /* restore the parser globals to how we found them */
<a name="732"></a>                gActor = oldActor;
<a name="733"></a>                gIssuingActor = oldIssuer;
<a name="734"></a>                gAction = oldAction;
<a name="735"></a>            }
<a name="736"></a>
<a name="737"></a>            /*
<a name="738"></a>             *   if this was an explicit 'undo' command, save the command
<a name="739"></a>             *   to allow repeating it with 'again'
<a name="740"></a>             */
<a name="741"></a>            if (asCommand)
<a name="742"></a>                AgainAction.saveForAgain(gPlayerChar, gPlayerChar, nil, self);
<a name="743"></a>
<a name="744"></a>            /* indicate success */
<a name="745"></a>            return true;
<a name="746"></a>        }
<a name="747"></a>        else
<a name="748"></a>        {
<a name="749"></a>            /* no more undo information available */
<a name="750"></a>            gLibMessages.undoFailed();
<a name="751"></a>
<a name="752"></a>            /* indicate failure */
<a name="753"></a>            return nil;
<a name="754"></a>        }
<a name="755"></a>    }
<a name="756"></a>
<a name="757"></a>    /*
<a name="758"></a>     *   "undo" is not undoable - if we undo again after an undo, we undo
<a name="759"></a>     *   the next most recent command
<a name="760"></a>     */
<a name="761"></a>    includeInUndo = nil
<a name="762"></a>;
<a name="763"></a>
<a name="764"></a>/* ------------------------------------------------------------------------ */
<a name="765"></a>/*
<a name="766"></a> *   Save the defaults
<a name="767"></a> */
<a name="768"></a>DefineSystemAction(SaveDefaults)
<a name="769"></a>    execSystemAction()
<a name="770"></a>    {
<a name="771"></a>        /* tell SettingsItem to save all settings */
<a name="772"></a>        settingsUI.saveSettingsMsg();
<a name="773"></a>    }
<a name="774"></a>
<a name="775"></a>    /* there's no point in including this in undo */
<a name="776"></a>    includeInUndo = nil
<a name="777"></a>;
<a name="778"></a>
<a name="779"></a>/*
<a name="780"></a> *   Restore defaults
<a name="781"></a> */
<a name="782"></a>DefineSystemAction(RestoreDefaults)
<a name="783"></a>    execSystemAction()
<a name="784"></a>    {
<a name="785"></a>        /*
<a name="786"></a>         *   Tell SettingsItem to restore all settings.  This is an
<a name="787"></a>         *   explicit request, so we want SettingsItem to describe what
<a name="788"></a>         *   happened.
<a name="789"></a>         */
<a name="790"></a>        settingsUI.restoreSettingsMsg();
<a name="791"></a>    }
<a name="792"></a>
<a name="793"></a>    /* there's no point in including this in undo */
<a name="794"></a>    includeInUndo = nil
<a name="795"></a>;
<a name="796"></a>
<a name="797"></a>
<a name="798"></a>/* ------------------------------------------------------------------------ */
<a name="799"></a>/*
<a name="800"></a> *   Quit the game.
<a name="801"></a> */
<a name="802"></a>DefineSystemAction(Quit)
<a name="803"></a>    execSystemAction()
<a name="804"></a>    {
<a name="805"></a>        /* confirm that they really want to quit */
<a name="806"></a>        gLibMessages.confirmQuit();
<a name="807"></a>        if (yesOrNo())
<a name="808"></a>        {
<a name="809"></a>            /* carry out the termination */
<a name="810"></a>            terminateGame();
<a name="811"></a>        }
<a name="812"></a>        else
<a name="813"></a>        {
<a name="814"></a>            /* show the confirmation that we're not quitting */
<a name="815"></a>            gLibMessages.notTerminating();
<a name="816"></a>        }
<a name="817"></a>    }
<a name="818"></a>
<a name="819"></a>    /*
<a name="820"></a>     *   Carry out game termination.  This can be called when we wish to
<a name="821"></a>     *   end the game without asking for any additional player
<a name="822"></a>     *   confirmation.
<a name="823"></a>     */
<a name="824"></a>    terminateGame()
<a name="825"></a>    {
<a name="826"></a>        /* acknowledge that we're quitting */
<a name="827"></a>        gLibMessages.okayQuitting();
<a name="828"></a>
<a name="829"></a>        /* throw a 'quitting' signal to end the game */
<a name="830"></a>        throw new QuittingException;
<a name="831"></a>    }
<a name="832"></a>
<a name="833"></a>    /* there's no point in including this in undo */
<a name="834"></a>    includeInUndo = nil
<a name="835"></a>;
<a name="836"></a>
<a name="837"></a>/*
<a name="838"></a> *   Pause the game.  This stops the real-time clock until the user
<a name="839"></a> *   presses a key.  Games that don't use the real-time clock will have no
<a name="840"></a> *   use for this.
<a name="841"></a> */
<a name="842"></a>DefineSystemAction(Pause)
<a name="843"></a>    execSystemAction()
<a name="844"></a>    {
<a name="845"></a>        local elapsed;
<a name="846"></a>
<a name="847"></a>        /*
<a name="848"></a>         *   remember the current elapsed game real time - when we are
<a name="849"></a>         *   released from the pause, we'll restore this time
<a name="850"></a>         */
<a name="851"></a>        elapsed = realTimeManager.getElapsedTime();
<a name="852"></a>
<a name="853"></a>        /* show our prompt */
<a name="854"></a>        gLibMessages.pausePrompt();
<a name="855"></a>
<a name="856"></a>        /* keep going until we're released */
<a name="857"></a>    waitLoop:
<a name="858"></a>        for (;;)
<a name="859"></a>        {
<a name="860"></a>            /*
<a name="861"></a>             *   Wait for a key, and see what we have.  Note that we
<a name="862"></a>             *   explicitly do not want to allow any real-time events to
<a name="863"></a>             *   occur, so we simply wait forever without timeout.
<a name="864"></a>             */
<a name="865"></a>            switch(inputKey())
<a name="866"></a>            {
<a name="867"></a>            case ' ':
<a name="868"></a>                /* space key - end the wait */
<a name="869"></a>                break waitLoop;
<a name="870"></a>
<a name="871"></a>            case 's':
<a name="872"></a>            case 'S':
<a name="873"></a>                /* mention that we're saving */
<a name="874"></a>                gLibMessages.pauseSaving();
<a name="875"></a>
<a name="876"></a>                /*
<a name="877"></a>                 *   set the elapsed time to the time when we started, so
<a name="878"></a>                 *   that the saved position reflects the time at the
<a name="879"></a>                 *   start of the pause
<a name="880"></a>                 */
<a name="881"></a>                realTimeManager.setElapsedTime(elapsed);
<a name="882"></a>
<a name="883"></a>                /* save the game - go run the normal SAVE command */
<a name="884"></a>                SaveAction.execSystemAction();
<a name="885"></a>
<a name="886"></a>                /* show our prompt again */
<a name="887"></a>                "&lt;.p&gt;";
<a name="888"></a>                gLibMessages.pausePrompt();
<a name="889"></a>
<a name="890"></a>                /* go back to wait for another key */
<a name="891"></a>                break;
<a name="892"></a>
<a name="893"></a>            case '[eof]':
<a name="894"></a>                /* end-of-file on keyboard input - throw an error */
<a name="895"></a>                "\b";
<a name="896"></a>                throw new EndOfFileException();
<a name="897"></a>
<a name="898"></a>            default:
<a name="899"></a>                /* ignore other keys; just go back to wait again */
<a name="900"></a>                break;
<a name="901"></a>            }
<a name="902"></a>        }
<a name="903"></a>
<a name="904"></a>        /* show the released-from-pause message */
<a name="905"></a>        gLibMessages.pauseEnded();
<a name="906"></a>
<a name="907"></a>        /*
<a name="908"></a>         *   set the real-time clock to the same elapsed game time
<a name="909"></a>         *   that we had when we started the pause, so that the
<a name="910"></a>         *   elapsed real time of the pause itself doesn't count
<a name="911"></a>         *   against the game elapsed time
<a name="912"></a>         */
<a name="913"></a>        realTimeManager.setElapsedTime(elapsed);
<a name="914"></a>    }
<a name="915"></a>;
<a name="916"></a>
<a name="917"></a>/*
<a name="918"></a> *   Change to VERBOSE mode.
<a name="919"></a> */
<a name="920"></a>DefineSystemAction(Verbose)
<a name="921"></a>    execSystemAction()
<a name="922"></a>    {
<a name="923"></a>        /* set the global 'verbose' mode */
<a name="924"></a>        gameMain.verboseMode.isOn = true;
<a name="925"></a>
<a name="926"></a>        /* acknowledge it */
<a name="927"></a>        gLibMessages.acknowledgeVerboseMode(true);
<a name="928"></a>    }
<a name="929"></a>;
<a name="930"></a>
<a name="931"></a>/*
<a name="932"></a> *   Change to TERSE mode.
<a name="933"></a> */
<a name="934"></a>DefineSystemAction(Terse)
<a name="935"></a>    execSystemAction()
<a name="936"></a>    {
<a name="937"></a>        /* set the global 'verbose' mode */
<a name="938"></a>        gameMain.verboseMode.isOn = nil;
<a name="939"></a>
<a name="940"></a>        /* acknowledge it */
<a name="941"></a>        gLibMessages.acknowledgeVerboseMode(nil);
<a name="942"></a>    }
<a name="943"></a>;
<a name="944"></a>
<a name="945"></a>/* in case the score module isn't present */
<a name="946"></a>property showScore;
<a name="947"></a>property showFullScore;
<a name="948"></a>property scoreNotify;
<a name="949"></a>
<a name="950"></a>/*
<a name="951"></a> *   Show the current score.
<a name="952"></a> */
<a name="953"></a>DefineSystemAction(Score)
<a name="954"></a>    execSystemAction()
<a name="955"></a>    {
<a name="956"></a>        /* show the simple score */
<a name="957"></a>        if (libGlobal.scoreObj != nil)
<a name="958"></a>        {
<a name="959"></a>            /* show the score */
<a name="960"></a>            libGlobal.scoreObj.showScore();
<a name="961"></a>
<a name="962"></a>            /*
<a name="963"></a>             *   Mention the FULL SCORE command to the player if we haven't
<a name="964"></a>             *   already.  Note that we only want to mention
<a name="965"></a>             */
<a name="966"></a>            if (!mentionedFullScore)
<a name="967"></a>            {
<a name="968"></a>                /* explain about it */
<a name="969"></a>                gLibMessages.mentionFullScore;
<a name="970"></a>
<a name="971"></a>                /* don't mention it again */
<a name="972"></a>                ScoreAction.mentionedFullScore = true;
<a name="973"></a>            }
<a name="974"></a>        }
<a name="975"></a>        else
<a name="976"></a>            gLibMessages.scoreNotPresent;
<a name="977"></a>    }
<a name="978"></a>
<a name="979"></a>    /* there's no point in including this in undo */
<a name="980"></a>    includeInUndo = nil
<a name="981"></a>
<a name="982"></a>    /* have we mentioned the FULL SCORE command yet? */
<a name="983"></a>    mentionedFullScore = nil
<a name="984"></a>;
<a name="985"></a>
<a name="986"></a>/*
<a name="987"></a> *   Show the full score.
<a name="988"></a> */
<a name="989"></a>DefineSystemAction(FullScore)
<a name="990"></a>    execSystemAction()
<a name="991"></a>    {
<a name="992"></a>        /* show the full score in response to an explicit player request */
<a name="993"></a>        showFullScore();
<a name="994"></a>
<a name="995"></a>        /* this counts as a mention of the FULL SCORE command */
<a name="996"></a>        ScoreAction.mentionedFullScore = true;
<a name="997"></a>    }
<a name="998"></a>
<a name="999"></a>    /* show the full score */
<a name="1000"></a>    showFullScore()
<a name="1001"></a>    {
<a name="1002"></a>        /* show the full score */
<a name="1003"></a>        if (libGlobal.scoreObj != nil)
<a name="1004"></a>            libGlobal.scoreObj.showFullScore();
<a name="1005"></a>        else
<a name="1006"></a>            gLibMessages.scoreNotPresent;
<a name="1007"></a>    }
<a name="1008"></a>
<a name="1009"></a>    /* there's no point in including this in undo */
<a name="1010"></a>    includeInUndo = nil
<a name="1011"></a>;
<a name="1012"></a>
<a name="1013"></a>/*
<a name="1014"></a> *   Show the NOTIFY status.
<a name="1015"></a> */
<a name="1016"></a>DefineSystemAction(Notify)
<a name="1017"></a>    execSystemAction()
<a name="1018"></a>    {
<a name="1019"></a>        /* show the current notification status */
<a name="1020"></a>        if (libGlobal.scoreObj != nil)
<a name="1021"></a>            gLibMessages.showNotifyStatus(
<a name="1022"></a>                libGlobal.scoreObj.scoreNotify.isOn);
<a name="1023"></a>        else
<a name="1024"></a>            gLibMessages.commandNotPresent;
<a name="1025"></a>    }
<a name="1026"></a>;
<a name="1027"></a>
<a name="1028"></a>/*
<a name="1029"></a> *   Turn score change notifications on.
<a name="1030"></a> */
<a name="1031"></a>DefineSystemAction(NotifyOn)
<a name="1032"></a>    execSystemAction()
<a name="1033"></a>    {
<a name="1034"></a>        /* turn notifications on, and acknowledge the status */
<a name="1035"></a>        if (libGlobal.scoreObj != nil)
<a name="1036"></a>        {
<a name="1037"></a>            libGlobal.scoreObj.scoreNotify.isOn = true;
<a name="1038"></a>            gLibMessages.acknowledgeNotifyStatus(true);
<a name="1039"></a>        }
<a name="1040"></a>        else
<a name="1041"></a>            gLibMessages.commandNotPresent;
<a name="1042"></a>    }
<a name="1043"></a>;
<a name="1044"></a>
<a name="1045"></a>/*
<a name="1046"></a> *   Turn score change notifications off.
<a name="1047"></a> */
<a name="1048"></a>DefineSystemAction(NotifyOff)
<a name="1049"></a>    execSystemAction()
<a name="1050"></a>    {
<a name="1051"></a>        /* turn notifications off, and acknowledge the status */
<a name="1052"></a>        if (libGlobal.scoreObj != nil)
<a name="1053"></a>        {
<a name="1054"></a>            libGlobal.scoreObj.scoreNotify.isOn = nil;
<a name="1055"></a>            gLibMessages.acknowledgeNotifyStatus(nil);
<a name="1056"></a>        }
<a name="1057"></a>        else
<a name="1058"></a>            gLibMessages.commandNotPresent;
<a name="1059"></a>    }
<a name="1060"></a>;
<a name="1061"></a>
<a name="1062"></a>/*
<a name="1063"></a> *   Show version information for the game and the library modules the
<a name="1064"></a> *   game is using.
<a name="1065"></a> */
<a name="1066"></a>DefineSystemAction(Version)
<a name="1067"></a>    execSystemAction()
<a name="1068"></a>    {
<a name="1069"></a>        /* show the version information for each library */
<a name="1070"></a>        foreach (local cur in ModuleID.getModuleList())
<a name="1071"></a>            cur.showVersion();
<a name="1072"></a>    }
<a name="1073"></a>
<a name="1074"></a>    /* there's no point in including this in undo */
<a name="1075"></a>    includeInUndo = nil
<a name="1076"></a>;
<a name="1077"></a>
<a name="1078"></a>/*
<a name="1079"></a> *   Show the credits for the game and the library modules the game
<a name="1080"></a> *   includes.
<a name="1081"></a> */
<a name="1082"></a>DefineSystemAction(Credits)
<a name="1083"></a>    execSystemAction()
<a name="1084"></a>    {
<a name="1085"></a>        /* show the credits for each library */
<a name="1086"></a>        foreach (local cur in ModuleID.getModuleList())
<a name="1087"></a>            cur.showCredit();
<a name="1088"></a>    }
<a name="1089"></a>
<a name="1090"></a>    /* there's no point in including this in undo */
<a name="1091"></a>    includeInUndo = nil
<a name="1092"></a>;
<a name="1093"></a>
<a name="1094"></a>/*
<a name="1095"></a> *   Show the "about" information for the game and library modules.
<a name="1096"></a> */
<a name="1097"></a>DefineSystemAction(About)
<a name="1098"></a>    execSystemAction()
<a name="1099"></a>    {
<a name="1100"></a>        local anyOutput;
<a name="1101"></a>
<a name="1102"></a>        /* watch for any output while showing module information */
<a name="1103"></a>        anyOutput = outputManager.curOutputStream
<a name="1104"></a>                    .watchForOutput(function()
<a name="1105"></a>        {
<a name="1106"></a>            /* show information for each module */
<a name="1107"></a>            foreach (local cur in ModuleID.getModuleList())
<a name="1108"></a>                cur.showAbout();
<a name="1109"></a>        });
<a name="1110"></a>
<a name="1111"></a>        /*
<a name="1112"></a>         *   if we didn't have any ABOUT information to show, display a
<a name="1113"></a>         *   message to this effect
<a name="1114"></a>         */
<a name="1115"></a>        if (!anyOutput)
<a name="1116"></a>            gLibMessages.noAboutInfo;
<a name="1117"></a>    }
<a name="1118"></a>
<a name="1119"></a>    /* there's no point in including this in undo */
<a name="1120"></a>    includeInUndo = nil
<a name="1121"></a>;
<a name="1122"></a>
<a name="1123"></a>/*
<a name="1124"></a> *   A state object that keeps track of our logging (scripting) status.
<a name="1125"></a> *   This is transient, because logging is controlled through the output
<a name="1126"></a> *   layer in the interpreter, which does not participate in any of the
<a name="1127"></a> *   persistence mechanisms.
<a name="1128"></a> */
<a name="1129"></a>transient scriptStatus: object
<a name="1130"></a>    /*
<a name="1131"></a>     *   Script file name.  This is nil when logging is not in effect, and
<a name="1132"></a>     *   is set to the name of the scripting file when a log file is
<a name="1133"></a>     *   active.
<a name="1134"></a>     */
<a name="1135"></a>    scriptFile = nil
<a name="1136"></a>
<a name="1137"></a>    /* RECORD file name */
<a name="1138"></a>    recordFile = nil
<a name="1139"></a>
<a name="1140"></a>    /* have we warned about using NOTE without logging in effect? */
<a name="1141"></a>    noteWithoutScriptWarning = nil
<a name="1142"></a>;
<a name="1143"></a>
<a name="1144"></a>/*
<a name="1145"></a> *   Property: object is a web temp file.  The Web UI uses this to flag
<a name="1146"></a> *   that a file we're saving to is actually a temp file that will be
<a name="1147"></a> *   offered as a downloadable file to the client after the file is written
<a name="1148"></a> *   and closed.
<a name="1149"></a> */
<a name="1150"></a>property isWebTempFile;
<a name="1151"></a>
<a name="1152"></a>/*
<a name="1153"></a> *   A base class for file-oriented actions, such as SCRIPT, RECORD, and
<a name="1154"></a> *   REPLAY.  We provide common handling that prompts interactively for a
<a name="1155"></a> *   filename; subclasses must override a few methods and properties to
<a name="1156"></a> *   carry out the specific subclassed operation on the file.
<a name="1157"></a> */
<a name="1158"></a>DefineSystemAction(FileOp)
<a name="1159"></a>    /* our file dialog prompt message */
<a name="1160"></a>    filePromptMsg = ''
<a name="1161"></a>
<a name="1162"></a>    /* the file dialog open/save type */
<a name="1163"></a>    fileDisposition = InFileSave
<a name="1164"></a>
<a name="1165"></a>    /* the file dialog type ID */
<a name="1166"></a>    fileTypeID = FileTypeLog
<a name="1167"></a>
<a name="1168"></a>    /* show our cancellation mesage */
<a name="1169"></a>    showCancelMsg = ""
<a name="1170"></a>
<a name="1171"></a>    /*
<a name="1172"></a>     *   Carry out our file operation.
<a name="1173"></a>     *
<a name="1174"></a>     *   'desc' is an optional named argument giving a description string
<a name="1175"></a>     *   entered by the user via the Save Game dialog.  Some versions of
<a name="1176"></a>     *   the Save Game dialog let the user enter this additional
<a name="1177"></a>     *   information, which can be stored as part of the saved game
<a name="1178"></a>     *   metadata.
<a name="1179"></a>     */
<a name="1180"></a>    performFileOp(fname, ack, desc:?)
<a name="1181"></a>    {
<a name="1182"></a>        /*
<a name="1183"></a>         *   Each concrete action subclass must override this to carry out
<a name="1184"></a>         *   our operation.  This is called when the user has successfully
<a name="1185"></a>         *   selected a filename for the operation.
<a name="1186"></a>         */
<a name="1187"></a>    }
<a name="1188"></a>
<a name="1189"></a>    execSystemAction()
<a name="1190"></a>    {
<a name="1191"></a>        /*
<a name="1192"></a>         *   ask for a file and carry out our action; since the command is
<a name="1193"></a>         *   being performed directly from the command line, we want an
<a name="1194"></a>         *   acknowledgment message on success
<a name="1195"></a>         */
<a name="1196"></a>        setUpFileOp(true);
<a name="1197"></a>    }
<a name="1198"></a>
<a name="1199"></a>    /* ask for a file, and carry out our operation is we get one */
<a name="1200"></a>    setUpFileOp(ack)
<a name="1201"></a>    {
<a name="1202"></a>        local result;
<a name="1203"></a>        local origElapsedTime;
<a name="1204"></a>
<a name="1205"></a>        /* note the current game time */
<a name="1206"></a>        origElapsedTime = realTimeManager.getElapsedTime();
<a name="1207"></a>
<a name="1208"></a>        /* ask for a file */
<a name="1209"></a>        result = getInputFile(filePromptMsg, fileDisposition, fileTypeID, 0);
<a name="1210"></a>
<a name="1211"></a>        /* check the inputFile result */
<a name="1212"></a>        switch(result[1])
<a name="1213"></a>        {
<a name="1214"></a>        case InFileSuccess:
<a name="1215"></a>            /* carry out our file operation */
<a name="1216"></a>            if (result.length &gt;= 3)
<a name="1217"></a>                performFileOp(result[2], ack, desc:result[3]);
<a name="1218"></a>            else
<a name="1219"></a>                performFileOp(result[2], ack);
<a name="1220"></a>            break;
<a name="1221"></a>
<a name="1222"></a>        case InFileFailure:
<a name="1223"></a>            /* advise of the failure of the prompt */
<a name="1224"></a>            if (result.length() &gt; 1)
<a name="1225"></a>                gLibMessages.filePromptFailedMsg(result[2]);
<a name="1226"></a>            else
<a name="1227"></a>                gLibMessages.filePromptFailed();
<a name="1228"></a>            break;
<a name="1229"></a>
<a name="1230"></a>        case InFileCancel:
<a name="1231"></a>            /* acknowledge the cancellation */
<a name="1232"></a>            showCancelMsg();
<a name="1233"></a>            break;
<a name="1234"></a>        }
<a name="1235"></a>
<a name="1236"></a>        /*
<a name="1237"></a>         *   restore the original elapsed game time, so that the time spent
<a name="1238"></a>         *   in the file selector dialog doesn't count against the game
<a name="1239"></a>         *   time
<a name="1240"></a>         */
<a name="1241"></a>        realTimeManager.setElapsedTime(origElapsedTime);
<a name="1242"></a>    }
<a name="1243"></a>
<a name="1244"></a>    /* we can't include this in undo, as it affects external files */
<a name="1245"></a>    includeInUndo = nil
<a name="1246"></a>
<a name="1247"></a>    /* don't allow repeating with AGAIN */
<a name="1248"></a>    isRepeatable = nil
<a name="1249"></a>;
<a name="1250"></a>
<a name="1251"></a>/*
<a name="1252"></a> *   Turn scripting on.  This creates a text file that contains a
<a name="1253"></a> *   transcript of all commands and responses from this point forward.
<a name="1254"></a> */
<a name="1255"></a>DefineAction(Script, FileOpAction)
<a name="1256"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="1257"></a>    filePromptMsg = (gLibMessages.getScriptingPrompt())
<a name="1258"></a>    fileTypeID = FileTypeLog
<a name="1259"></a>    fileDisposition = InFileSave
<a name="1260"></a>
<a name="1261"></a>    /* show our cancellation mesasge */
<a name="1262"></a>    showCancelMsg() { gLibMessages.scriptingCanceled(); }
<a name="1263"></a>
<a name="1264"></a>    /*
<a name="1265"></a>     *   set up scripting - this can be used to set up scripting
<a name="1266"></a>     *   programmatically, in the course of carrying out another action
<a name="1267"></a>     */
<a name="1268"></a>    setUpScripting(ack) { setUpFileOp(ack); }
<a name="1269"></a>
<a name="1270"></a>    /* turn on scripting to the given file */
<a name="1271"></a>    performFileOp(fname, ack)
<a name="1272"></a>    {
<a name="1273"></a>        /* turn on logging */
<a name="1274"></a>        local ok = nil, exc = nil;
<a name="1275"></a>        try
<a name="1276"></a>        {
<a name="1277"></a>            ok = aioSetLogFile(fname, LogTypeTranscript);
<a name="1278"></a>        }
<a name="1279"></a>        catch (Exception e)
<a name="1280"></a>        {
<a name="1281"></a>            exc = e;
<a name="1282"></a>        }
<a name="1283"></a>        if (ok)
<a name="1284"></a>        {
<a name="1285"></a>            /* remember that scripting is in effect */
<a name="1286"></a>            scriptStatus.scriptFile = fname;
<a name="1287"></a>
<a name="1288"></a>            /*
<a name="1289"></a>             *   forget any past warning that we've issued about NOTE
<a name="1290"></a>             *   without a script in effect; the next time scripting isn't
<a name="1291"></a>             *   active, we'll want to issue a new warning, since they
<a name="1292"></a>             *   might not be aware at that point that the scripting we're
<a name="1293"></a>             *   starting now has ended
<a name="1294"></a>             */
<a name="1295"></a>            scriptStatus.noteWithoutScriptWarning = nil;
<a name="1296"></a>
<a name="1297"></a>            /* note that logging is active, if acknowledgment is desired */
<a name="1298"></a>            if (ack)
<a name="1299"></a>            {
<a name="1300"></a>                if (fname.isWebTempFile)
<a name="1301"></a>                    gLibMessages.scriptingOkayWebTemp();
<a name="1302"></a>                else
<a name="1303"></a>                    gLibMessages.scriptingOkay();
<a name="1304"></a>            }
<a name="1305"></a>        }
<a name="1306"></a>        else
<a name="1307"></a>        {
<a name="1308"></a>            /* scripting is no longer in effect */
<a name="1309"></a>            scriptStatus.scriptFile = nil;
<a name="1310"></a>
<a name="1311"></a>            /* show an error, if acknowledgment is desired */
<a name="1312"></a>            if (ack)
<a name="1313"></a>            {
<a name="1314"></a>                if (exc != nil)
<a name="1315"></a>                    gLibMessages.scriptingFailedException(exc);
<a name="1316"></a>                else
<a name="1317"></a>                    gLibMessages.scriptingFailed;
<a name="1318"></a>            }
<a name="1319"></a>        }
<a name="1320"></a>    }
<a name="1321"></a>;
<a name="1322"></a>
<a name="1323"></a>/*
<a name="1324"></a> *   Subclass of Script action taking a quoted string as part of the
<a name="1325"></a> *   command syntax.  The grammar rule must set our fname_ property to a
<a name="1326"></a> *   quotedStringPhrase subproduction.
<a name="1327"></a> */
<a name="1328"></a>DefineAction(ScriptString, ScriptAction)
<a name="1329"></a>    execSystemAction()
<a name="1330"></a>    {
<a name="1331"></a>        /* if there's a filename, we don't need to prompt */
<a name="1332"></a>        if (fname_ != nil)
<a name="1333"></a>        {
<a name="1334"></a>            /* set up scripting to the filename specified in the command */
<a name="1335"></a>            performFileOp(fname_.getStringText(), true);
<a name="1336"></a>        }
<a name="1337"></a>        else
<a name="1338"></a>        {
<a name="1339"></a>            /* there's no filename, so prompt as usual */
<a name="1340"></a>            inherited();
<a name="1341"></a>        }
<a name="1342"></a>    }
<a name="1343"></a>;
<a name="1344"></a>
<a name="1345"></a>/*
<a name="1346"></a> *   Turn scripting off.  This stops recording the game transcript started
<a name="1347"></a> *   with the most recent SCRIPT command.
<a name="1348"></a> */
<a name="1349"></a>DefineSystemAction(ScriptOff)
<a name="1350"></a>    execSystemAction()
<a name="1351"></a>    {
<a name="1352"></a>        /* turn off scripting */
<a name="1353"></a>        turnOffScripting(true);
<a name="1354"></a>    }
<a name="1355"></a>
<a name="1356"></a>    /* turn off scripting */
<a name="1357"></a>    turnOffScripting(ack)
<a name="1358"></a>    {
<a name="1359"></a>        /* if we're not in a script file, ignore it */
<a name="1360"></a>        if (scriptStatus.scriptFile == nil)
<a name="1361"></a>        {
<a name="1362"></a>            gLibMessages.scriptOffIgnored();
<a name="1363"></a>            return;
<a name="1364"></a>        }
<a name="1365"></a>
<a name="1366"></a>        /* cancel scripting in the interpreter's output layer */
<a name="1367"></a>        aioSetLogFile(nil, LogTypeTranscript);
<a name="1368"></a>
<a name="1369"></a>        /* remember that scripting is no longer in effect */
<a name="1370"></a>        scriptStatus.scriptFile = nil;
<a name="1371"></a>
<a name="1372"></a>        /* acknowledge the change, if desired */
<a name="1373"></a>        if (ack)
<a name="1374"></a>            gLibMessages.scriptOffOkay();
<a name="1375"></a>    }
<a name="1376"></a>
<a name="1377"></a>    /* we can't include this in undo, as it affects external files */
<a name="1378"></a>    includeInUndo = nil
<a name="1379"></a>;
<a name="1380"></a>
<a name="1381"></a>/*
<a name="1382"></a> *   RECORD - this is similar to SCRIPT, but stores a file containing only
<a name="1383"></a> *   the command input, not the output.
<a name="1384"></a> */
<a name="1385"></a>DefineAction(Record, FileOpAction)
<a name="1386"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="1387"></a>    filePromptMsg = (gLibMessages.getRecordingPrompt())
<a name="1388"></a>    fileTypeID = FileTypeCmd
<a name="1389"></a>    fileDisposition = InFileSave
<a name="1390"></a>
<a name="1391"></a>    /* show our cancellation mesasge */
<a name="1392"></a>    showCancelMsg() { gLibMessages.recordingCanceled(); }
<a name="1393"></a>
<a name="1394"></a>    /*
<a name="1395"></a>     *   set up recording - this can be used to set up scripting
<a name="1396"></a>     *   programmatically, in the course of carrying out another action
<a name="1397"></a>     */
<a name="1398"></a>    setUpRecording(ack) { setUpFileOp(ack); }
<a name="1399"></a>
<a name="1400"></a>    /* turn on recording to the given file */
<a name="1401"></a>    performFileOp(fname, ack)
<a name="1402"></a>    {
<a name="1403"></a>        /* turn on command logging */
<a name="1404"></a>        local ok = nil, exc = nil;
<a name="1405"></a>        try
<a name="1406"></a>        {
<a name="1407"></a>            ok = aioSetLogFile(fname, logFileType);
<a name="1408"></a>        }
<a name="1409"></a>        catch (Exception e)
<a name="1410"></a>        {
<a name="1411"></a>            exc = e;
<a name="1412"></a>        }
<a name="1413"></a>        if (ok)
<a name="1414"></a>        {
<a name="1415"></a>            /* remember that recording is in effect */
<a name="1416"></a>            scriptStatus.recordFile = fname;
<a name="1417"></a>
<a name="1418"></a>            /* note that logging is active, if acknowledgment is desired */
<a name="1419"></a>            if (ack)
<a name="1420"></a>                gLibMessages.recordingOkay();
<a name="1421"></a>        }
<a name="1422"></a>        else
<a name="1423"></a>        {
<a name="1424"></a>            /* recording failed */
<a name="1425"></a>            scriptStatus.recordFile = nil;
<a name="1426"></a>
<a name="1427"></a>            /* show an error if acknowledgment is desired */
<a name="1428"></a>            if (ack)
<a name="1429"></a>            {
<a name="1430"></a>                if (exc != nil)
<a name="1431"></a>                    gLibMessages.recordingFailedException(exc);
<a name="1432"></a>                else
<a name="1433"></a>                    gLibMessages.recordingFailed();
<a name="1434"></a>            }
<a name="1435"></a>        }
<a name="1436"></a>    }
<a name="1437"></a>
<a name="1438"></a>    /* the log file type - by default, we open a regular command log */
<a name="1439"></a>    logFileType = LogTypeCommand
<a name="1440"></a>;
<a name="1441"></a>
<a name="1442"></a>/* subclass of Record action that sets up an event script recording */
<a name="1443"></a>DefineAction(RecordEvents, RecordAction)
<a name="1444"></a>    logFileType = LogTypeScript
<a name="1445"></a>;
<a name="1446"></a>
<a name="1447"></a>/* subclass of Record action taking a quoted string for the filename */
<a name="1448"></a>DefineAction(RecordString, RecordAction)
<a name="1449"></a>    execSystemAction()
<a name="1450"></a>    {
<a name="1451"></a>        /* set up scripting to the filename specified in the command */
<a name="1452"></a>        performFileOp(fname_.getStringText(), true);
<a name="1453"></a>    }
<a name="1454"></a>;
<a name="1455"></a>
<a name="1456"></a>/* subclass of RecordString action that sets up an event script recording */
<a name="1457"></a>DefineAction(RecordEventsString, RecordStringAction)
<a name="1458"></a>    logFileType = LogTypeScript
<a name="1459"></a>;
<a name="1460"></a>
<a name="1461"></a>/*
<a name="1462"></a> *   Turn command recording off.  This stops recording the command log
<a name="1463"></a> *   started with the most recent RECORD command.
<a name="1464"></a> */
<a name="1465"></a>DefineSystemAction(RecordOff)
<a name="1466"></a>    execSystemAction()
<a name="1467"></a>    {
<a name="1468"></a>        /* turn off recording */
<a name="1469"></a>        turnOffRecording(true);
<a name="1470"></a>    }
<a name="1471"></a>
<a name="1472"></a>    /* turn off recording */
<a name="1473"></a>    turnOffRecording(ack)
<a name="1474"></a>    {
<a name="1475"></a>        /* if we're not recording anything, ignore it */
<a name="1476"></a>        if (scriptStatus.recordFile == nil)
<a name="1477"></a>        {
<a name="1478"></a>            gLibMessages.recordOffIgnored();
<a name="1479"></a>            return;
<a name="1480"></a>        }
<a name="1481"></a>
<a name="1482"></a>        /* cancel recording in the interpreter's output layer */
<a name="1483"></a>        aioSetLogFile(nil, LogTypeCommand);
<a name="1484"></a>
<a name="1485"></a>        /* remember that recording is no longer in effect */
<a name="1486"></a>        scriptStatus.recordFile = nil;
<a name="1487"></a>
<a name="1488"></a>        /* acknowledge the change, if desired */
<a name="1489"></a>        if (ack)
<a name="1490"></a>            gLibMessages.recordOffOkay();
<a name="1491"></a>    }
<a name="1492"></a>
<a name="1493"></a>    /* we can't include this in undo, as it affects external files */
<a name="1494"></a>    includeInUndo = nil
<a name="1495"></a>;
<a name="1496"></a>
<a name="1497"></a>/*
<a name="1498"></a> *   REPLAY - play back a command log previously recorded.
<a name="1499"></a> */
<a name="1500"></a>DefineAction(Replay, FileOpAction)
<a name="1501"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="1502"></a>    filePromptMsg = (gLibMessages.getReplayPrompt())
<a name="1503"></a>    fileTypeID = FileTypeCmd
<a name="1504"></a>    fileDisposition = InFileOpen
<a name="1505"></a>
<a name="1506"></a>    /* show our cancellation mesasge */
<a name="1507"></a>    showCancelMsg() { gLibMessages.replayCanceled(); }
<a name="1508"></a>
<a name="1509"></a>    /* script flags passed to setScriptFile */
<a name="1510"></a>    scriptOptionFlags = 0
<a name="1511"></a>
<a name="1512"></a>    /* replay the given file */
<a name="1513"></a>    performFileOp(fname, ack)
<a name="1514"></a>    {
<a name="1515"></a>        /*
<a name="1516"></a>         *   Note that we're reading from the script file if desired.  Do
<a name="1517"></a>         *   this before opening the script, so that we display the
<a name="1518"></a>         *   acknowledgment even if we're in 'quiet' mode.
<a name="1519"></a>         */
<a name="1520"></a>        if (ack)
<a name="1521"></a>            gLibMessages.inputScriptOkay(
<a name="1522"></a>                fname.ofKind(TemporaryFile) ? fname.getFilename() : fname);
<a name="1523"></a>
<a name="1524"></a>        /* activate the script file */
<a name="1525"></a>        local ok = nil, exc = nil;
<a name="1526"></a>        try
<a name="1527"></a>        {
<a name="1528"></a>            ok = setScriptFile(fname, scriptOptionFlags);
<a name="1529"></a>        }
<a name="1530"></a>        catch (Exception e)
<a name="1531"></a>        {
<a name="1532"></a>            exc = e;
<a name="1533"></a>        }
<a name="1534"></a>        if (!ok)
<a name="1535"></a>        {
<a name="1536"></a>            if (exc != nil)
<a name="1537"></a>                gLibMessages.inputScriptFailed(exc);
<a name="1538"></a>            else
<a name="1539"></a>                gLibMessages.inputScriptFailed();
<a name="1540"></a>        }
<a name="1541"></a>    }
<a name="1542"></a>;
<a name="1543"></a>
<a name="1544"></a>/* subclass of Replay action taking a quoted string for the filename */
<a name="1545"></a>DefineAction(ReplayString, ReplayAction)
<a name="1546"></a>    execSystemAction()
<a name="1547"></a>    {
<a name="1548"></a>        /*
<a name="1549"></a>         *   if there's a string, use the string as the filename;
<a name="1550"></a>         *   otherwise, inherit the default handling to ask for a filename
<a name="1551"></a>         */
<a name="1552"></a>        if (fname_ != nil)
<a name="1553"></a>        {
<a name="1554"></a>            /* set up scripting to the filename specified in the command */
<a name="1555"></a>            performFileOp(fname_.getStringText(), true);
<a name="1556"></a>        }
<a name="1557"></a>        else
<a name="1558"></a>        {
<a name="1559"></a>            /* inherit the default handling to ask for a filename */
<a name="1560"></a>            inherited();
<a name="1561"></a>        }
<a name="1562"></a>    }
<a name="1563"></a>;
<a name="1564"></a>
<a name="1565"></a>
<a name="1566"></a>/* in case the footnote module is not present */
<a name="1567"></a>property showFootnote;
<a name="1568"></a>
<a name="1569"></a>/*
<a name="1570"></a> *   Footnote - this requires a numeric argument parsed via the
<a name="1571"></a> *   numberPhrase production and assigned to the numMatch property.
<a name="1572"></a> */
<a name="1573"></a>DefineSystemAction(Footnote)
<a name="1574"></a>    execSystemAction()
<a name="1575"></a>    {
<a name="1576"></a>        /* ask the Footnote class to do the work */
<a name="1577"></a>        if (libGlobal.footnoteClass != nil)
<a name="1578"></a>            libGlobal.footnoteClass.showFootnote(numMatch.getval());
<a name="1579"></a>        else
<a name="1580"></a>            gLibMessages.commandNotPresent;
<a name="1581"></a>    }
<a name="1582"></a>
<a name="1583"></a>    /* there's no point in including this in undo */
<a name="1584"></a>    includeInUndo = nil
<a name="1585"></a>;
<a name="1586"></a>
<a name="1587"></a>property footnoteSettings;
<a name="1588"></a>
<a name="1589"></a>/* base class for FOOTNOTES xxx commands */
<a name="1590"></a>DefineSystemAction(Footnotes)
<a name="1591"></a>    execSystemAction()
<a name="1592"></a>    {
<a name="1593"></a>        if (libGlobal.footnoteClass != nil)
<a name="1594"></a>        {
<a name="1595"></a>            /* set my footnote status in the global setting */
<a name="1596"></a>            libGlobal.footnoteClass.footnoteSettings.showFootnotes =
<a name="1597"></a>                showFootnotes;
<a name="1598"></a>
<a name="1599"></a>            /* acknowledge it */
<a name="1600"></a>            gLibMessages.acknowledgeFootnoteStatus(showFootnotes);
<a name="1601"></a>        }
<a name="1602"></a>        else
<a name="1603"></a>            gLibMessages.commandNotPresent;
<a name="1604"></a>    }
<a name="1605"></a>
<a name="1606"></a>    /*
<a name="1607"></a>     *   the footnote status I set when this command is activated - this
<a name="1608"></a>     *   must be overridden by each subclass
<a name="1609"></a>     */
<a name="1610"></a>    showFootnotes = nil
<a name="1611"></a>;
<a name="1612"></a>
<a name="1613"></a>DefineAction(FootnotesFull, FootnotesAction)
<a name="1614"></a>    showFootnotes = FootnotesFull
<a name="1615"></a>;
<a name="1616"></a>
<a name="1617"></a>DefineAction(FootnotesMedium, FootnotesAction)
<a name="1618"></a>    showFootnotes = FootnotesMedium
<a name="1619"></a>;
<a name="1620"></a>
<a name="1621"></a>DefineAction(FootnotesOff, FootnotesAction)
<a name="1622"></a>    showFootnotes = FootnotesOff
<a name="1623"></a>;
<a name="1624"></a>
<a name="1625"></a>DefineSystemAction(FootnotesStatus)
<a name="1626"></a>    execSystemAction()
<a name="1627"></a>    {
<a name="1628"></a>        /* show the current status */
<a name="1629"></a>        if (libGlobal.footnoteClass != nil)
<a name="1630"></a>            gLibMessages.showFootnoteStatus(libGlobal.footnoteClass.
<a name="1631"></a>                                            footnoteSettings.showFootnotes);
<a name="1632"></a>        else
<a name="1633"></a>            gLibMessages.commandNotPresent;
<a name="1634"></a>    }
<a name="1635"></a>
<a name="1636"></a>    /* there's no point in including this in undo */
<a name="1637"></a>    includeInUndo = nil
<a name="1638"></a>;
<a name="1639"></a>
<a name="1640"></a>DefineIAction(Inventory)
<a name="1641"></a>    execAction()
<a name="1642"></a>    {
<a name="1643"></a>        /* show the actor's inventory in the current mode */
<a name="1644"></a>        gActor.showInventory(inventoryMode == InventoryTall);
<a name="1645"></a>    }
<a name="1646"></a>
<a name="1647"></a>    /* current inventory mode - start in 'wide' mode by default */
<a name="1648"></a>    inventoryMode = InventoryWide;
<a name="1649"></a>;
<a name="1650"></a>
<a name="1651"></a>DefineIAction(InventoryTall)
<a name="1652"></a>    execAction()
<a name="1653"></a>    {
<a name="1654"></a>        /* set inventory mode to 'tall' */
<a name="1655"></a>        InventoryAction.inventoryMode = InventoryTall;
<a name="1656"></a>
<a name="1657"></a>        /* run the inventory action */
<a name="1658"></a>        InventoryAction.checkAction();
<a name="1659"></a>        InventoryAction.execAction();
<a name="1660"></a>    }
<a name="1661"></a>;
<a name="1662"></a>
<a name="1663"></a>DefineIAction(InventoryWide)
<a name="1664"></a>    execAction()
<a name="1665"></a>    {
<a name="1666"></a>        /* set inventory mode to 'wide' */
<a name="1667"></a>        InventoryAction.inventoryMode = InventoryWide;
<a name="1668"></a>
<a name="1669"></a>        /* run the inventory action */
<a name="1670"></a>        InventoryAction.checkAction();
<a name="1671"></a>        InventoryAction.execAction();
<a name="1672"></a>    }
<a name="1673"></a>;
<a name="1674"></a>
<a name="1675"></a>DefineIAction(Wait)
<a name="1676"></a>    execAction()
<a name="1677"></a>    {
<a name="1678"></a>        /* just show the "time passes" message */
<a name="1679"></a>        defaultReport(&amp;timePassesMsg);
<a name="1680"></a>    }
<a name="1681"></a>;
<a name="1682"></a>
<a name="1683"></a>DefineIAction(Look)
<a name="1684"></a>    execAction()
<a name="1685"></a>    {
<a name="1686"></a>        /* show the actor's current location in verbose mode */
<a name="1687"></a>        gActor.lookAround(true);
<a name="1688"></a>    }
<a name="1689"></a>;
<a name="1690"></a>
<a name="1691"></a>DefineIAction(Sleep)
<a name="1692"></a>    execAction()
<a name="1693"></a>    {
<a name="1694"></a>        /* let the actor handle it */
<a name="1695"></a>        gActor.goToSleep();
<a name="1696"></a>    }
<a name="1697"></a>;
<a name="1698"></a>
<a name="1699"></a>DefineTAction(Take)
<a name="1700"></a>    /* this is a basic inventory-management verb, so allow ALL with it */
<a name="1701"></a>    actionAllowsAll = true
<a name="1702"></a>
<a name="1703"></a>    /* get the ALL list for the direct object */
<a name="1704"></a>    getAllDobj(actor, scopeList)
<a name="1705"></a>    {
<a name="1706"></a>        local locList;
<a name="1707"></a>        local dropLoc;
<a name="1708"></a>        local actorLoc;
<a name="1709"></a>
<a name="1710"></a>        /*
<a name="1711"></a>         *   Include all of the objects that are directly in the actor's
<a name="1712"></a>         *   immediate container, the container's container, and so on out
<a name="1713"></a>         *   to the "drop destination" location (which is where things go
<a name="1714"></a>         *   when we DROP them, and is meant to represent the nearest
<a name="1715"></a>         *   platform-like or floor-like container).  Also include anything
<a name="1716"></a>         *   that's directly in anything fixed in place within one of these
<a name="1717"></a>         *   containers.  Don't include anything that actually contains the
<a name="1718"></a>         *   actor, since we normally can't pick up something we're inside.
<a name="1719"></a>         *
<a name="1720"></a>         *   Start by getting the actor's immediate location and drop
<a name="1721"></a>         *   destination location.
<a name="1722"></a>         */
<a name="1723"></a>        actorLoc = actor.location;
<a name="1724"></a>        dropLoc = actor.getDropDestination(nil, nil);
<a name="1725"></a>
<a name="1726"></a>        /*
<a name="1727"></a>         *   create a vector to hold the location list, and start it off
<a name="1728"></a>         *   with the drop location
<a name="1729"></a>         */
<a name="1730"></a>        locList = new Vector(10);
<a name="1731"></a>        locList.append(dropLoc);
<a name="1732"></a>
<a name="1733"></a>        /* now work up the location list until we hit the drop location */
<a name="1734"></a>        for (local cur = actorLoc ; cur != nil &amp;&amp; cur != dropLoc ;
<a name="1735"></a>             cur = cur.location)
<a name="1736"></a>        {
<a name="1737"></a>            /* add this container to the list */
<a name="1738"></a>            locList.append(cur);
<a name="1739"></a>        }
<a name="1740"></a>
<a name="1741"></a>        /*
<a name="1742"></a>         *   now generate the subset of in-scope objects that are directly
<a name="1743"></a>         *   in any of these locations (or directly in items fixed in place
<a name="1744"></a>         *   within any of these locations), and return the result
<a name="1745"></a>         */
<a name="1746"></a>        return scopeList.subset(
<a name="1747"></a>            {x: (locList.indexWhich(
<a name="1748"></a>                {loc: x.isDirectlyIn(loc) || x.isInFixedIn(loc)}) != nil
<a name="1749"></a>                 &amp;&amp; !actor.isIn(x)) });
<a name="1750"></a>    }
<a name="1751"></a>;
<a name="1752"></a>
<a name="1753"></a>DefineTIAction(TakeFrom)
<a name="1754"></a>    /* this is a basic inventory-management verb, so allow ALL with it */
<a name="1755"></a>    actionAllowsAll = true
<a name="1756"></a>
<a name="1757"></a>    /* get the ALL list for the direct object */
<a name="1758"></a>    getAllDobj(actor, scopeList)
<a name="1759"></a>    {
<a name="1760"></a>        /* ask the indirect object for the list */
<a name="1761"></a>        return getIobj() == nil
<a name="1762"></a>            ? []
<a name="1763"></a>            : getIobj().getAllForTakeFrom(scopeList);
<a name="1764"></a>    }
<a name="1765"></a>;
<a name="1766"></a>
<a name="1767"></a>DefineTAction(Remove)
<a name="1768"></a>;
<a name="1769"></a>
<a name="1770"></a>DefineTAction(Drop)
<a name="1771"></a>    /* this is a basic inventory-management verb, so allow ALL with it */
<a name="1772"></a>    actionAllowsAll = true
<a name="1773"></a>
<a name="1774"></a>    /* get the ALL list for the direct object */
<a name="1775"></a>    getAllDobj(actor, scopeList)
<a name="1776"></a>    {
<a name="1777"></a>        /* include only objects directly held by the actor */
<a name="1778"></a>        return scopeList.subset({x: x.isDirectlyIn(actor)});
<a name="1779"></a>    }
<a name="1780"></a>;
<a name="1781"></a>
<a name="1782"></a>DefineTAction(Examine)
<a name="1783"></a>;
<a name="1784"></a>
<a name="1785"></a>DefineTAction(Read)
<a name="1786"></a>;
<a name="1787"></a>
<a name="1788"></a>DefineTAction(LookIn)
<a name="1789"></a>;
<a name="1790"></a>
<a name="1791"></a>DefineTAction(Search)
<a name="1792"></a>;
<a name="1793"></a>
<a name="1794"></a>DefineTAction(LookUnder)
<a name="1795"></a>;
<a name="1796"></a>
<a name="1797"></a>DefineTAction(LookBehind)
<a name="1798"></a>;
<a name="1799"></a>
<a name="1800"></a>DefineTAction(LookThrough)
<a name="1801"></a>;
<a name="1802"></a>
<a name="1803"></a>DefineTAction(Feel)
<a name="1804"></a>;
<a name="1805"></a>
<a name="1806"></a>DefineTAction(Taste)
<a name="1807"></a>;
<a name="1808"></a>
<a name="1809"></a>DefineTAction(Smell)
<a name="1810"></a>;
<a name="1811"></a>
<a name="1812"></a>DefineTAction(ListenTo)
<a name="1813"></a>;
<a name="1814"></a>
<a name="1815"></a>/*
<a name="1816"></a> *   Base class for undirected sensing, such as "listen" or "smell" with no
<a name="1817"></a> *   object.  We'll scan for things that have a presence in the
<a name="1818"></a> *   corresponding sense and describe each one.
<a name="1819"></a> */
<a name="1820"></a>DefineIAction(SenseImplicit)
<a name="1821"></a>    /* the sense in which I operate */
<a name="1822"></a>    mySense = nil
<a name="1823"></a>
<a name="1824"></a>    /* the object property to display this sense's description */
<a name="1825"></a>    descProp = nil
<a name="1826"></a>
<a name="1827"></a>    /* the default message to display if we find nothing specific to sense */
<a name="1828"></a>    defaultMsgProp = nil
<a name="1829"></a>
<a name="1830"></a>    /* the Lister we use to show the items */
<a name="1831"></a>    resultLister = nil
<a name="1832"></a>
<a name="1833"></a>    /* execute the action */
<a name="1834"></a>    execAction()
<a name="1835"></a>    {
<a name="1836"></a>        local senseTab;
<a name="1837"></a>        local presenceList;
<a name="1838"></a>
<a name="1839"></a>        /* get a list of everything in range of this sense for the actor */
<a name="1840"></a>        senseTab = gActor.senseInfoTable(mySense);
<a name="1841"></a>
<a name="1842"></a>        /* get a list of everything with a presence in this sense */
<a name="1843"></a>        presenceList = senseInfoTableSubset(senseTab,
<a name="1844"></a>            {obj, info: obj.(mySense.presenceProp)});
<a name="1845"></a>
<a name="1846"></a>        /*
<a name="1847"></a>         *   if there's anything in the list, show it; otherwise, show a
<a name="1848"></a>         *   default report
<a name="1849"></a>         */
<a name="1850"></a>        if (presenceList.length() != 0)
<a name="1851"></a>        {
<a name="1852"></a>            /* show the list using our lister */
<a name="1853"></a>            resultLister.showList(gActor, nil, presenceList, 0, 0,
<a name="1854"></a>                                  senseTab, nil);
<a name="1855"></a>        }
<a name="1856"></a>        else
<a name="1857"></a>        {
<a name="1858"></a>            /* there's nothing to show - say so */
<a name="1859"></a>            defaultReport(defaultMsgProp);
<a name="1860"></a>        }
<a name="1861"></a>    }
<a name="1862"></a>;
<a name="1863"></a>
<a name="1864"></a>DefineAction(SmellImplicit, SenseImplicitAction)
<a name="1865"></a>    mySense = smell
<a name="1866"></a>    descProp = &amp;smellDesc
<a name="1867"></a>    defaultMsgProp = &amp;nothingToSmellMsg
<a name="1868"></a>    resultLister = smellActionLister
<a name="1869"></a>;
<a name="1870"></a>
<a name="1871"></a>DefineAction(ListenImplicit, SenseImplicitAction)
<a name="1872"></a>    mySense = sound
<a name="1873"></a>    descProp = &amp;soundDesc
<a name="1874"></a>    defaultMsgProp = &amp;nothingToHearMsg
<a name="1875"></a>    resultLister = listenActionLister
<a name="1876"></a>;
<a name="1877"></a>
<a name="1878"></a>DefineTIAction(PutIn)
<a name="1879"></a>    /* this is a basic inventory-management verb, so allow ALL with it */
<a name="1880"></a>    actionAllowsAll = true
<a name="1881"></a>
<a name="1882"></a>    /* get the ALL list for the direct object */
<a name="1883"></a>    getAllDobj(actor, scopeList)
<a name="1884"></a>    {
<a name="1885"></a>        local loc;
<a name="1886"></a>        local iobj = nil;
<a name="1887"></a>        local iobjIdent = nil;
<a name="1888"></a>
<a name="1889"></a>        /* get the actor's location */
<a name="1890"></a>        loc = actor.location;
<a name="1891"></a>
<a name="1892"></a>        /* if we have an iobj list, retrieve its first element */
<a name="1893"></a>        if (iobjList_ != nil &amp;&amp; iobjList_.length() &gt; 0)
<a name="1894"></a>        {
<a name="1895"></a>            iobj = iobjList_[1].obj_;
<a name="1896"></a>            iobjIdent = iobj.getIdentityObject();
<a name="1897"></a>        }
<a name="1898"></a>
<a name="1899"></a>        /*
<a name="1900"></a>         *   Include objects that are directly in the actor's location, or
<a name="1901"></a>         *   within fixed items in the actor's location, or directly in the
<a name="1902"></a>         *   actor's inventory.
<a name="1903"></a>         *
<a name="1904"></a>         *   Exclude the indirect object and its "identity" object (since
<a name="1905"></a>         *   we obviously can't put the indirect object in itself), and
<a name="1906"></a>         *   exclude everything already directly in the indirect object.
<a name="1907"></a>         */
<a name="1908"></a>        return scopeList.subset({x:
<a name="1909"></a>                                (x.isDirectlyIn(loc)
<a name="1910"></a>                                 || x.isInFixedIn(loc)
<a name="1911"></a>                                 || x.isDirectlyIn(actor))
<a name="1912"></a>                                &amp;&amp; x != iobj
<a name="1913"></a>                                &amp;&amp; x != iobjIdent
<a name="1914"></a>                                &amp;&amp; !x.isDirectlyIn(iobj)});
<a name="1915"></a>    }
<a name="1916"></a>;
<a name="1917"></a>
<a name="1918"></a>DefineTIAction(PutOn)
<a name="1919"></a>    /* this is a basic inventory-management verb, so allow ALL with it */
<a name="1920"></a>    actionAllowsAll = true
<a name="1921"></a>
<a name="1922"></a>    /* get the ALL list for the direct object */
<a name="1923"></a>    getAllDobj(actor, scopeList)
<a name="1924"></a>    {
<a name="1925"></a>        /* use the same strategy that we do in PutIn */
<a name="1926"></a>        local loc = actor.location;
<a name="1927"></a>        return scopeList.subset({x:
<a name="1928"></a>                                (x.isDirectlyIn(loc)
<a name="1929"></a>                                 || x.isInFixedIn(loc)
<a name="1930"></a>                                 || x.isDirectlyIn(actor))
<a name="1931"></a>                                &amp;&amp; x != getIobj()
<a name="1932"></a>                                &amp;&amp; !x.isDirectlyIn(getIobj())});
<a name="1933"></a>    }
<a name="1934"></a>;
<a name="1935"></a>
<a name="1936"></a>DefineTIAction(PutUnder)
<a name="1937"></a>;
<a name="1938"></a>
<a name="1939"></a>DefineTIAction(PutBehind)
<a name="1940"></a>;
<a name="1941"></a>
<a name="1942"></a>DefineTAction(Wear)
<a name="1943"></a>;
<a name="1944"></a>
<a name="1945"></a>DefineTAction(Doff)
<a name="1946"></a>;
<a name="1947"></a>
<a name="1948"></a>DefineConvTopicTAction(AskFor, IndirectObject)
<a name="1949"></a>;
<a name="1950"></a>
<a name="1951"></a>DefineConvTopicTAction(AskAbout, IndirectObject)
<a name="1952"></a>;
<a name="1953"></a>
<a name="1954"></a>DefineConvTopicTAction(TellAbout, IndirectObject)
<a name="1955"></a>    /*
<a name="1956"></a>     *   TELL ABOUT is a conversational address, as opposed to an order,
<a name="1957"></a>     *   if the direct object of the action is the same as the issuer: in
<a name="1958"></a>     *   this case, the command has the form &lt;actor&gt;, TELL ME ABOUT
<a name="1959"></a>     *   &lt;topic&gt;, which has exactly the same meaning as ASK &lt;actor&gt; ABOUT
<a name="1960"></a>     *   &lt;topic&gt;.
<a name="1961"></a>     */
<a name="1962"></a>    isConversational(issuer)
<a name="1963"></a>    {
<a name="1964"></a>        local dobj;
<a name="1965"></a>
<a name="1966"></a>        /*
<a name="1967"></a>         *   if the resolved direct object matches the issuer, it's
<a name="1968"></a>         *   conversational
<a name="1969"></a>         */
<a name="1970"></a>        dobj = getResolvedDobjList();
<a name="1971"></a>        return (dobj.length() == 1 &amp;&amp; dobj[1] == issuer);
<a name="1972"></a>    }
<a name="1973"></a>;
<a name="1974"></a>
<a name="1975"></a>/*
<a name="1976"></a> *   AskVague and TellVague are for syntactically incorrect phrasings that
<a name="1977"></a> *   a player might accidentally type, especially in conjunction with a
<a name="1978"></a> *   past SpecialTopic prompt; in English, for example, we define these as
<a name="1979"></a> *   ASK &lt;actor&gt; &lt;topic&gt; and TELL &lt;actor&gt; &lt;topic&gt;.  These are used only to
<a name="1980"></a> *   provide more helpful error messages.
<a name="1981"></a> */
<a name="1982"></a>DefineTopicTAction(AskVague, IndirectObject)
<a name="1983"></a>;
<a name="1984"></a>DefineTopicTAction(TellVague, IndirectObject)
<a name="1985"></a>;
<a name="1986"></a>
<a name="1987"></a>DefineConvIAction(Hello)
<a name="1988"></a>    execAction()
<a name="1989"></a>    {
<a name="1990"></a>        /* the issuing actor is saying hello to the target actor */
<a name="1991"></a>        gIssuingActor.sayHello(gActor);
<a name="1992"></a>    }
<a name="1993"></a>;
<a name="1994"></a>
<a name="1995"></a>DefineConvIAction(Goodbye)
<a name="1996"></a>    execAction()
<a name="1997"></a>    {
<a name="1998"></a>        /* the issuing actor is saying goodbye to the target actor */
<a name="1999"></a>        gIssuingActor.sayGoodbye(gActor);
<a name="2000"></a>    }
<a name="2001"></a>;
<a name="2002"></a>
<a name="2003"></a>DefineConvIAction(Yes)
<a name="2004"></a>    execAction()
<a name="2005"></a>    {
<a name="2006"></a>        /* the issuing actor is saying yes to the target actor */
<a name="2007"></a>        gIssuingActor.sayYes(gActor);
<a name="2008"></a>    }
<a name="2009"></a>;
<a name="2010"></a>
<a name="2011"></a>DefineConvIAction(No)
<a name="2012"></a>    execAction()
<a name="2013"></a>    {
<a name="2014"></a>        /* the issuing actor is saying no to the target actor */
<a name="2015"></a>        gIssuingActor.sayNo(gActor);
<a name="2016"></a>    }
<a name="2017"></a>;
<a name="2018"></a>
<a name="2019"></a>/*
<a name="2020"></a> *   Invoke the active SpecialTopic.  This isn't a real command - the
<a name="2021"></a> *   player will never actually type this; rather, it's a pseudo-command
<a name="2022"></a> *   that we send to ourselves from a string pre-parser when we recognize
<a name="2023"></a> *   input that matches a SpecialTopic's custom command syntax.
<a name="2024"></a> *
<a name="2025"></a> *   Note that we actually define the syntax for this command right here
<a name="2026"></a> *   in the language-independent library, because this isn't a real
<a name="2027"></a> *   command.  The user never needs to type this command, since it's
<a name="2028"></a> *   something we generate internally.  The only important language issue
<a name="2029"></a> *   is that we use a command keyword that no language will ever want to
<a name="2030"></a> *   use for a real command, so we intentionally use some near-English
<a name="2031"></a> *   gibberish.
<a name="2032"></a> */
<a name="2033"></a>DefineLiteralAction(SpecialTopic)
<a name="2034"></a>    execAction()
<a name="2035"></a>    {
<a name="2036"></a>        /*
<a name="2037"></a>         *   the issuing actor is saying the current special topic to the
<a name="2038"></a>         *   actor's current interlocutor
<a name="2039"></a>         */
<a name="2040"></a>        gIssuingActor.saySpecialTopic();
<a name="2041"></a>    }
<a name="2042"></a>
<a name="2043"></a>    /*
<a name="2044"></a>     *   Repeat the action, for an AGAIN command.  We need to make sure
<a name="2045"></a>     *   the special text interpretation we gave to the command still
<a name="2046"></a>     *   holds; if not, reparse the original text and try that.
<a name="2047"></a>     */
<a name="2048"></a>    repeatAction(lastTargetActor, lastTargetActorPhrase,
<a name="2049"></a>                 lastIssuingActor, countsAsIssuerTurn)
<a name="2050"></a>    {
<a name="2051"></a>        local cmd;
<a name="2052"></a>
<a name="2053"></a>        /* get the original text the player entered */
<a name="2054"></a>        cmd = getEnteredText();
<a name="2055"></a>
<a name="2056"></a>        /*
<a name="2057"></a>         *   try running this through the special topic pre-parser again,
<a name="2058"></a>         *   to see if it still has the special meaning
<a name="2059"></a>         */
<a name="2060"></a>        if (specialTopicPreParser.doParsing(cmd, rmcCommand)
<a name="2061"></a>            .startsWith('xspcltopic '))
<a name="2062"></a>        {
<a name="2063"></a>            /*
<a name="2064"></a>             *   it still has the special meaning, so simply execute as we
<a name="2065"></a>             *   normally would, by inheriting the standard Action
<a name="2066"></a>             *   handling
<a name="2067"></a>             */
<a name="2068"></a>            inherited(lastTargetActor, lastTargetActorPhrase,
<a name="2069"></a>                      lastIssuingActor, countsAsIssuerTurn);
<a name="2070"></a>        }
<a name="2071"></a>        else
<a name="2072"></a>        {
<a name="2073"></a>            /*
<a name="2074"></a>             *   The command no longer has the special meaning it did on
<a name="2075"></a>             *   the last command, so we can't repeat this command.
<a name="2076"></a>             */
<a name="2077"></a>            gLibMessages.againNotPossible(lastIssuingActor);
<a name="2078"></a>        }
<a name="2079"></a>    }
<a name="2080"></a>
<a name="2081"></a>    /*
<a name="2082"></a>     *   Get the original player-entered text.  This is our literal
<a name="2083"></a>     *   phrase, with the embedded-quote encoding decoded.
<a name="2084"></a>     */
<a name="2085"></a>    getEnteredText() { return decodeOrig(getLiteral()); }
<a name="2086"></a>
<a name="2087"></a>    /*
<a name="2088"></a>     *   encode the original text for our literal phrase: turn double
<a name="2089"></a>     *   quotes into '%q' sequences, and turn percent signs into '%%'
<a name="2090"></a>     *   sequences
<a name="2091"></a>     */
<a name="2092"></a>    encodeOrig(txt)
<a name="2093"></a>    {
<a name="2094"></a>        /* replace '%' with '%%', and double quotes with '%q' */
<a name="2095"></a>        return txt.findReplace(['%', '"'], ['%%', '%q']);
<a name="2096"></a>    }
<a name="2097"></a>
<a name="2098"></a>    /* decode our encoding */
<a name="2099"></a>    decodeOrig(txt)
<a name="2100"></a>    {
<a name="2101"></a>        /* replace '%%' with '%', and '%q' with '"' */
<a name="2102"></a>        return txt.findReplace(['%%', '%q'], ['%', '"']);
<a name="2103"></a>    }
<a name="2104"></a>;
<a name="2105"></a>
<a name="2106"></a>grammar predicate(SpecialTopic):
<a name="2107"></a>    'xspcltopic' literalPhrase-&gt;literalMatch
<a name="2108"></a>    : SpecialTopicAction
<a name="2109"></a>
<a name="2110"></a>    /*
<a name="2111"></a>     *   Use the text of the command as originally typed by the player as
<a name="2112"></a>     *   our apparent original text.
<a name="2113"></a>     */
<a name="2114"></a>    getOrigText() { return getEnteredText(); }
<a name="2115"></a>;
<a name="2116"></a>
<a name="2117"></a>/* in case they try typing just 'xspcltopic' */
<a name="2118"></a>grammar predicate(EmptySpecialTopic):
<a name="2119"></a>    'xspcltopic' : IAction
<a name="2120"></a>
<a name="2121"></a>    /* just act like we don't understand this command */
<a name="2122"></a>    execAction() { gLibMessages.commandNotPresent; }
<a name="2123"></a>;
<a name="2124"></a>
<a name="2125"></a>DefineTAction(Kiss)
<a name="2126"></a>;
<a name="2127"></a>
<a name="2128"></a>DefineIAction(Yell)
<a name="2129"></a>    execAction()
<a name="2130"></a>    {
<a name="2131"></a>        /* yelling generally has no effect; issue a default response */
<a name="2132"></a>        mainReport(&amp;okayYellMsg);
<a name="2133"></a>    }
<a name="2134"></a>;
<a name="2135"></a>
<a name="2136"></a>DefineTAction(TalkTo)
<a name="2137"></a>;
<a name="2138"></a>
<a name="2139"></a>DefineSystemAction(Topics)
<a name="2140"></a>    execSystemAction()
<a name="2141"></a>    {
<a name="2142"></a>        /* check to see if any suggestions are defined in the entire game */
<a name="2143"></a>        if (firstObj(SuggestedTopic, ObjInstances) != nil)
<a name="2144"></a>        {
<a name="2145"></a>            /* we have topics - let the actor handle it */
<a name="2146"></a>            gActor.suggestTopics(true);
<a name="2147"></a>        }
<a name="2148"></a>        else
<a name="2149"></a>        {
<a name="2150"></a>            /* there are no topics at all, so this command isn't used */
<a name="2151"></a>            gLibMessages.commandNotPresent;
<a name="2152"></a>        }
<a name="2153"></a>    }
<a name="2154"></a>
<a name="2155"></a>    /* don't include this in undo */
<a name="2156"></a>    includeInUndo = nil
<a name="2157"></a>;
<a name="2158"></a>
<a name="2159"></a>DefineTIAction(GiveTo)
<a name="2160"></a>    getDefaultIobj(np, resolver)
<a name="2161"></a>    {
<a name="2162"></a>        /* check the actor for a current interlocutor */
<a name="2163"></a>        local obj = resolver.getTargetActor().getCurrentInterlocutor();
<a name="2164"></a>        if (obj != nil)
<a name="2165"></a>            return [new ResolveInfo(obj, 0, np)];
<a name="2166"></a>        else
<a name="2167"></a>            return inherited(np, resolver);
<a name="2168"></a>    }
<a name="2169"></a>;
<a name="2170"></a>
<a name="2171"></a>/*
<a name="2172"></a> *   Define a global remapping to transform commands of the form "X, GIVE
<a name="2173"></a> *   ME Y" to the format "ME, ASK X FOR Y".  This makes it easier to write
<a name="2174"></a> *   the code to handle these sorts of exchanges, since it means you only
<a name="2175"></a> *   have to write it in the ASK FOR handler.
<a name="2176"></a> */
<a name="2177"></a>giveMeToAskFor: GlobalRemapping
<a name="2178"></a>    /*
<a name="2179"></a>     *   Remap a command, if applicable.  We look for commands of the form
<a name="2180"></a>     *   "X, GIVE ME Y": we look for a GiveTo action whose indirect object
<a name="2181"></a>     *   is the same as the issuing actor.  When we find this form of
<a name="2182"></a>     *   command, we rewrite it to "ME, ASK X FOR Y".
<a name="2183"></a>     */
<a name="2184"></a>    getRemapping(issuingActor, targetActor, action)
<a name="2185"></a>    {
<a name="2186"></a>        /*
<a name="2187"></a>         *   if it's of the form "X, GIVE Y TO Z", where Z is the issuing
<a name="2188"></a>         *   actor (generally ME, but it could conceivably be someone
<a name="2189"></a>         *   else), transform it into "Z, ASK X FOR Y".
<a name="2190"></a>         */
<a name="2191"></a>        if (action.ofKind(GiveToAction)
<a name="2192"></a>            &amp;&amp; action.canIobjResolveTo(issuingActor))
<a name="2193"></a>        {
<a name="2194"></a>            /* create the ASK FOR action */
<a name="2195"></a>            local newAction = AskForAction.createActionInstance();
<a name="2196"></a>
<a name="2197"></a>            /* remember the original version of the action */
<a name="2198"></a>            newAction.setOriginalAction(action);
<a name="2199"></a>
<a name="2200"></a>            /*
<a name="2201"></a>             *   Changing the phrasing from "X, GIVE Y TO Z" to "Z, ASK X
<a name="2202"></a>             *   FOR Y" will change the target actor from X in the old
<a name="2203"></a>             *   version to Z in the new version.  In the original format,
<a name="2204"></a>             *   the pronouns "you", "your", and "yours" implicitly refers
<a name="2205"></a>             *   to Z ("Bob, give me your book" implies "bob's book").  The
<a name="2206"></a>             *   rewrite will change that, though - assuming that Z is a
<a name="2207"></a>             *   second-person actor, "you" will by default refer to Z in
<a name="2208"></a>             *   the rewrite.  In order to preserve the original meaning,
<a name="2209"></a>             *   we have to override "you" in the rewrite so that it
<a name="2210"></a>             *   continues to refer to "X", which we can do using a pronoun
<a name="2211"></a>             *   override in the new action.
<a name="2212"></a>             */
<a name="2213"></a>            newAction.setPronounOverride(PronounYou, targetActor);
<a name="2214"></a>
<a name="2215"></a>            /*
<a name="2216"></a>             *   The direct object - the person we're asking - is the
<a name="2217"></a>             *   original target actor ("bob" in "bob, give me x").  Since
<a name="2218"></a>             *   this is a specific object, we need to wrap it in a
<a name="2219"></a>             *   PreResolvedProd.
<a name="2220"></a>             */
<a name="2221"></a>            local dobj = new PreResolvedProd(targetActor);
<a name="2222"></a>
<a name="2223"></a>            /*
<a name="2224"></a>             *   The thing we're asking for is the original direct object.
<a name="2225"></a>             *   ASK FOR takes a topic phrase for its indirect object,
<a name="2226"></a>             *   whereas GIVE TO takes a regular noun phrase.  The two
<a name="2227"></a>             *   aren't quite identical syntactically, so we'll do better
<a name="2228"></a>             *   if we re-parse the original dobj noun phrase as a topic
<a name="2229"></a>             *   phrase.  Fortunately, this is easy...
<a name="2230"></a>             */
<a name="2231"></a>            local iobj = newAction.reparseMatchAsTopic(
<a name="2232"></a>                action.dobjMatch, issuingActor, issuingActor);
<a name="2233"></a>
<a name="2234"></a>            /* set the object match trees */
<a name="2235"></a>            newAction.setObjectMatches(dobj, iobj);
<a name="2236"></a>
<a name="2237"></a>            /*
<a name="2238"></a>             *   Return the new command, addressing the *issuing* actor
<a name="2239"></a>             *   this time around.
<a name="2240"></a>             */
<a name="2241"></a>            return [issuingActor, newAction];
<a name="2242"></a>        }
<a name="2243"></a>
<a name="2244"></a>        /* it's not ours */
<a name="2245"></a>        return nil;
<a name="2246"></a>    }
<a name="2247"></a>;
<a name="2248"></a>
<a name="2249"></a>
<a name="2250"></a>DefineTIAction(ShowTo)
<a name="2251"></a>    getDefaultIobj(np, resolver)
<a name="2252"></a>    {
<a name="2253"></a>        /* check the actor for a current interlocutor */
<a name="2254"></a>        local obj = resolver.getTargetActor().getCurrentInterlocutor();
<a name="2255"></a>        if (obj != nil)
<a name="2256"></a>            return [new ResolveInfo(obj, 0, np)];
<a name="2257"></a>        else
<a name="2258"></a>            return inherited(np, resolver);
<a name="2259"></a>    }
<a name="2260"></a>;
<a name="2261"></a>
<a name="2262"></a>DefineTAction(Follow)
<a name="2263"></a>    /*
<a name="2264"></a>     *   For resolving our direct object, we want to include in the scope
<a name="2265"></a>     *   any item that isn't present but which the actor saw departing the
<a name="2266"></a>     *   present location.
<a name="2267"></a>     */
<a name="2268"></a>    initResolver(issuingActor, targetActor)
<a name="2269"></a>    {
<a name="2270"></a>        /* inherit the base resolver initialization */
<a name="2271"></a>        inherited(issuingActor, targetActor);
<a name="2272"></a>
<a name="2273"></a>        /*
<a name="2274"></a>         *   add to the scope all of the actor's followable objects -
<a name="2275"></a>         *   these are the objects which the actor has witnessed leaving
<a name="2276"></a>         *   the actor's present location
<a name="2277"></a>         */
<a name="2278"></a>        scope_ = scope_.appendUnique(targetActor.getFollowables());
<a name="2279"></a>    }
<a name="2280"></a>;
<a name="2281"></a>
<a name="2282"></a>DefineTAction(Attack)
<a name="2283"></a>;
<a name="2284"></a>
<a name="2285"></a>DefineTIAction(AttackWith)
<a name="2286"></a>    /*
<a name="2287"></a>     *   for the indirect object, limit 'all' and defaults to the items in
<a name="2288"></a>     *   inventory
<a name="2289"></a>     */
<a name="2290"></a>    getAllIobj(actor, scopeList)
<a name="2291"></a>    {
<a name="2292"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2293"></a>    }
<a name="2294"></a>;
<a name="2295"></a>
<a name="2296"></a>DefineTAction(Throw)
<a name="2297"></a>;
<a name="2298"></a>
<a name="2299"></a>DefineTAction(ThrowDir)
<a name="2300"></a>    /* get the direction of the throwing (as a Direction object) */
<a name="2301"></a>    getDirection() { return dirMatch.dir; }
<a name="2302"></a>;
<a name="2303"></a>
<a name="2304"></a>DefineTIAction(ThrowAt)
<a name="2305"></a>;
<a name="2306"></a>
<a name="2307"></a>DefineTIAction(ThrowTo)
<a name="2308"></a>;
<a name="2309"></a>
<a name="2310"></a>DefineTAction(Dig)
<a name="2311"></a>;
<a name="2312"></a>
<a name="2313"></a>DefineTIAction(DigWith)
<a name="2314"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2315"></a>    getAllIobj(actor, scopeList)
<a name="2316"></a>    {
<a name="2317"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2318"></a>    }
<a name="2319"></a>;
<a name="2320"></a>
<a name="2321"></a>DefineIAction(Jump)
<a name="2322"></a>    preCond = [actorStanding]
<a name="2323"></a>    execAction()
<a name="2324"></a>    {
<a name="2325"></a>        /* show the default report for jumping in place */
<a name="2326"></a>        mainReport(&amp;okayJumpMsg);
<a name="2327"></a>    }
<a name="2328"></a>;
<a name="2329"></a>
<a name="2330"></a>DefineTAction(JumpOver)
<a name="2331"></a>;
<a name="2332"></a>
<a name="2333"></a>DefineTAction(JumpOff)
<a name="2334"></a>;
<a name="2335"></a>
<a name="2336"></a>DefineIAction(JumpOffI)
<a name="2337"></a>    execAction()
<a name="2338"></a>    {
<a name="2339"></a>        mainReport(&amp;cannotJumpOffHereMsg);
<a name="2340"></a>    }
<a name="2341"></a>;
<a name="2342"></a>
<a name="2343"></a>DefineTAction(Push)
<a name="2344"></a>;
<a name="2345"></a>
<a name="2346"></a>DefineTAction(Pull)
<a name="2347"></a>;
<a name="2348"></a>
<a name="2349"></a>DefineTAction(Move)
<a name="2350"></a>;
<a name="2351"></a>
<a name="2352"></a>DefineTIAction(MoveWith)
<a name="2353"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2354"></a>    getAllIobj(actor, scopeList)
<a name="2355"></a>    {
<a name="2356"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2357"></a>    }
<a name="2358"></a>;
<a name="2359"></a>
<a name="2360"></a>DefineTIAction(MoveTo)
<a name="2361"></a>;
<a name="2362"></a>
<a name="2363"></a>DefineTAction(Turn)
<a name="2364"></a>;
<a name="2365"></a>
<a name="2366"></a>DefineTIAction(TurnWith)
<a name="2367"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2368"></a>    getAllIobj(actor, scopeList)
<a name="2369"></a>    {
<a name="2370"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2371"></a>    }
<a name="2372"></a>;
<a name="2373"></a>
<a name="2374"></a>DefineLiteralTAction(TurnTo, IndirectObject)
<a name="2375"></a>;
<a name="2376"></a>
<a name="2377"></a>DefineTAction(Set)
<a name="2378"></a>;
<a name="2379"></a>
<a name="2380"></a>DefineLiteralTAction(SetTo, IndirectObject)
<a name="2381"></a>;
<a name="2382"></a>
<a name="2383"></a>DefineTAction(TypeOn)
<a name="2384"></a>;
<a name="2385"></a>
<a name="2386"></a>DefineLiteralTAction(TypeLiteralOn, DirectObject)
<a name="2387"></a>;
<a name="2388"></a>
<a name="2389"></a>DefineLiteralTAction(EnterOn, DirectObject)
<a name="2390"></a>;
<a name="2391"></a>
<a name="2392"></a>DefineTAction(Consult)
<a name="2393"></a>;
<a name="2394"></a>
<a name="2395"></a>DefineTopicTAction(ConsultAbout, IndirectObject)
<a name="2396"></a>    getDefaultDobj(np, resolver)
<a name="2397"></a>    {
<a name="2398"></a>        /*
<a name="2399"></a>         *   if the actor has consulted something before, and that object
<a name="2400"></a>         *   is still visible, use it as the default for this consultation
<a name="2401"></a>         */
<a name="2402"></a>        local actor = resolver.getTargetActor();
<a name="2403"></a>        local obj = actor.lastConsulted;
<a name="2404"></a>        if (obj != nil &amp;&amp; actor.canSee(obj))
<a name="2405"></a>            return [new ResolveInfo(obj, DefaultObject, np)];
<a name="2406"></a>        else
<a name="2407"></a>            return inherited(np, resolver);
<a name="2408"></a>    }
<a name="2409"></a>
<a name="2410"></a>    /*
<a name="2411"></a>     *   Filter the topic phrase resolution.  If we know our direct object,
<a name="2412"></a>     *   and it's a Consultable, refer the resolution to the Consultable.
<a name="2413"></a>     */
<a name="2414"></a>    filterTopic(lst, np, resolver)
<a name="2415"></a>    {
<a name="2416"></a>        local dobj;
<a name="2417"></a>
<a name="2418"></a>        /* check the direct object */
<a name="2419"></a>        if (dobjList_ != nil
<a name="2420"></a>            &amp;&amp; dobjList_.length() == 1
<a name="2421"></a>            &amp;&amp; (dobj = dobjList_[1].obj_).ofKind(Consultable))
<a name="2422"></a>        {
<a name="2423"></a>            /*
<a name="2424"></a>             *   we have a Consultable direct object - let it handle the
<a name="2425"></a>             *   topic phrase resolution
<a name="2426"></a>             */
<a name="2427"></a>            return dobj.resolveConsultTopic(lst, topicMatch, resolver);
<a name="2428"></a>        }
<a name="2429"></a>        else
<a name="2430"></a>        {
<a name="2431"></a>            /* otherwise, use the default handling */
<a name="2432"></a>            return inherited(lst, np, resolver);
<a name="2433"></a>        }
<a name="2434"></a>    }
<a name="2435"></a>;
<a name="2436"></a>
<a name="2437"></a>DefineTAction(Switch)
<a name="2438"></a>;
<a name="2439"></a>
<a name="2440"></a>DefineTAction(Flip)
<a name="2441"></a>;
<a name="2442"></a>
<a name="2443"></a>DefineTAction(TurnOn)
<a name="2444"></a>;
<a name="2445"></a>
<a name="2446"></a>DefineTAction(TurnOff)
<a name="2447"></a>;
<a name="2448"></a>
<a name="2449"></a>DefineTAction(Light)
<a name="2450"></a>;
<a name="2451"></a>
<a name="2452"></a>DefineTAction(Burn)
<a name="2453"></a>;
<a name="2454"></a>
<a name="2455"></a>DefineTIAction(BurnWith)
<a name="2456"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2457"></a>    getAllIobj(actor, scopeList)
<a name="2458"></a>    {
<a name="2459"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2460"></a>    }
<a name="2461"></a>
<a name="2462"></a>    /* resolve the direct object first */
<a name="2463"></a>    resolveFirst = DirectObject
<a name="2464"></a>;
<a name="2465"></a>
<a name="2466"></a>DefineTAction(Extinguish)
<a name="2467"></a>;
<a name="2468"></a>
<a name="2469"></a>DefineTIAction(AttachTo)
<a name="2470"></a>;
<a name="2471"></a>
<a name="2472"></a>DefineTIAction(DetachFrom)
<a name="2473"></a>;
<a name="2474"></a>
<a name="2475"></a>DefineTAction(Detach)
<a name="2476"></a>;
<a name="2477"></a>
<a name="2478"></a>DefineTAction(Break)
<a name="2479"></a>;
<a name="2480"></a>
<a name="2481"></a>DefineTAction(Cut)
<a name="2482"></a>;
<a name="2483"></a>
<a name="2484"></a>DefineTIAction(CutWith)
<a name="2485"></a>;
<a name="2486"></a>
<a name="2487"></a>DefineTAction(Climb)
<a name="2488"></a>;
<a name="2489"></a>
<a name="2490"></a>DefineTAction(ClimbUp)
<a name="2491"></a>;
<a name="2492"></a>
<a name="2493"></a>DefineTAction(ClimbDown)
<a name="2494"></a>;
<a name="2495"></a>
<a name="2496"></a>DefineTAction(Open)
<a name="2497"></a>;
<a name="2498"></a>
<a name="2499"></a>DefineTAction(Close)
<a name="2500"></a>;
<a name="2501"></a>
<a name="2502"></a>DefineTAction(Lock)
<a name="2503"></a>;
<a name="2504"></a>
<a name="2505"></a>DefineTAction(Unlock)
<a name="2506"></a>;
<a name="2507"></a>
<a name="2508"></a>DefineTIAction(LockWith)
<a name="2509"></a>    /*
<a name="2510"></a>     *   Resolve the direct object (the lock) first, so that we know what
<a name="2511"></a>     *   we're trying to unlock when we're verifying the key.  This allows
<a name="2512"></a>     *   us to (optionally) boost the likelihood of a known good key for
<a name="2513"></a>     *   disambiguation.
<a name="2514"></a>     */
<a name="2515"></a>    resolveFirst = DirectObject
<a name="2516"></a>
<a name="2517"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2518"></a>    getAllIobj(actor, scopeList)
<a name="2519"></a>    {
<a name="2520"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2521"></a>    }
<a name="2522"></a>;
<a name="2523"></a>
<a name="2524"></a>DefineTIAction(UnlockWith)
<a name="2525"></a>    /* resolve the direct object first, for the same reason as in LockWith */
<a name="2526"></a>    resolveFirst = DirectObject
<a name="2527"></a>
<a name="2528"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2529"></a>    getAllIobj(actor, scopeList)
<a name="2530"></a>    {
<a name="2531"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2532"></a>    }
<a name="2533"></a>;
<a name="2534"></a>
<a name="2535"></a>DefineTAction(Eat)
<a name="2536"></a>;
<a name="2537"></a>
<a name="2538"></a>DefineTAction(Drink)
<a name="2539"></a>;
<a name="2540"></a>
<a name="2541"></a>DefineTAction(Pour)
<a name="2542"></a>;
<a name="2543"></a>
<a name="2544"></a>DefineTIAction(PourInto)
<a name="2545"></a>;
<a name="2546"></a>
<a name="2547"></a>DefineTIAction(PourOnto)
<a name="2548"></a>;
<a name="2549"></a>
<a name="2550"></a>DefineTAction(Clean)
<a name="2551"></a>;
<a name="2552"></a>
<a name="2553"></a>DefineTIAction(CleanWith)
<a name="2554"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2555"></a>    getAllIobj(actor, scopeList)
<a name="2556"></a>    {
<a name="2557"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2558"></a>    }
<a name="2559"></a>;
<a name="2560"></a>
<a name="2561"></a>DefineIAction(Sit)
<a name="2562"></a>    execAction()
<a name="2563"></a>    {
<a name="2564"></a>        /*
<a name="2565"></a>         *   if the actor is already sitting, just say so; otherwise, ask
<a name="2566"></a>         *   what they want to sit on
<a name="2567"></a>         */
<a name="2568"></a>        if (gActor.posture == sitting)
<a name="2569"></a>            reportFailure(&amp;alreadySittingMsg);
<a name="2570"></a>        else
<a name="2571"></a>            askForDobj(SitOn);
<a name="2572"></a>    }
<a name="2573"></a>;
<a name="2574"></a>
<a name="2575"></a>DefineTAction(SitOn)
<a name="2576"></a>;
<a name="2577"></a>
<a name="2578"></a>DefineIAction(Lie)
<a name="2579"></a>    execAction()
<a name="2580"></a>    {
<a name="2581"></a>        /*
<a name="2582"></a>         *   if the actor is already lying down, just say so; otherwise,
<a name="2583"></a>         *   ask what they want to lie on
<a name="2584"></a>         */
<a name="2585"></a>        if (gActor.posture == lying)
<a name="2586"></a>            reportFailure(&amp;alreadyLyingMsg);
<a name="2587"></a>        else
<a name="2588"></a>            askForDobj(LieOn);
<a name="2589"></a>    }
<a name="2590"></a>;
<a name="2591"></a>
<a name="2592"></a>DefineTAction(LieOn)
<a name="2593"></a>;
<a name="2594"></a>
<a name="2595"></a>DefineTAction(StandOn)
<a name="2596"></a>;
<a name="2597"></a>
<a name="2598"></a>DefineIAction(Stand)
<a name="2599"></a>    execAction()
<a name="2600"></a>    {
<a name="2601"></a>        /* let the actor handle it */
<a name="2602"></a>        gActor.standUp();
<a name="2603"></a>    }
<a name="2604"></a>;
<a name="2605"></a>
<a name="2606"></a>DefineTAction(Board)
<a name="2607"></a>;
<a name="2608"></a>
<a name="2609"></a>DefineTAction(GetOutOf)
<a name="2610"></a>    getAllDobj(actor, scopeList)
<a name="2611"></a>    {
<a name="2612"></a>        /* 'all' for 'get out of' is the actor's immediate container */
<a name="2613"></a>        return scopeList.subset({x: actor.isDirectlyIn(x)});
<a name="2614"></a>    }
<a name="2615"></a>;
<a name="2616"></a>
<a name="2617"></a>DefineTAction(GetOffOf)
<a name="2618"></a>    getAllDobj(actor, scopeList)
<a name="2619"></a>    {
<a name="2620"></a>        /* 'all' for 'get off of' is the actor's immediate container */
<a name="2621"></a>        return scopeList.subset({x: actor.isDirectlyIn(x)});
<a name="2622"></a>    }
<a name="2623"></a>;
<a name="2624"></a>
<a name="2625"></a>DefineIAction(GetOut)
<a name="2626"></a>    execAction()
<a name="2627"></a>    {
<a name="2628"></a>        /* let the actor handle it */
<a name="2629"></a>        gActor.disembark();
<a name="2630"></a>    }
<a name="2631"></a>;
<a name="2632"></a>
<a name="2633"></a>DefineTAction(Fasten)
<a name="2634"></a>;
<a name="2635"></a>
<a name="2636"></a>DefineTIAction(FastenTo)
<a name="2637"></a>;
<a name="2638"></a>
<a name="2639"></a>DefineTAction(Unfasten)
<a name="2640"></a>;
<a name="2641"></a>
<a name="2642"></a>DefineTIAction(UnfastenFrom)
<a name="2643"></a>;
<a name="2644"></a>
<a name="2645"></a>DefineTAction(PlugIn)
<a name="2646"></a>;
<a name="2647"></a>
<a name="2648"></a>DefineTIAction(PlugInto)
<a name="2649"></a>;
<a name="2650"></a>
<a name="2651"></a>DefineTAction(Unplug)
<a name="2652"></a>;
<a name="2653"></a>
<a name="2654"></a>DefineTIAction(UnplugFrom)
<a name="2655"></a>;
<a name="2656"></a>
<a name="2657"></a>DefineTAction(Screw)
<a name="2658"></a>;
<a name="2659"></a>
<a name="2660"></a>DefineTIAction(ScrewWith)
<a name="2661"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2662"></a>    getAllIobj(actor, scopeList)
<a name="2663"></a>    {
<a name="2664"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2665"></a>    }
<a name="2666"></a>;
<a name="2667"></a>
<a name="2668"></a>DefineTAction(Unscrew)
<a name="2669"></a>;
<a name="2670"></a>
<a name="2671"></a>DefineTIAction(UnscrewWith)
<a name="2672"></a>    /* limit 'all' for the indirect object to items in inventory */
<a name="2673"></a>    getAllIobj(actor, scopeList)
<a name="2674"></a>    {
<a name="2675"></a>        return scopeList.subset({x: x.isIn(actor)});
<a name="2676"></a>    }
<a name="2677"></a>;
<a name="2678"></a>
<a name="2679"></a>/* ------------------------------------------------------------------------ */
<a name="2680"></a>/*
<a name="2681"></a> *   Travel Action - this is the base class for verbs that attempt to move
<a name="2682"></a> *   an actor to a new location via one of the directional connections
<a name="2683"></a> *   from the current location.
<a name="2684"></a> *
<a name="2685"></a> *   Each grammar rule for this action must set the 'dirMatch' property to
<a name="2686"></a> *   a DirectionProd match object that gives the direction.
<a name="2687"></a> */
<a name="2688"></a>DefineIAction(Travel)
<a name="2689"></a>    execAction()
<a name="2690"></a>    {
<a name="2691"></a>        local conn;
<a name="2692"></a>
<a name="2693"></a>        /*
<a name="2694"></a>         *   Perform the travel via the connector, if we have one.  If
<a name="2695"></a>         *   there's no connector defined for this direction, show a
<a name="2696"></a>         *   default "you can't go that way" message.
<a name="2697"></a>         */
<a name="2698"></a>        if ((conn = getConnector()) != nil)
<a name="2699"></a>        {
<a name="2700"></a>            /*
<a name="2701"></a>             *   we have a connector - use the pseudo-action TravelVia with
<a name="2702"></a>             *   the connector to carry out the travel
<a name="2703"></a>             */
<a name="2704"></a>            replaceAction(TravelVia, conn);
<a name="2705"></a>        }
<a name="2706"></a>        else
<a name="2707"></a>        {
<a name="2708"></a>            /* no connector - show a default "can't go that way" error */
<a name="2709"></a>            mainReport(&amp;cannotGoThatWayMsg);
<a name="2710"></a>        }
<a name="2711"></a>    }
<a name="2712"></a>
<a name="2713"></a>    /* get the direction object for the travel */
<a name="2714"></a>    getDirection() { return dirMatch != nil ? dirMatch.dir : nil; }
<a name="2715"></a>
<a name="2716"></a>    /*
<a name="2717"></a>     *   Get my travel connector.  My connector is given by the travel
<a name="2718"></a>     *   link property for this action as defined in the actor's current
<a name="2719"></a>     *   location.
<a name="2720"></a>     */
<a name="2721"></a>    getConnector()
<a name="2722"></a>    {
<a name="2723"></a>        /* ask the location for the connector in my direction */
<a name="2724"></a>        return gActor.location == nil
<a name="2725"></a>            ? nil
<a name="2726"></a>            : gActor.location.getTravelConnector(getDirection(), gActor);
<a name="2727"></a>    }
<a name="2728"></a>
<a name="2729"></a>    /*
<a name="2730"></a>     *   The grammar rules for the individual directions will usually just
<a name="2731"></a>     *   create a base TravelAction object, rather than one of the
<a name="2732"></a>     *   direction-specific subclasses (NorthAction, etc).  For
<a name="2733"></a>     *   convenience in testing the action, though, treat ourself as
<a name="2734"></a>     *   matching the subclass with the same direction.
<a name="2735"></a>     */
<a name="2736"></a>    actionOfKind(cls)
<a name="2737"></a>    {
<a name="2738"></a>        /*
<a name="2739"></a>         *   If they're asking about a specific-direction TravelAction
<a name="2740"></a>         *   subclass, then we match it if our own direction matches that
<a name="2741"></a>         *   of the given subclass, and we fail to match if our direction
<a name="2742"></a>         *   doesn't match the given direction.
<a name="2743"></a>         */
<a name="2744"></a>        if (cls.ofKind(TravelAction) &amp;&amp; cls.getDirection() != nil)
<a name="2745"></a>        {
<a name="2746"></a>            /* we match if and only if the direction matches */
<a name="2747"></a>            return (getDirection() == cls.getDirection());
<a name="2748"></a>        }
<a name="2749"></a>
<a name="2750"></a>        /* otherwise, inherit the default handling */
<a name="2751"></a>        return inherited(cls);
<a name="2752"></a>    }
<a name="2753"></a>;
<a name="2754"></a>
<a name="2755"></a>/* for a vague command such as GO, which doesn't say where to go */
<a name="2756"></a>DefineIAction(VagueTravel)
<a name="2757"></a>    execAction()
<a name="2758"></a>    {
<a name="2759"></a>        /* simply ask for a direction */
<a name="2760"></a>        reportFailure(&amp;whereToGoMsg);
<a name="2761"></a>    }
<a name="2762"></a>;
<a name="2763"></a>
<a name="2764"></a>/*
<a name="2765"></a> *   This class makes it convenient to synthesize a TravelAction given a
<a name="2766"></a> *   Direction object.  To create a travel action for a direction, use
<a name="2767"></a> *
<a name="2768"></a> *.     new TravelDirAction(direction)
<a name="2769"></a> *
<a name="2770"></a> *   where 'direction' is the direction object (northDirection, etc) for
<a name="2771"></a> *   the desired direction of travel.  Note that if you want to use the
<a name="2772"></a> *   resulting object in replaceAction() or one of the similar macros,
<a name="2773"></a> *   you'll need to go directly to the underlying function rather than
<a name="2774"></a> *   using the standard macro, since the macros expect a literal action
<a name="2775"></a> *   name rather than an object.  For example:
<a name="2776"></a> *
<a name="2777"></a> *.     _replaceAction(gActor, new TravelDirAction(getDirection));
<a name="2778"></a> */
<a name="2779"></a>DefineAction(TravelDir, TravelAction)
<a name="2780"></a>    construct(dir)
<a name="2781"></a>    {
<a name="2782"></a>        /* remember my direction */
<a name="2783"></a>        dir_ = dir;
<a name="2784"></a>    }
<a name="2785"></a>
<a name="2786"></a>    /* get my direction */
<a name="2787"></a>    getDirection() { return dir_; }
<a name="2788"></a>
<a name="2789"></a>    /* my direction, normally specified during construction */
<a name="2790"></a>    dir_ = nil
<a name="2791"></a>;
<a name="2792"></a>
<a name="2793"></a>/*
<a name="2794"></a> *   To make it more convenient to use directional travel actions as
<a name="2795"></a> *   synthesized commands, define a set of action classes for the specific
<a name="2796"></a> *   directions.
<a name="2797"></a> */
<a name="2798"></a>DefineAction(North, TravelAction)
<a name="2799"></a>    getDirection = northDirection
<a name="2800"></a>;
<a name="2801"></a>DefineAction(South, TravelAction)
<a name="2802"></a>    getDirection = southDirection
<a name="2803"></a>;
<a name="2804"></a>DefineAction(East, TravelAction)
<a name="2805"></a>    getDirection = eastDirection
<a name="2806"></a>;
<a name="2807"></a>DefineAction(West, TravelAction)
<a name="2808"></a>    getDirection = westDirection
<a name="2809"></a>;
<a name="2810"></a>DefineAction(Northeast, TravelAction)
<a name="2811"></a>    getDirection = northeastDirection
<a name="2812"></a>;
<a name="2813"></a>DefineAction(Northwest, TravelAction)
<a name="2814"></a>    getDirection = northwestDirection
<a name="2815"></a>;
<a name="2816"></a>DefineAction(Southeast, TravelAction)
<a name="2817"></a>    getDirection = southeastDirection
<a name="2818"></a>;
<a name="2819"></a>DefineAction(Southwest, TravelAction)
<a name="2820"></a>    getDirection = southwestDirection
<a name="2821"></a>;
<a name="2822"></a>DefineAction(In, TravelAction)
<a name="2823"></a>    getDirection = inDirection
<a name="2824"></a>;
<a name="2825"></a>DefineAction(Out, TravelAction)
<a name="2826"></a>    getDirection = outDirection
<a name="2827"></a>;
<a name="2828"></a>DefineAction(Up, TravelAction)
<a name="2829"></a>    getDirection = upDirection
<a name="2830"></a>;
<a name="2831"></a>DefineAction(Down, TravelAction)
<a name="2832"></a>    getDirection = downDirection
<a name="2833"></a>;
<a name="2834"></a>DefineAction(Fore, TravelAction)
<a name="2835"></a>    getDirection = foreDirection
<a name="2836"></a>;
<a name="2837"></a>DefineAction(Aft, TravelAction)
<a name="2838"></a>    getDirection = aftDirection
<a name="2839"></a>;
<a name="2840"></a>DefineAction(Port, TravelAction)
<a name="2841"></a>    getDirection = portDirection
<a name="2842"></a>;
<a name="2843"></a>DefineAction(Starboard, TravelAction)
<a name="2844"></a>    getDirection = starboardDirection
<a name="2845"></a>;
<a name="2846"></a>
<a name="2847"></a>/*
<a name="2848"></a> *   Non-directional travel actions
<a name="2849"></a> */
<a name="2850"></a>
<a name="2851"></a>DefineTAction(GoThrough)
<a name="2852"></a>;
<a name="2853"></a>
<a name="2854"></a>DefineTAction(Enter)
<a name="2855"></a>;
<a name="2856"></a>
<a name="2857"></a>/*
<a name="2858"></a> *   An internal action for traveling via a connector.  This isn't a real
<a name="2859"></a> *   action, and shouldn't have a grammar defined for it.  The purpose of
<a name="2860"></a> *   this action is to allow real actions that cause travel via a
<a name="2861"></a> *   connector to be implemented by mapping to this internal action, which
<a name="2862"></a> *   we implement on the base travel connector class.
<a name="2863"></a> */
<a name="2864"></a>DefineTAction(TravelVia)
<a name="2865"></a>    /*
<a name="2866"></a>     *   The direct object of this synthetic action isn't necessarily an
<a name="2867"></a>     *   ordinary simulation object: it could be a TravelConnector instead.
<a name="2868"></a>     *   Since callers asking for a direct object almost always expect a
<a name="2869"></a>     *   simulation object, returning a non-simulation object here can be
<a name="2870"></a>     *   problematic.  To avoid this, we return an empty object list by
<a name="2871"></a>     *   default - this ensures that no one who asks for the direct object
<a name="2872"></a>     *   of the verb will get back a non-simulation travel connector.
<a name="2873"></a>     */
<a name="2874"></a>    getCurrentObjects = []
<a name="2875"></a>;
<a name="2876"></a>
<a name="2877"></a>/* "go back" */
<a name="2878"></a>DefineIAction(GoBack)
<a name="2879"></a>    execAction()
<a name="2880"></a>    {
<a name="2881"></a>        /* ask the actor to handle it */
<a name="2882"></a>        gActor.reverseLastTravel();
<a name="2883"></a>    }
<a name="2884"></a>;
<a name="2885"></a>
<a name="2886"></a>/* ------------------------------------------------------------------------ */
<a name="2887"></a>/*
<a name="2888"></a> *   Combined pushing-and-traveling action ("push crate north", "drag sled
<a name="2889"></a> *   into cave").  All of these are based on a base action class, which
<a name="2890"></a> *   defines the methods invoked on the object being pushed; the
<a name="2891"></a> *   subclasses provide a definition of the connector that determines
<a name="2892"></a> *   where the travel takes us.
<a name="2893"></a> */
<a name="2894"></a>DefineTAction(PushTravel)
<a name="2895"></a>    /*
<a name="2896"></a>     *   Carry out the nested travel action for the special combination
<a name="2897"></a>     *   push-traveler.  This should carry out the same action we would
<a name="2898"></a>     *   have performed for the underlying basic travel.
<a name="2899"></a>     *
<a name="2900"></a>     *   This method is invoked by the TravelPushable to carry out a
<a name="2901"></a>     *   push-travel action.  The TravelPushable object will first set up
<a name="2902"></a>     *   a PushTraveler as the actor's global traveler, and it will then
<a name="2903"></a>     *   invoke this method to carry out the actual travel with that
<a name="2904"></a>     *   special traveler in effect.  Our job is to provide the mapping to
<a name="2905"></a>     *   the correct underlying simple travel action; since we'll be
<a name="2906"></a>     *   moving the PushTraveler object, we can move it using the ordinary
<a name="2907"></a>     *   non-push travel action as though it were any other traveler.
<a name="2908"></a>     *
<a name="2909"></a>     *   This method is abstract - each subclass must define it
<a name="2910"></a>     *   appropriately.
<a name="2911"></a>     */
<a name="2912"></a>    // performTravel() { }
<a name="2913"></a>;
<a name="2914"></a>
<a name="2915"></a>/*
<a name="2916"></a> *   For directional push-and-travel commands, we define a common base
<a name="2917"></a> *   class that does the work to find the connector based on the room's
<a name="2918"></a> *   directional connector.
<a name="2919"></a> *
<a name="2920"></a> *   Subclasses for grammar rules must define the 'dirMatch' property to
<a name="2921"></a> *   be a DirectionProd object for the associated direction.
<a name="2922"></a> */
<a name="2923"></a>DefineAction(PushTravelDir, PushTravelAction)
<a name="2924"></a>    /*
<a name="2925"></a>     *   Get the direction we're going.  By default, we return the
<a name="2926"></a>     *   direction associated with the dirMatch match object from our
<a name="2927"></a>     *   grammar match.
<a name="2928"></a>     */
<a name="2929"></a>    getDirection() { return dirMatch.dir; }
<a name="2930"></a>
<a name="2931"></a>    /* carry out the nested travel action for a PushTravel */
<a name="2932"></a>    performTravel()
<a name="2933"></a>    {
<a name="2934"></a>        local conn;
<a name="2935"></a>
<a name="2936"></a>        /* ask the actor's location for the connector in our direction */
<a name="2937"></a>        conn = gActor.location.getTravelConnector(getDirection(), gActor);
<a name="2938"></a>
<a name="2939"></a>        /* perform a nested TravelVia on the connector */
<a name="2940"></a>        nestedAction(TravelVia, conn);
<a name="2941"></a>    }
<a name="2942"></a>;
<a name="2943"></a>
<a name="2944"></a>/*
<a name="2945"></a> *   To make it easy to synthesize actions for pushing objects, define
<a name="2946"></a> *   individual subclasses for the various directions.
<a name="2947"></a> */
<a name="2948"></a>DefineAction(PushNorth, PushTravelDirAction)
<a name="2949"></a>    getDirection = northDirection
<a name="2950"></a>;
<a name="2951"></a>
<a name="2952"></a>DefineAction(PushSouth, PushTravelDirAction)
<a name="2953"></a>    getDirection = southDirection
<a name="2954"></a>;
<a name="2955"></a>
<a name="2956"></a>DefineAction(PushEast, PushTravelDirAction)
<a name="2957"></a>    getDirection = eastDirection
<a name="2958"></a>;
<a name="2959"></a>
<a name="2960"></a>DefineAction(PushWest, PushTravelDirAction)
<a name="2961"></a>    getDirection = westDirection
<a name="2962"></a>;
<a name="2963"></a>
<a name="2964"></a>DefineAction(PushNorthwest, PushTravelDirAction)
<a name="2965"></a>    getDirection = northwestDirection
<a name="2966"></a>;
<a name="2967"></a>
<a name="2968"></a>DefineAction(PushNortheast, PushTravelDirAction)
<a name="2969"></a>    getDirection = northeastDirection
<a name="2970"></a>;
<a name="2971"></a>
<a name="2972"></a>DefineAction(PushSouthwest, PushTravelDirAction)
<a name="2973"></a>    getDirection = southwestDirection
<a name="2974"></a>;
<a name="2975"></a>
<a name="2976"></a>DefineAction(PushSoutheast, PushTravelDirAction)
<a name="2977"></a>    getDirection = southeastDirection
<a name="2978"></a>;
<a name="2979"></a>
<a name="2980"></a>DefineAction(PushUp, PushTravelDirAction)
<a name="2981"></a>    getDirection = upDirection
<a name="2982"></a>;
<a name="2983"></a>
<a name="2984"></a>DefineAction(PushDown, PushTravelDirAction)
<a name="2985"></a>    getDirection = downDirection
<a name="2986"></a>;
<a name="2987"></a>
<a name="2988"></a>DefineAction(PushIn, PushTravelDirAction)
<a name="2989"></a>    getDirection = inDirection
<a name="2990"></a>;
<a name="2991"></a>
<a name="2992"></a>DefineAction(PushOut, PushTravelDirAction)
<a name="2993"></a>    getDirection = outDirection
<a name="2994"></a>;
<a name="2995"></a>
<a name="2996"></a>DefineAction(PushFore, PushTravelDirAction)
<a name="2997"></a>    getDirection = foreDirection
<a name="2998"></a>;
<a name="2999"></a>
<a name="3000"></a>DefineAction(PushAft, PushTravelDirAction)
<a name="3001"></a>    getDirection = aftDirection
<a name="3002"></a>;
<a name="3003"></a>
<a name="3004"></a>DefineAction(PushPort, PushTravelDirAction)
<a name="3005"></a>    getDirection = portDirection
<a name="3006"></a>;
<a name="3007"></a>
<a name="3008"></a>DefineAction(PushStarboard, PushTravelDirAction)
<a name="3009"></a>    getDirection = starboardDirection
<a name="3010"></a>;
<a name="3011"></a>
<a name="3012"></a>/*
<a name="3013"></a> *   Base class for two-object push-travel commands, such as "push boulder
<a name="3014"></a> *   out of cave" or "drag sled up hill".  For all of these, the connector
<a name="3015"></a> *   is given by the indirect object.
<a name="3016"></a> */
<a name="3017"></a>DefineAction(PushTravelViaIobj, TIAction, PushTravelAction)
<a name="3018"></a>    /*
<a name="3019"></a>     *   Verify the indirect object of the push-travel action.  We'll
<a name="3020"></a>     *   remap this to given corresponding simple travel action, and call
<a name="3021"></a>     *   that action's verifier.
<a name="3022"></a>     */
<a name="3023"></a>    verifyPushTravelIobj(obj, action)
<a name="3024"></a>    {
<a name="3025"></a>        /* handle this by remapping it to the underlying simple action */
<a name="3026"></a>        remapVerify(IndirectObject, gVerifyResults, [action, obj]);
<a name="3027"></a>    }
<a name="3028"></a>;
<a name="3029"></a>
<a name="3030"></a>DefineTIActionSub(PushTravelThrough, PushTravelViaIobjAction)
<a name="3031"></a>    /*
<a name="3032"></a>     *   Carry out the underlying simple travel action.  This simply
<a name="3033"></a>     *   performs a GoThrough on my indirect object, as though we had
<a name="3034"></a>     *   typed simply GO THROUGH iobj.  The PushTraveler will already be
<a name="3035"></a>     *   set up as the actor's special traveler, so the ordinary GO
<a name="3036"></a>     *   THROUGH command will move the special PushTraveler object as
<a name="3037"></a>     *   though it were the original actor.
<a name="3038"></a>     */
<a name="3039"></a>    performTravel() { nestedAction(GoThrough, getIobj()); }
<a name="3040"></a>;
<a name="3041"></a>
<a name="3042"></a>DefineTIActionSub(PushTravelEnter, PushTravelViaIobjAction)
<a name="3043"></a>    /* carry out the underlying simple travel as an ENTER action */
<a name="3044"></a>    performTravel() { nestedAction(Enter, getIobj()); }
<a name="3045"></a>;
<a name="3046"></a>
<a name="3047"></a>DefineTIActionSub(PushTravelGetOutOf, PushTravelViaIobjAction)
<a name="3048"></a>    /* carry out the underlying simple travel as a GET OUT OF action */
<a name="3049"></a>    performTravel() { nestedAction(GetOutOf, getIobj()); }
<a name="3050"></a>;
<a name="3051"></a>
<a name="3052"></a>DefineTIActionSub(PushTravelClimbUp, PushTravelViaIobjAction)
<a name="3053"></a>    /* carry out the underlying simple travel as a CLIMB UP action */
<a name="3054"></a>    performTravel() { nestedAction(ClimbUp, getIobj()); }
<a name="3055"></a>;
<a name="3056"></a>
<a name="3057"></a>DefineTIActionSub(PushTravelClimbDown, PushTravelViaIobjAction)
<a name="3058"></a>    /* carry out the underlying simple travel as an CLIMB DOWN action */
<a name="3059"></a>    performTravel() { nestedAction(ClimbDown, getIobj()); }
<a name="3060"></a>;
<a name="3061"></a>
<a name="3062"></a>/*
<a name="3063"></a> *   The "exits" verb.  This verb explicitly shows all of the exits from
<a name="3064"></a> *   the current location.
<a name="3065"></a> */
<a name="3066"></a>DefineIAction(Exits)
<a name="3067"></a>    execAction()
<a name="3068"></a>    {
<a name="3069"></a>        /*
<a name="3070"></a>         *   if we have an exit lister object, invoke it; otherwise,
<a name="3071"></a>         *   explain that this command isn't supported in this game
<a name="3072"></a>         */
<a name="3073"></a>        if (gExitLister != nil)
<a name="3074"></a>            gExitLister.showExitsCommand();
<a name="3075"></a>        else
<a name="3076"></a>            gLibMessages.commandNotPresent;
<a name="3077"></a>    }
<a name="3078"></a>;
<a name="3079"></a>
<a name="3080"></a>/* in case the exits module isn't included */
<a name="3081"></a>property showExitsCommand, exitsOnOffCommand;
<a name="3082"></a>
<a name="3083"></a>/*
<a name="3084"></a> *   Change the exit display mode.  The grammar must set one of the mode
<a name="3085"></a> *   token properties to a non-nil value, according to which mode the
<a name="3086"></a> *   player selected: on_ for turning on statusline and description lists;
<a name="3087"></a> *   stat_ for turning on only the statusline list; look_ for turning on
<a name="3088"></a> *   only the room description list; and off_ for turning off everything.
<a name="3089"></a> */
<a name="3090"></a>DefineSystemAction(ExitsMode)
<a name="3091"></a>    execSystemAction()
<a name="3092"></a>    {
<a name="3093"></a>        local stat, look;
<a name="3094"></a>
<a name="3095"></a>        /*
<a name="3096"></a>         *   If it's EXITS ON, turn on both statusline and room description
<a name="3097"></a>         *   lists.  If it's EXITS LOOK or EXITS STATUS, just turn on one
<a name="3098"></a>         *   or the other.  Otherwise, turn both off.
<a name="3099"></a>         */
<a name="3100"></a>        stat = (stat_ != nil || on_ != nil);
<a name="3101"></a>        look = (look_ != nil || on_ != nil);
<a name="3102"></a>
<a name="3103"></a>        /* update the exit display */
<a name="3104"></a>        if (gExitLister != nil)
<a name="3105"></a>            gExitLister.exitsOnOffCommand(stat, look);
<a name="3106"></a>        else
<a name="3107"></a>            gLibMessages.commandNotPresent;
<a name="3108"></a>    }
<a name="3109"></a>;
<a name="3110"></a>
<a name="3111"></a>/*
<a name="3112"></a> *   Dummy OOPS action for times when OOPS isn't in context.  We'll simply
<a name="3113"></a> *   explain how OOPS works, and that you can't use it right now.
<a name="3114"></a> */
<a name="3115"></a>DefineLiteralAction(Oops)
<a name="3116"></a>    execAction()
<a name="3117"></a>    {
<a name="3118"></a>        /* simply explain how this command works */
<a name="3119"></a>        gLibMessages.oopsOutOfContext;
<a name="3120"></a>    }
<a name="3121"></a>
<a name="3122"></a>    /* this is a meta-command, so don't consume any time */
<a name="3123"></a>    actionTime = 0
<a name="3124"></a>;
<a name="3125"></a>
<a name="3126"></a>/* intransitive form of "oops" */
<a name="3127"></a>DefineIAction(OopsI)
<a name="3128"></a>    doActionMain()
<a name="3129"></a>    {
<a name="3130"></a>        /* as with OOPS with a literal, simply explain the problem */
<a name="3131"></a>        gLibMessages.oopsOutOfContext;
<a name="3132"></a>    }
<a name="3133"></a>
<a name="3134"></a>    /* this is a meta-command, so don't consume any time */
<a name="3135"></a>    actionTime = 0
<a name="3136"></a>;
<a name="3137"></a>
<a name="3138"></a>property disableHints, showHints;
<a name="3139"></a>
<a name="3140"></a>/* hint system - disable hints for this session */
<a name="3141"></a>DefineSystemAction(HintsOff)
<a name="3142"></a>    execSystemAction()
<a name="3143"></a>    {
<a name="3144"></a>        if (gHintManager != nil)
<a name="3145"></a>            gHintManager.disableHints();
<a name="3146"></a>        else
<a name="3147"></a>            mainReport(gLibMessages.hintsNotPresent);
<a name="3148"></a>    }
<a name="3149"></a>;
<a name="3150"></a>
<a name="3151"></a>/* invoke hint system */
<a name="3152"></a>DefineSystemAction(Hint)
<a name="3153"></a>    execSystemAction()
<a name="3154"></a>    {
<a name="3155"></a>        if (gHintManager != nil)
<a name="3156"></a>            gHintManager.showHints();
<a name="3157"></a>        else
<a name="3158"></a>            mainReport(gLibMessages.hintsNotPresent);
<a name="3159"></a>    }
<a name="3160"></a>;
<a name="3161"></a>
<a name="3162"></a>/* ------------------------------------------------------------------------ */
<a name="3163"></a>/*
<a name="3164"></a> *   Parser debugging verbs
<a name="3165"></a> */
<a name="3166"></a>
<a name="3167"></a>#ifdef PARSER_DEBUG
<a name="3168"></a>
<a name="3169"></a>DefineIAction(ParseDebug)
<a name="3170"></a>    execAction()
<a name="3171"></a>    {
<a name="3172"></a>        local newMode;
<a name="3173"></a>
<a name="3174"></a>        /*
<a name="3175"></a>         *   get the mode - if the mode is explicitly stated in the
<a name="3176"></a>         *   command, use the stated new mode, otherwise invert the current
<a name="3177"></a>         *   mode
<a name="3178"></a>         */
<a name="3179"></a>        newMode = (onOrOff_ == 'on'
<a name="3180"></a>                   ? true
<a name="3181"></a>                   : onOrOff_ == 'off'
<a name="3182"></a>                   ? nil
<a name="3183"></a>                   : !libGlobal.parserDebugMode);
<a name="3184"></a>
<a name="3185"></a>        /* set the new mode */
<a name="3186"></a>        libGlobal.parserDebugMode = newMode;
<a name="3187"></a>
<a name="3188"></a>        /* mention the change */
<a name="3189"></a>        "Parser debugging is now
<a name="3190"></a>        &lt;&lt;libGlobal.parserDebugMode ? 'on' : 'off'&gt;&gt;.\n";
<a name="3191"></a>    }
<a name="3192"></a>;
<a name="3193"></a>
<a name="3194"></a>grammar predicate(ParseDebug):
<a name="3195"></a>    'parse-debug' 'on'-&gt;onOrOff_
<a name="3196"></a>    | 'parse-debug' 'off'-&gt;onOrOff_
<a name="3197"></a>    | 'parse-debug'
<a name="3198"></a>    : ParseDebugAction
<a name="3199"></a>;
<a name="3200"></a>
<a name="3201"></a>#endif
<a name="3202"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
