<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>verify.t</title></head><body>
<table class=ban><tr><td><h1>verify.t</h1><td align=right><a href="../file/verify.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library: verification
<a name="7"></a> *
<a name="8"></a> *   This module defines classes related to "verification," which is the
<a name="9"></a> *   phase of command execution where the parser attempts to determine how
<a name="10"></a> *   logical a command is.
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>#include "adv3.h"
<a name="14"></a>
<a name="15"></a>
<a name="16"></a>/* ------------------------------------------------------------------------ */
<a name="17"></a>/*
<a name="18"></a> *   Verification result class.  Verification routines return a
<a name="19"></a> *   verification result describing whether or not an action is allowed,
<a name="20"></a> *   and how much sense the command seems to make.  When a verification
<a name="21"></a> *   fails, it must include a message describing why the command isn't
<a name="22"></a> *   allowed.
<a name="23"></a> *
<a name="24"></a> *   It is important to understand that the purpose of verification
<a name="25"></a> *   results is to guess what's in the player's mind, not to reflect the
<a name="26"></a> *   full internal state of the game.  We use verification results to
<a name="27"></a> *   figure out what a player means with a command, so if we were to rely
<a name="28"></a> *   on information the player doesn't have, we would not correctly guess
<a name="29"></a> *   the player's intentions.  So, in choosing a verification result, only
<a name="30"></a> *   information that ought to be obvious to the player should be
<a name="31"></a> *   consdidered.
<a name="32"></a> *
<a name="33"></a> *   For example, suppose we have a closed door; suppose further that the
<a name="34"></a> *   door happens to be locked, but that there's no way for the player to
<a name="35"></a> *   see that just by looking at the door.  Now, if the player types
<a name="36"></a> *   "close door," we should return "currently illogical" - common sense
<a name="37"></a> *   tells the player that the door is something that can be opened and
<a name="38"></a> *   closed, so we wouldn't return "always illogical," but the player can
<a name="39"></a> *   plainly see that the door is already closed and thus would know that
<a name="40"></a> *   it makes no sense to close it again.  In other words, the player
<a name="41"></a> *   would conclude looking at the door that closing it is currently
<a name="42"></a> *   illogical, so that's the result we should generate.
<a name="43"></a> *
<a name="44"></a> *   What if the player types "open door," though?  In this case, should
<a name="45"></a> *   we return "currently illogical" as well, because the door is locked?
<a name="46"></a> *   The answer is no.  We know that the command won't succeed because we
<a name="47"></a> *   know from looking at the internal game state that the door is locked,
<a name="48"></a> *   but that doesn't matter - it's what the *player* knows that's
<a name="49"></a> *   important, not what the internal game state tells us.  So, what
<a name="50"></a> *   should we return here?  It might seem strange, but the correct result
<a name="51"></a> *   is "logical" - as far as the player is concerned, the door is
<a name="52"></a> *   something that can be opened and closed, and it is currently closed,
<a name="53"></a> *   so it makes perfect sense to open it.
<a name="54"></a> */
<a name="55"></a>class VerifyResult: MessageResult
<a name="56"></a>    /*
<a name="57"></a>     *   Is the action allowed?  This returns true if the command can be
<a name="58"></a>     *   allowed to proceed on the basis of the verification, nil if not.
<a name="59"></a>     */
<a name="60"></a>    allowAction = true
<a name="61"></a>
<a name="62"></a>    /*
<a name="63"></a>     *   Is the action allowed as an implicit action?  This returns true
<a name="64"></a>     *   if the command can be allowed to proceed AND the command can be
<a name="65"></a>     *   undertaken simply because it's implied by another command, even
<a name="66"></a>     *   though the player never explicitly entered the command.  We
<a name="67"></a>     *   distinguish this from allowAction so that we can prevent certain
<a name="68"></a>     *   actions from being undertaken implicitly; we might want to
<a name="69"></a>     *   disallow an implicit action when our best guess is that a player
<a name="70"></a>     *   should know better than to perform an action because it's
<a name="71"></a>     *   obviously dangerous.
<a name="72"></a>     */
<a name="73"></a>    allowImplicit
<a name="74"></a>    {
<a name="75"></a>        /*
<a name="76"></a>         *   by default, any allowable action is also allowed as an
<a name="77"></a>         *   implicit action
<a name="78"></a>         */
<a name="79"></a>        return allowAction;
<a name="80"></a>    }
<a name="81"></a>
<a name="82"></a>    /*
<a name="83"></a>     *   Am I worse than another result?  Returns true if this result is
<a name="84"></a>     *   more disapproving than the other.
<a name="85"></a>     */
<a name="86"></a>    isWorseThan(other)
<a name="87"></a>    {
<a name="88"></a>        /* I'm worse if my result ranking is lower */
<a name="89"></a>        return (resultRank &lt; other.resultRank);
<a name="90"></a>    }
<a name="91"></a>
<a name="92"></a>    /*
<a name="93"></a>     *   compare to another: negative if I'm worse than the other, zero if
<a name="94"></a>     *   we're the same, positive if I'm better
<a name="95"></a>     */
<a name="96"></a>    compareTo(other)
<a name="97"></a>    {
<a name="98"></a>        /* compare based on result rankings */
<a name="99"></a>        return resultRank - other.resultRank;
<a name="100"></a>    }
<a name="101"></a>
<a name="102"></a>    /*
<a name="103"></a>     *   Determine if I should appear in a result list before the given
<a name="104"></a>     *   result object.  By default, this is true if I'm worse than the
<a name="105"></a>     *   given result, but some types of results use special sorting
<a name="106"></a>     *   orders.
<a name="107"></a>     */
<a name="108"></a>    shouldInsertBefore(other)
<a name="109"></a>    {
<a name="110"></a>        /*
<a name="111"></a>         *   by default, I come before the other in a result list if I'm
<a name="112"></a>         *   worse than the other, because we keep result lists in order
<a name="113"></a>         *   from worst to best
<a name="114"></a>         */
<a name="115"></a>        return compareTo(other) &lt; 0;
<a name="116"></a>    }
<a name="117"></a>
<a name="118"></a>    /*
<a name="119"></a>     *   Determine if I'm identical to another result.  Note that it's
<a name="120"></a>     *   possible for two items to compare the same but not be identical -
<a name="121"></a>     *   compareTo() is concerned only with logicalness ranking, but
<a name="122"></a>     *   identicalTo() determines if the two items are exactly the same.
<a name="123"></a>     *   Some subclasses (such as LogicalVerifyResult) distinguish among
<a name="124"></a>     *   items that compare the same but have different reasons for their
<a name="125"></a>     *   rankings.
<a name="126"></a>     */
<a name="127"></a>    identicalTo(other)
<a name="128"></a>    {
<a name="129"></a>        /* by default, I'm identical if my comparison shows I rank the same */
<a name="130"></a>        return compareTo(other) == 0;
<a name="131"></a>    }
<a name="132"></a>
<a name="133"></a>    /*
<a name="134"></a>     *   Our result ranking relative to other results.  Each result class
<a name="135"></a>     *   defines a ranking level so that we can determine whether one
<a name="136"></a>     *   result is better (more approving) or worse (more disapproving)
<a name="137"></a>     *   than another.
<a name="138"></a>     *
<a name="139"></a>     *   To allow easy insertion of new library extension result types or
<a name="140"></a>     *   game-specific result types, we assign widely spaced rankings to
<a name="141"></a>     *   the pre-defined results.  This is arbitrary; the only thing that
<a name="142"></a>     *   matters in comparing two results is the order of the rank values.
<a name="143"></a>     */
<a name="144"></a>    resultRank = nil
<a name="145"></a>
<a name="146"></a>    /*
<a name="147"></a>     *   Should we exclude plurals from being matched, when this type of
<a name="148"></a>     *   result is present?  By default, we don't; some illogical types
<a name="149"></a>     *   might want to exclude plurals because the result types indicate
<a name="150"></a>     *   such obvious illogicalities.
<a name="151"></a>     */
<a name="152"></a>    excludePluralMatches = nil
<a name="153"></a>;
<a name="154"></a>
<a name="155"></a>/*
<a name="156"></a> *   Verification result - command is logical and allowed.
<a name="157"></a> *
<a name="158"></a> *   This can provide additional information ranking the likelihood of the
<a name="159"></a> *   command intepretation, which can be useful to distinguish among
<a name="160"></a> *   logical but not equally likely possibilities.  For example, if the
<a name="161"></a> *   command is "take book," and the actor has a book inside his or her
<a name="162"></a> *   backpack, and there is also a book on a table in the actor's
<a name="163"></a> *   location, it would make sense to take either book, but the game might
<a name="164"></a> *   prefer to take the book on the table because it's not already being
<a name="165"></a> *   carried.  The likelihood level can be used to rank these
<a name="166"></a> *   alternatives: if the object is being carried indirectly, a lower
<a name="167"></a> *   likelihood ranking would be returned than if the object were not
<a name="168"></a> *   already somewhere in the actor's inventory.
<a name="169"></a> */
<a name="170"></a>class LogicalVerifyResult: VerifyResult
<a name="171"></a>    construct(likelihoodRank, key, ord)
<a name="172"></a>    {
<a name="173"></a>        /* remember my likelihood ranking */
<a name="174"></a>        likelihood = likelihoodRank;
<a name="175"></a>
<a name="176"></a>        /* remember my key value */
<a name="177"></a>        keyVal = key;
<a name="178"></a>
<a name="179"></a>        /* remember my list order */
<a name="180"></a>        listOrder = ord;
<a name="181"></a>    }
<a name="182"></a>
<a name="183"></a>    /* am I worse than the other result? */
<a name="184"></a>    isWorseThan(other)
<a name="185"></a>    {
<a name="186"></a>        /*
<a name="187"></a>         *   I'm worse if my result ranking is lower; or, if we are both
<a name="188"></a>         *   LogicalVerifyResult objects, I'm worse if my likelihood is
<a name="189"></a>         *   lower.
<a name="190"></a>         */
<a name="191"></a>        if (resultRank == other.resultRank)
<a name="192"></a>            return likelihood &lt; other.likelihood;
<a name="193"></a>        else
<a name="194"></a>            return inherited(other);
<a name="195"></a>    }
<a name="196"></a>
<a name="197"></a>    /* compare to another result */
<a name="198"></a>    compareTo(other)
<a name="199"></a>    {
<a name="200"></a>        /*
<a name="201"></a>         *   if we're not both of the same rank (i.e., 'logical'), inherit
<a name="202"></a>         *   the default comparison
<a name="203"></a>         */
<a name="204"></a>        if (resultRank != other.resultRank)
<a name="205"></a>            return inherited(other);
<a name="206"></a>
<a name="207"></a>        /*
<a name="208"></a>         *   we're both 'logical' results, so compare based on our
<a name="209"></a>         *   respective likelihoods
<a name="210"></a>         */
<a name="211"></a>        return likelihood - other.likelihood;
<a name="212"></a>    }
<a name="213"></a>
<a name="214"></a>    /* determine if I go in a result list before the given result */
<a name="215"></a>    shouldInsertBefore(other)
<a name="216"></a>    {
<a name="217"></a>        /* if we're not both of the same rank, use the default handling */
<a name="218"></a>        if (resultRank != other.resultRank)
<a name="219"></a>            return inherited(other);
<a name="220"></a>
<a name="221"></a>        /*
<a name="222"></a>         *   we're both 'logical' results, so order in the list based on
<a name="223"></a>         *   our priority ordering; if we're of the same priority, use the
<a name="224"></a>         *   default ordering
<a name="225"></a>         */
<a name="226"></a>        if (listOrder != other.listOrder)
<a name="227"></a>            return listOrder &lt; other.listOrder;
<a name="228"></a>        else
<a name="229"></a>            return inherited(other);
<a name="230"></a>    }
<a name="231"></a>
<a name="232"></a>    /* determine if I'm identical to another result */
<a name="233"></a>    identicalTo(other)
<a name="234"></a>    {
<a name="235"></a>        /*
<a name="236"></a>         *   I'm identical if I compare the same and my key value is the
<a name="237"></a>         *   same.
<a name="238"></a>         */
<a name="239"></a>        return compareTo(other) == 0 &amp;&amp; keyVal == other.keyVal;
<a name="240"></a>    }
<a name="241"></a>
<a name="242"></a>    /*
<a name="243"></a>     *   The likelihood of the command - the higher the number, the more
<a name="244"></a>     *   likely.  We use 100 as the default, so that there's plenty of
<a name="245"></a>     *   room for specific rankings above or below the default. Particular
<a name="246"></a>     *   actions might want to rank likelihoods based on action-specific
<a name="247"></a>     *   factors.
<a name="248"></a>     */
<a name="249"></a>    likelihood = 100
<a name="250"></a>
<a name="251"></a>    /*
<a name="252"></a>     *   Our list ordering.  This establishes how we are entered into the
<a name="253"></a>     *   master results list relative to other 'logical' results.  Results
<a name="254"></a>     *   are entered into the master list in ascending list order, so a
<a name="255"></a>     *   lower order number means an earlier place in the list.
<a name="256"></a>     *
<a name="257"></a>     *   The list ordering is more important than the likelihood ranking.
<a name="258"></a>     *   Suppose we have two items: one is at list order 10 and has
<a name="259"></a>     *   likelihood 100, and the other is at list order 20 and has
<a name="260"></a>     *   likelihood 50.  The order of the likelihoods stored in the list
<a name="261"></a>     *   will be (100, 50).  This is inverted from the normal ordering,
<a name="262"></a>     *   which would put the worst item first.
<a name="263"></a>     *
<a name="264"></a>     *   The point of this ordering is to allow for logical results with
<a name="265"></a>     *   higher or lower importances in establishing the likelihood.  The
<a name="266"></a>     *   library uses the following list order values:
<a name="267"></a>     *
<a name="268"></a>     *   100 - the default ranking.  This is used in most cases.
<a name="269"></a>     *
<a name="270"></a>     *   150 - secondary ranking.  This is used for rankings that aren't
<a name="271"></a>     *   of great importance but which can be useful to distinguish
<a name="272"></a>     *   objects in cases where no more important rankings are present.
<a name="273"></a>     *   The library uses this for precondition verification rankings.
<a name="274"></a>     */
<a name="275"></a>    listOrder = 100
<a name="276"></a>
<a name="277"></a>    /*
<a name="278"></a>     *   my key value, to distinguish among different results with the
<a name="279"></a>     *   same likelihood ranking
<a name="280"></a>     */
<a name="281"></a>    keyVal = ''
<a name="282"></a>
<a name="283"></a>    /* result rank - we're the most approving kind of result */
<a name="284"></a>    resultRank = 100
<a name="285"></a>;
<a name="286"></a>
<a name="287"></a>/*
<a name="288"></a> *   Verification result - command is logical and allowed, but is
<a name="289"></a> *   dangerous.  As with all verify results, this should reflect our best
<a name="290"></a> *   guess as to the player's intentions, so this should only be used when
<a name="291"></a> *   it is meant to be obvious to the player that the action is dangerous.
<a name="292"></a> */
<a name="293"></a>class DangerousVerifyResult: VerifyResult
<a name="294"></a>    /*
<a name="295"></a>     *   don't allow dangerous actions to be undertaken implicitly - we do
<a name="296"></a>     *   allow these actions, but only when explicitly requested
<a name="297"></a>     */
<a name="298"></a>    allowImplicit = nil
<a name="299"></a>
<a name="300"></a>    /* result rank - we're only slightly less approving than 'logical' */
<a name="301"></a>    resultRank = 90
<a name="302"></a>
<a name="303"></a>    /* this result indicates danger */
<a name="304"></a>    isDangerous = true
<a name="305"></a>;
<a name="306"></a>
<a name="307"></a>/*
<a name="308"></a> *   Verification result - command is currently illogical due to the state
<a name="309"></a> *   of the object, but might be logically applied to the object at other
<a name="310"></a> *   times.  For example, "open door" on a door that's already open is
<a name="311"></a> *   illogical at the moment, but makes more sense than opening something
<a name="312"></a> *   that has no evident way to be opened or closed to begin with.
<a name="313"></a> */
<a name="314"></a>class IllogicalNowVerifyResult: VerifyResult
<a name="315"></a>    /* the command isn't allowed */
<a name="316"></a>    allowAction = nil
<a name="317"></a>
<a name="318"></a>    /* result rank */
<a name="319"></a>    resultRank = 40
<a name="320"></a>;
<a name="321"></a>
<a name="322"></a>/*
<a name="323"></a> *   Verification result - command is currently illogical, because the
<a name="324"></a> *   state that the command seeks to impose already obtains.  For example,
<a name="325"></a> *   we're trying to open a door that's already open, or drop an object
<a name="326"></a> *   that we're not carrying.
<a name="327"></a> *
<a name="328"></a> *   This is almost exactly the same as an "illogical now" result, so this
<a name="329"></a> *   is a simple subclass of that result type.  We act almost the same as
<a name="330"></a> *   an "illogical now" result; the only reason to distinguish this type is
<a name="331"></a> *   that it's an especially obvious kind of condition, so we might want to
<a name="332"></a> *   use it to exclude some vocabulary matches that we wouldn't normally
<a name="333"></a> *   exclude for the more general "illogical now" result type.
<a name="334"></a> */
<a name="335"></a>class IllogicalAlreadyVerifyResult: IllogicalNowVerifyResult
<a name="336"></a>    /* exclude plural matches when this result type is present */
<a name="337"></a>    excludePluralMatches = true
<a name="338"></a>;
<a name="339"></a>
<a name="340"></a>/*
<a name="341"></a> *   Verification result - command is always illogical, regardless of the
<a name="342"></a> *   state of the object.  "Close fish" might fall into this category.
<a name="343"></a> */
<a name="344"></a>class IllogicalVerifyResult: VerifyResult
<a name="345"></a>    /* the command isn't allowed */
<a name="346"></a>    allowAction = nil
<a name="347"></a>
<a name="348"></a>    /* result rank - this is the most disapproving of the disapprovals */
<a name="349"></a>    resultRank = 30
<a name="350"></a>;
<a name="351"></a>
<a name="352"></a>/*
<a name="353"></a> *   Verification result - command is always illogical, because it's trying
<a name="354"></a> *   to use an object on itself in some invalid way, as in PUT BOX IN BOX.
<a name="355"></a> *
<a name="356"></a> *   This is almost identical to a regular always-illogical result, so
<a name="357"></a> *   we're a simple subclass of that result type.  We distinguish these
<a name="358"></a> *   from the basic always-illogical type because it's especially obvious
<a name="359"></a> *   that the "self" kind is illogical, so we might in some cases want to
<a name="360"></a> *   exclude a vocabulary match for the "self" kind that we wouldn't
<a name="361"></a> *   exclude for the basic kind.
<a name="362"></a> */
<a name="363"></a>class IllogicalSelfVerifyResult: IllogicalVerifyResult
<a name="364"></a>    /* exclude plural matches when this result type is present */
<a name="365"></a>    excludePluralMatches = true
<a name="366"></a>;
<a name="367"></a>
<a name="368"></a>/*
<a name="369"></a> *   Verification result - command is logical and allowed, but is
<a name="370"></a> *   non-obvious on this object.  This should be used when the command is
<a name="371"></a> *   logical, but should not be obvious to the player.  When this
<a name="372"></a> *   verification result is present, the command is allowed when performed
<a name="373"></a> *   explicitly but will never be taken as a default.
<a name="374"></a> *
<a name="375"></a> *   In cases of ambiguity, a non-obvious object is equivalent to an
<a name="376"></a> *   always-illogical object.  A non-obvious object *appears* to be
<a name="377"></a> *   illogical at first glance, so we want to treat it the same as an
<a name="378"></a> *   ordinarily illogical object if we're trying to choose among ambiguous
<a name="379"></a> *   objects.
<a name="380"></a> */
<a name="381"></a>class NonObviousVerifyResult: VerifyResult
<a name="382"></a>    /*
<a name="383"></a>     *   don't allow non-obvious actions to be undertaken implicitly - we
<a name="384"></a>     *   allow these actions, but only when explicitly requested
<a name="385"></a>     */
<a name="386"></a>    allowImplicit = nil
<a name="387"></a>
<a name="388"></a>    /*
<a name="389"></a>     *   non-obvious objects are illogical at first glance, so rank them
<a name="390"></a>     *   the same as objects that are actually illogical
<a name="391"></a>     */
<a name="392"></a>    resultRank = (IllogicalVerifyResult.resultRank)
<a name="393"></a>;
<a name="394"></a>
<a name="395"></a>/*
<a name="396"></a> *   Verification result - object is inaccessible.  This should be used
<a name="397"></a> *   when a command is applied to an object that is not accessibile in a
<a name="398"></a> *   sense required for the command; for example, "look at" requires that
<a name="399"></a> *   its target object be visible, so a "look at" command in the dark
<a name="400"></a> *   would fail with this type of result.
<a name="401"></a> */
<a name="402"></a>class InaccessibleVerifyResult: VerifyResult
<a name="403"></a>    /* the command isn't allowed */
<a name="404"></a>    allowAction = nil
<a name="405"></a>
<a name="406"></a>    /*
<a name="407"></a>     *   This ranks below any illogical result - inaccessibility is a
<a name="408"></a>     *   stronger disapproval than mere illogicality.
<a name="409"></a>     */
<a name="410"></a>    resultRank = 10
<a name="411"></a>;
<a name="412"></a>
<a name="413"></a>/*
<a name="414"></a> *   Default 'logical' verify result.  If a verification result list
<a name="415"></a> *   doesn't have an explicitly set result, this is the default value.
<a name="416"></a> */
<a name="417"></a>defaultLogicalVerifyResult: LogicalVerifyResult
<a name="418"></a>    showMessage()
<a name="419"></a>    {
<a name="420"></a>        /* the default logical result has no message */
<a name="421"></a>    }
<a name="422"></a>    keyVal = 'default'
<a name="423"></a>;
<a name="424"></a>
<a name="425"></a>/*
<a name="426"></a> *   Verification result list.
<a name="427"></a> */
<a name="428"></a>class VerifyResultList: object
<a name="429"></a>    construct()
<a name="430"></a>    {
<a name="431"></a>        /* initialize the results vector */
<a name="432"></a>        results_ = new Vector(5);
<a name="433"></a>    }
<a name="434"></a>
<a name="435"></a>    /*
<a name="436"></a>     *   Add a result to our result list.
<a name="437"></a>     */
<a name="438"></a>    addResult(result)
<a name="439"></a>    {
<a name="440"></a>        local i;
<a name="441"></a>
<a name="442"></a>        /*
<a name="443"></a>         *   Find the insertion point.  We want to keep the results sorted
<a name="444"></a>         *   in order from worst to best, so insert this result before the
<a name="445"></a>         *   first item in our list that's better than this item.
<a name="446"></a>         */
<a name="447"></a>        for (i = 1 ; i &lt;= results_.length() ; ++i)
<a name="448"></a>        {
<a name="449"></a>            /*
<a name="450"></a>             *   if it's exactly the same as this item, don't add it -
<a name="451"></a>             *   keep only one of each unique result
<a name="452"></a>             */
<a name="453"></a>            if (result.identicalTo(results_[i]))
<a name="454"></a>                return;
<a name="455"></a>
<a name="456"></a>            /*
<a name="457"></a>             *   If the new result is to be inserted before the result at
<a name="458"></a>             *   the current index, insert the new result at the current
<a name="459"></a>             *   index.
<a name="460"></a>             */
<a name="461"></a>            if (result.shouldInsertBefore(results_[i]))
<a name="462"></a>                break;
<a name="463"></a>        }
<a name="464"></a>
<a name="465"></a>        /* add the result to our list at the index we found */
<a name="466"></a>        results_.insertAt(i, result);
<a name="467"></a>    }
<a name="468"></a>
<a name="469"></a>    /*
<a name="470"></a>     *   Is the action allowed?  We return true if we have no results;
<a name="471"></a>     *   otherwise, we allow the action if *all* of our results allow it,
<a name="472"></a>     *   nil if even one disapproves.
<a name="473"></a>     */
<a name="474"></a>    allowAction()
<a name="475"></a>    {
<a name="476"></a>        /* approve if the effective result approves */
<a name="477"></a>        return results_.indexWhich({x: !x.allowAction}) == nil;
<a name="478"></a>    }
<a name="479"></a>
<a name="480"></a>    /*
<a name="481"></a>     *   Do we exclude plural matches?  We do if we have at least one
<a name="482"></a>     *   result that excludes plural matches.
<a name="483"></a>     */
<a name="484"></a>    excludePluralMatches()
<a name="485"></a>    {
<a name="486"></a>        /* exclude plural matches if we have any result that says to */
<a name="487"></a>        return results_.indexWhich({x: x.excludePluralMatches}) != nil;
<a name="488"></a>    }
<a name="489"></a>
<a name="490"></a>    /*
<a name="491"></a>     *   Is the action allowed as an implicit action?  Returns true if we
<a name="492"></a>     *   have no results; otherwise, returns true if *all* of our results
<a name="493"></a>     *   allow the implicit action, nil if even one disapproves.
<a name="494"></a>     */
<a name="495"></a>    allowImplicit()
<a name="496"></a>    {
<a name="497"></a>        /* search for disapprovals; if we find none, allow it */
<a name="498"></a>        return results_.indexWhich({x: !x.allowImplicit}) == nil;
<a name="499"></a>    }
<a name="500"></a>
<a name="501"></a>    /*
<a name="502"></a>     *   Show the message.  If I have any results, we'll show the message
<a name="503"></a>     *   for the effective (i.e., most disapproving) result; otherwise we
<a name="504"></a>     *   show nothing.
<a name="505"></a>     */
<a name="506"></a>    showMessage()
<a name="507"></a>    {
<a name="508"></a>        local res;
<a name="509"></a>
<a name="510"></a>        /*
<a name="511"></a>         *   Find the first result that disapproves.  Only disapprovers
<a name="512"></a>         *   will have messages, so we need to find a disapprover.
<a name="513"></a>         *   Entries are in ascending order of approval, and we want the
<a name="514"></a>         *   most disapproving disapprover, so take the first one we find.
<a name="515"></a>         */
<a name="516"></a>        if ((res = results_.valWhich({x: !x.allowAction})) != nil)
<a name="517"></a>            res.showMessage();
<a name="518"></a>    }
<a name="519"></a>
<a name="520"></a>    /*
<a name="521"></a>     *   Get my effective result object.  If I have no explicitly-set
<a name="522"></a>     *   result object, my effective result is the defaut logical result.
<a name="523"></a>     *   Otherwise, we return the most disapproving result in our list.
<a name="524"></a>     */
<a name="525"></a>    getEffectiveResult()
<a name="526"></a>    {
<a name="527"></a>        /* if our list is empty, return the default logical result */
<a name="528"></a>        if (results_.length() == 0)
<a name="529"></a>            return defaultLogicalVerifyResult;
<a name="530"></a>
<a name="531"></a>        /*
<a name="532"></a>         *   return the first item in the list - we keep the list sorted
<a name="533"></a>         *   from worst to best, so the first item is the most
<a name="534"></a>         *   disapproving result we have
<a name="535"></a>         */
<a name="536"></a>        return results_[1];
<a name="537"></a>    }
<a name="538"></a>
<a name="539"></a>    /*
<a name="540"></a>     *   Compare my cumulative result (i.e., my most disapproving result)
<a name="541"></a>     *   to that of another result list's cumulative result.  Returns a
<a name="542"></a>     *   value suitable for sorting: -1 if I'm worse than the other one, 0
<a name="543"></a>     *   if we're the same, and 1 if I'm better than the other one.  This
<a name="544"></a>     *   can be used to compare the cumulative verification results for
<a name="545"></a>     *   two objects to determine which object is more logical.
<a name="546"></a>     */
<a name="547"></a>    compareTo(other)
<a name="548"></a>    {
<a name="549"></a>        local lst1;
<a name="550"></a>        local lst2;
<a name="551"></a>        local idx;
<a name="552"></a>
<a name="553"></a>        /* get private copies of the two lists */
<a name="554"></a>        lst1 = results_.toList();
<a name="555"></a>        lst2 = other.results_.toList();
<a name="556"></a>
<a name="557"></a>        /* keep going until we find differing items or run out of items */
<a name="558"></a>        for (idx = 1 ; idx &lt;= lst1.length() || idx &lt;= lst2.length(); ++idx)
<a name="559"></a>        {
<a name="560"></a>            local a, b;
<a name="561"></a>            local diff;
<a name="562"></a>
<a name="563"></a>            /*
<a name="564"></a>             *   Get the current item from each list.  If we're past the
<a name="565"></a>             *   end of one or the other list, use the default logical
<a name="566"></a>             *   result as the current item from that list.
<a name="567"></a>             */
<a name="568"></a>            a = idx &lt;= lst1.length() ? lst1[idx] : defaultLogicalVerifyResult;
<a name="569"></a>            b = idx &lt;= lst2.length() ? lst2[idx] : defaultLogicalVerifyResult;
<a name="570"></a>
<a name="571"></a>            /*
<a name="572"></a>             *   If the two items have distinct rankings, simply return
<a name="573"></a>             *   the sense of the ranking.
<a name="574"></a>             */
<a name="575"></a>            if ((diff = a.compareTo(b)) != 0)
<a name="576"></a>                return diff;
<a name="577"></a>
<a name="578"></a>            /*
<a name="579"></a>             *   The two items at the current position have equivalent
<a name="580"></a>             *   rankings, so ignore them for the purposes of comparing
<a name="581"></a>             *   these two items.  Simply proceed to the next item in each
<a name="582"></a>             *   list.  Before we do, though, check to see if we can
<a name="583"></a>             *   eliminate that current item from our own list - if we
<a name="584"></a>             *   have an identical item (not just ranked the same, but
<a name="585"></a>             *   actually identical) in the other list, throw the item out
<a name="586"></a>             *   of both lists.
<a name="587"></a>             */
<a name="588"></a>            for (local j = 1 ; j &lt; lst2.length() ; ++j)
<a name="589"></a>            {
<a name="590"></a>                /*
<a name="591"></a>                 *   if this item in the other list is identical to the
<a name="592"></a>                 *   current item from our list, throw out both items
<a name="593"></a>                 */
<a name="594"></a>                if (lst2[j].identicalTo(a))
<a name="595"></a>                {
<a name="596"></a>                    /* remove the items from both lists */
<a name="597"></a>                    lst1 -= a;
<a name="598"></a>                    lst2 -= lst2[j];
<a name="599"></a>
<a name="600"></a>                    /* consider the new current item at this position */
<a name="601"></a>                    --idx;
<a name="602"></a>
<a name="603"></a>                    /* no need to scan any further */
<a name="604"></a>                    break;
<a name="605"></a>                }
<a name="606"></a>            }
<a name="607"></a>        }
<a name="608"></a>
<a name="609"></a>        /*
<a name="610"></a>         *   We've run out of items in both lists, so everything must have
<a name="611"></a>         *   been identical in both lists.  Since we have no 'verify' basis
<a name="612"></a>         *   for preferring one object over the other, fall back on our
<a name="613"></a>         *   intrinsic vocabLikelihood values as a last resort.
<a name="614"></a>         */
<a name="615"></a>        return obj_.obj_.vocabLikelihood - other.obj_.obj_.vocabLikelihood;
<a name="616"></a>    }
<a name="617"></a>
<a name="618"></a>    /*
<a name="619"></a>     *   Determine if we match another verify result list after remapping.
<a name="620"></a>     *   This determines if the other verify result is equivalent to us
<a name="621"></a>     *   after considering the effects of remapping.  We'll return true if
<a name="622"></a>     *   all of the following are true:
<a name="623"></a>     *
<a name="624"></a>     *   - compareTo returns zero, indicating that we have the same
<a name="625"></a>     *   weighting in the verification results
<a name="626"></a>     *
<a name="627"></a>     *   - we refer to the same object after remapping; the effective
<a name="628"></a>     *   object after remapping is our original resolved object, if we're
<a name="629"></a>     *   not remapped, or our remap target if we are
<a name="630"></a>     *
<a name="631"></a>     *   - we use the object for the same action and in the same role
<a name="632"></a>     *
<a name="633"></a>     *   Note: this can only be called on remapped results.  Results can
<a name="634"></a>     *   only be combined in the first place when remapped, so there's no
<a name="635"></a>     *   need to ever call this on an unremapped result.
<a name="636"></a>     */
<a name="637"></a>    matchForCombineRemapped(other, action, role)
<a name="638"></a>    {
<a name="639"></a>        /* if our verification values aren't identical, we can't combine */
<a name="640"></a>        if (compareTo(other) != 0)
<a name="641"></a>            return nil;
<a name="642"></a>
<a name="643"></a>        /*
<a name="644"></a>         *   check the other - how we check depends on whether it's been
<a name="645"></a>         *   remapped or not
<a name="646"></a>         */
<a name="647"></a>        if (other.remapTarget_ == nil)
<a name="648"></a>        {
<a name="649"></a>            /*
<a name="650"></a>             *   The other one hasn't been remapped, so our remapped
<a name="651"></a>             *   object, action, and role must match the other's original
<a name="652"></a>             *   object, action, and role.  Note that to compare the two
<a name="653"></a>             *   actions, we compare their baseActionClass properties,
<a name="654"></a>             *   since this property gives us the identifying canonical
<a name="655"></a>             *   base class for the actions.
<a name="656"></a>             */
<a name="657"></a>            return (remapTarget_ == other.obj_.obj_
<a name="658"></a>                    &amp;&amp; remapAction_.baseActionClass == action.baseActionClass
<a name="659"></a>                    &amp;&amp; remapRole_ == role);
<a name="660"></a>        }
<a name="661"></a>        else
<a name="662"></a>        {
<a name="663"></a>            /*
<a name="664"></a>             *   The other one has been remapped as well, so our remapped
<a name="665"></a>             *   object, action, and role must match the other's remapped
<a name="666"></a>             *   object, action, and role.
<a name="667"></a>             */
<a name="668"></a>            return (remapTarget_ == other.remapTarget_
<a name="669"></a>                    &amp;&amp; remapAction_.baseActionClass
<a name="670"></a>                       == other.remapAction_.baseActionClass
<a name="671"></a>                    &amp;&amp; remapRole_ == other.remapRole_);
<a name="672"></a>        }
<a name="673"></a>    }
<a name="674"></a>
<a name="675"></a>    /*
<a name="676"></a>     *   The remapped target object.  This will filled in during
<a name="677"></a>     *   verification if we decide that we want to remap the nominal
<a name="678"></a>     *   object of the command to a different object.  This should be set
<a name="679"></a>     *   to the ultimate target object after all remappings.
<a name="680"></a>     */
<a name="681"></a>    remapTarget_ = nil
<a name="682"></a>
<a name="683"></a>    /* the action and role of the remapped action */
<a name="684"></a>    remapAction_ = nil
<a name="685"></a>    remapRole_ = nil
<a name="686"></a>
<a name="687"></a>    /* our list of results */
<a name="688"></a>    results_ = []
<a name="689"></a>
<a name="690"></a>    /*
<a name="691"></a>     *   The ResolveInfo for the object being verified.  Note that this
<a name="692"></a>     *   isn't saved until AFTER the verification is completed.
<a name="693"></a>     */
<a name="694"></a>    obj_ = nil
<a name="695"></a>
<a name="696"></a>    /*
<a name="697"></a>     *   The original list index for this result.  We use this when sorting
<a name="698"></a>     *   a list of results to preserve the original ordering of otherwise
<a name="699"></a>     *   equivalent items.
<a name="700"></a>     */
<a name="701"></a>    origOrder = 0
<a name="702"></a>;
<a name="703"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
