<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>misc.t</title></head><body>
<table class=ban><tr><td><h1>misc.t</h1><td align=right><a href="../file/misc.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library - miscellaneous definitions
<a name="7"></a> *
<a name="8"></a> *   This module contains miscellaneous definitions that don't have a
<a name="9"></a> *   natural grouping with any larger modules, and which aren't complex
<a name="10"></a> *   enough to justify modules of their own.
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/* include the library header */
<a name="14"></a>#include "adv3.h"
<a name="15"></a>
<a name="16"></a>
<a name="17"></a>/* ------------------------------------------------------------------------ */
<a name="18"></a>/*
<a name="19"></a> *   When a call is made to a property not defined or inherited by the
<a name="20"></a> *   target object, the system will automatically invoke this method.  The
<a name="21"></a> *   method will be invoked with a property pointer as its first argument,
<a name="22"></a> *   and the original arguments as the remaining arguments.  The first
<a name="23"></a> *   argument gives the property that was invoked and not defined by the
<a name="24"></a> *   object.  A typical definition in an object would look like this:
<a name="25"></a> *
<a name="26"></a> *   propNotDefined(prop, [args]) { ... }
<a name="27"></a> *
<a name="28"></a> *   If this method is not defined by the object, the system simply
<a name="29"></a> *   returns nil as the value of the undefined property evaluation or
<a name="30"></a> *   method invocation.
<a name="31"></a> */
<a name="32"></a>property propNotDefined;
<a name="33"></a>export propNotDefined;
<a name="34"></a>
<a name="35"></a>
<a name="36"></a>/* ------------------------------------------------------------------------ */
<a name="37"></a>/*
<a name="38"></a> *   We refer to some properties defined primarily in score.t - that's an
<a name="39"></a> *   optional module, though, so make sure the compiler has heard of these.
<a name="40"></a> */
<a name="41"></a>property calcMaxScore, runScoreNotifier;
<a name="42"></a>
<a name="43"></a>
<a name="44"></a>/* ------------------------------------------------------------------------ */
<a name="45"></a>/*
<a name="46"></a> *   The library base class for the gameMain object.
<a name="47"></a> *
<a name="48"></a> *   Each game MUST define an object called 'gameMain' to define how the
<a name="49"></a> *   game starts up.  You can use GameMainDef as the base class of your
<a name="50"></a> *   'gameMain' object, in which case the only thing you're required to
<a name="51"></a> *   specify in your object is the 'initialPlayerChar' property - you can
<a name="52"></a> *   inherit everything else from the GameMainDef class if you don't
<a name="53"></a> *   require any further customizations.
<a name="54"></a> */
<a name="55"></a>class GameMainDef: object
<a name="56"></a>    /*
<a name="57"></a>     *   The initial player character.  Each game's 'gameMain' object MUST
<a name="58"></a>     *   define this to refer to the Actor object that serves as the
<a name="59"></a>     *   initial player character.
<a name="60"></a>     */
<a name="61"></a>    initialPlayerChar = nil
<a name="62"></a>
<a name="63"></a>    /*
<a name="64"></a>     *   Show the game's introduction.  This routine is called by the
<a name="65"></a>     *   default newGame() just before entering the main command loop.  The
<a name="66"></a>     *   command loop starts off by showing the initial room description,
<a name="67"></a>     *   so there's no need to do that here.
<a name="68"></a>     *
<a name="69"></a>     *   Most games will want to override this, to show a prologue message
<a name="70"></a>     *   setting up the game's initial situation for the player.  We don't
<a name="71"></a>     *   show anything by default.
<a name="72"></a>     */
<a name="73"></a>    showIntro() { }
<a name="74"></a>
<a name="75"></a>    /*
<a name="76"></a>     *   Show the "goodbye" message.  This is called after the main command
<a name="77"></a>     *   loop terminates.
<a name="78"></a>     *
<a name="79"></a>     *   We don't show anything by default.  If you want to show a "thanks
<a name="80"></a>     *   for playing" type of message as the game exits, override this
<a name="81"></a>     *   routine with the desired text.
<a name="82"></a>     */
<a name="83"></a>    showGoodbye() { }
<a name="84"></a>
<a name="85"></a>    /*
<a name="86"></a>     *   Begin a new game.  This default implementation shows the
<a name="87"></a>     *   introductory message, calls the main command loop, and finally
<a name="88"></a>     *   shows the goodbye message.
<a name="89"></a>     *
<a name="90"></a>     *   You can override this routine if you want to customize the startup
<a name="91"></a>     *   protocol.  For example, if you want to create a pre-game options
<a name="92"></a>     *   menu, you could override this routine to show the list of options
<a name="93"></a>     *   and process the user's input.  If you need only to customize the
<a name="94"></a>     *   introduction and goodbye messages, you can simply override
<a name="95"></a>     *   showIntro() and showGoodbye() instead.
<a name="96"></a>     */
<a name="97"></a>    newGame()
<a name="98"></a>    {
<a name="99"></a>        /*
<a name="100"></a>         *   Show the statusline before we display our introductory.  This
<a name="101"></a>         *   will help minimize redrawing - if we waited until after
<a name="102"></a>         *   displaying some text, we might have to redraw some of the
<a name="103"></a>         *   screen to rearrange things for the new screen area taken up by
<a name="104"></a>         *   the status line, which could be visible to the user.  By
<a name="105"></a>         *   setting up the status line first, we'll probably have less to
<a name="106"></a>         *   redraw because we won't have anything on the screen yet when
<a name="107"></a>         *   figuring the layout.
<a name="108"></a>         */
<a name="109"></a>        statusLine.showStatusLine();
<a name="110"></a>
<a name="111"></a>        /* show the introduction */
<a name="112"></a>        showIntro();
<a name="113"></a>
<a name="114"></a>        /* run the game, showing the initial location's full description */
<a name="115"></a>        runGame(true);
<a name="116"></a>
<a name="117"></a>        /* show the end-of-game message */
<a name="118"></a>        showGoodbye();
<a name="119"></a>    }
<a name="120"></a>
<a name="121"></a>    /*
<a name="122"></a>     *   Restore a game and start it running.  This is invoked when the
<a name="123"></a>     *   user launches the interpreter using a saved game file; for
<a name="124"></a>     *   example, on a Macintosh, this happens when the user double-clicks
<a name="125"></a>     *   on a saved game file on the desktop.
<a name="126"></a>     *
<a name="127"></a>     *   This default implementation bypasses any normal introduction
<a name="128"></a>     *   messages: we simply restore the game file if possible, and
<a name="129"></a>     *   immediately start the game's main command loop.  Most games won't
<a name="130"></a>     *   need to override this, but you can if you need some special effect
<a name="131"></a>     *   in the restore-at-startup case.
<a name="132"></a>     */
<a name="133"></a>    restoreAndRunGame(filename)
<a name="134"></a>    {
<a name="135"></a>        local succ;
<a name="136"></a>
<a name="137"></a>        /* mention that we're about to restore the saved position */
<a name="138"></a>        gLibMessages.noteMainRestore();
<a name="139"></a>
<a name="140"></a>        /* try restoring it */
<a name="141"></a>        succ = RestoreAction.startupRestore(filename);
<a name="142"></a>
<a name="143"></a>        /* show a blank line after the restore result message */
<a name="144"></a>        "&lt;.p&gt;";
<a name="145"></a>
<a name="146"></a>        /* if we were successful, run the game */
<a name="147"></a>        if (succ)
<a name="148"></a>        {
<a name="149"></a>            /*
<a name="150"></a>             *   Run the command loop.  There's no need to show the room
<a name="151"></a>             *   description, since the RESTORE action will have already
<a name="152"></a>             *   done so.
<a name="153"></a>             */
<a name="154"></a>            runGame(nil);
<a name="155"></a>
<a name="156"></a>            /* show the end-of-game message */
<a name="157"></a>            showGoodbye();
<a name="158"></a>        }
<a name="159"></a>    }
<a name="160"></a>
<a name="161"></a>    /*
<a name="162"></a>     *   Set the interpreter window title, if applicable to the local
<a name="163"></a>     *   platform.  This simply displays a &lt;TITLE&gt; tag to set the title to
<a name="164"></a>     *   the string found in the versionInfo object.
<a name="165"></a>     */
<a name="166"></a>    setGameTitle()
<a name="167"></a>    {
<a name="168"></a>        /* write the &lt;TITLE&gt; tag with the game's name */
<a name="169"></a>        "&lt;title&gt;&lt;&lt;versionInfo.name&gt;&gt;&lt;/title&gt;";
<a name="170"></a>    }
<a name="171"></a>
<a name="172"></a>    /*
<a name="173"></a>     *   Set up the HTML-mode about-box.  By default, this does nothing.
<a name="174"></a>     *   Games can use this routine to show an &lt;ABOUTBOX&gt; tag, if desired,
<a name="175"></a>     *   to set up the contents of an about-box for HTML TADS platforms.
<a name="176"></a>     *
<a name="177"></a>     *   Note that an &lt;ABOUTBOX&gt; tag must be re-initialized each time the
<a name="178"></a>     *   main game window is cleared, so this routine should be called
<a name="179"></a>     *   again after any call to clearScreen().
<a name="180"></a>     */
<a name="181"></a>    setAboutBox()
<a name="182"></a>    {
<a name="183"></a>        /* we don't show any about-box by default */
<a name="184"></a>    }
<a name="185"></a>
<a name="186"></a>    /*
<a name="187"></a>     *   Build a saved game metadata table.  This returns a LookupTable
<a name="188"></a>     *   containing string key/value pairs that are stored in saved game
<a name="189"></a>     *   files, providing descriptive information that can be displayed to
<a name="190"></a>     *   the user when browsing a collection of save files.  This is called
<a name="191"></a>     *   each time we execute a SAVE command, so that we store the current
<a name="192"></a>     *   context of the game.
<a name="193"></a>     *
<a name="194"></a>     *   Some interpreters display information from this table when
<a name="195"></a>     *   presenting the user with a list of files for RESTORE.  The
<a name="196"></a>     *   contents of the table are intentionally open-ended to allow for
<a name="197"></a>     *   future extensions, but at the moment, the following keys are
<a name="198"></a>     *   specifically defined (note that capitalization must be exact):
<a name="199"></a>     *
<a name="200"></a>     *   UserDesc - descriptive text entered by the user (this should
<a name="201"></a>     *   simply be the contents of the 'userDesc' parameter).  This is
<a name="202"></a>     *   treated as ordinary plain text (i.e., no HTML or other markups are
<a name="203"></a>     *   interpreted in this text).
<a name="204"></a>     *
<a name="205"></a>     *   AutoDesc - descriptive text generated by the game to describe the
<a name="206"></a>     *   saved position.  This text can contain the simple HTML markups
<a name="207"></a>     *   &lt;b&gt;..&lt;/b&gt;, &lt;i&gt;..&lt;/i&gt;, and &lt;br&gt; for formatting.
<a name="208"></a>     *
<a name="209"></a>     *   Return nil if you don't want to save any metadata information.
<a name="210"></a>     *
<a name="211"></a>     *   'userDesc' is an optional string entered by the user via the Save
<a name="212"></a>     *   Game dialog.  Some interpreters let the user enter a description
<a name="213"></a>     *   for a saved game via the file selector dialog; the descriptive
<a name="214"></a>     *   text is separate from the filename, and is intended to let the
<a name="215"></a>     *   user enter a more free-form description than would be allowed in a
<a name="216"></a>     *   filename.  This text, if any, is passed to use via the 'userDesc'
<a name="217"></a>     *   parameter.
<a name="218"></a>     */
<a name="219"></a>    getSaveDesc(userDesc)
<a name="220"></a>    {
<a name="221"></a>        /* create the lookup table */
<a name="222"></a>        local t = new LookupTable();
<a name="223"></a>
<a name="224"></a>        /* store the user description, if provided */
<a name="225"></a>        if (userDesc != nil)
<a name="226"></a>            t['UserDesc'] = userDesc;
<a name="227"></a>
<a name="228"></a>        /* start our auto description with the current room name */
<a name="229"></a>        desc = gPlayerChar.getLookAroundName() + '; ';
<a name="230"></a>
<a name="231"></a>        /* if we're keeping score, include the score */
<a name="232"></a>        if (libGlobal.scoreObj != nil)
<a name="233"></a>            desc += toString(libGlobal.scoreObj.totalScore) + ' points in ';
<a name="234"></a>
<a name="235"></a>        /* add the number of turns so far */
<a name="236"></a>        desc += toString(libGlobal.totalTurns) + ' moves';
<a name="237"></a>
<a name="238"></a>        /* add the auto description */
<a name="239"></a>        t['AutoDesc'] = desc;
<a name="240"></a>
<a name="241"></a>        /* return the table */
<a name="242"></a>        return t;
<a name="243"></a>    }
<a name="244"></a>
<a name="245"></a>    /*
<a name="246"></a>     *   The gameMain object also specifies some settings that control
<a name="247"></a>     *   optional library behavior.  If you want the standard library
<a name="248"></a>     *   behavior, you can just inherit the default settings from this
<a name="249"></a>     *   class.  Some games might want to select non-default variations,
<a name="250"></a>     *   though.
<a name="251"></a>     */
<a name="252"></a>
<a name="253"></a>    /*
<a name="254"></a>     *   The maximum number of points possible in the game.  If the game
<a name="255"></a>     *   includes the scoring module at all, and this is non-nil, the SCORE
<a name="256"></a>     *   and FULL SCORE commands will display this value to the player as a
<a name="257"></a>     *   rough indication of how much farther there is to go in the game.
<a name="258"></a>     *
<a name="259"></a>     *   By default, we initialize this on demand, by calculating the sum
<a name="260"></a>     *   of the point values of the Achievement objects in the game.  The
<a name="261"></a>     *   game can override this if needed to specify a specific maximum
<a name="262"></a>     *   possible score, rather than relying on the automatic calculation.
<a name="263"></a>     */
<a name="264"></a>    maxScore()
<a name="265"></a>    {
<a name="266"></a>        local m;
<a name="267"></a>
<a name="268"></a>        /* ask the score module (if any) to compute the maximum score */
<a name="269"></a>        m = (libGlobal.scoreObj != nil
<a name="270"></a>             ? libGlobal.scoreObj.calcMaxScore : nil);
<a name="271"></a>
<a name="272"></a>        /* supersede this initializer with the calculated value */
<a name="273"></a>        maxScore = m;
<a name="274"></a>
<a name="275"></a>        /* return the result */
<a name="276"></a>        return m;
<a name="277"></a>    }
<a name="278"></a>
<a name="279"></a>    /*
<a name="280"></a>     *   The score ranking list - this provides a list of names for
<a name="281"></a>     *   various score levels.  If the game provides a non-nil list here,
<a name="282"></a>     *   the SCORE and FULL SCORE commands will show the rank along with
<a name="283"></a>     *   the score ("This makes you a Master Adventurer").
<a name="284"></a>     *
<a name="285"></a>     *   This is a list of score entries.  Each score entry is itself a
<a name="286"></a>     *   list of two elements: the first element is the minimum score for
<a name="287"></a>     *   the rank, and the second is a string describing the rank.  The
<a name="288"></a>     *   ranks should be given in ascending order, since we simply search
<a name="289"></a>     *   the list for the first item whose minimum score is greater than
<a name="290"></a>     *   our score, and use the preceding item.  The first entry in the
<a name="291"></a>     *   list would normally have a minimum of zero points, since it
<a name="292"></a>     *   should give the initial, lowest rank.
<a name="293"></a>     *
<a name="294"></a>     *   If this is set to nil, which it is by default, we'll simply skip
<a name="295"></a>     *   score ranks entirely.
<a name="296"></a>     */
<a name="297"></a>    scoreRankTable = nil
<a name="298"></a>
<a name="299"></a>    /*
<a name="300"></a>     *   Verbose mode.  If this is on, the full room description is
<a name="301"></a>     *   displayed each time the player enters a room, regardless of
<a name="302"></a>     *   whether or not the player has seen the room before; if this is
<a name="303"></a>     *   nil, the full description is only displayed on the player's first
<a name="304"></a>     *   entry to a room, and only the short description on re-entry.  Note
<a name="305"></a>     *   that the library provides VERBOSE and TERSE commands that let the
<a name="306"></a>     *   player change this setting dynamically.
<a name="307"></a>     *
<a name="308"></a>     *   We use a BinarySettingsItem to store the current mode, so that
<a name="309"></a>     *   this setting's default will be taken from the user's global
<a name="310"></a>     *   cross-game preferences.
<a name="311"></a>     */
<a name="312"></a>    verboseMode = verboseModeSettingsItem
<a name="313"></a>
<a name="314"></a>    /*
<a name="315"></a>     *   Option flag: allow the player to use "you" and "me"
<a name="316"></a>     *   interchangeably in referring to the player character.  We set this
<a name="317"></a>     *   true by default, so that the player can refer to the player
<a name="318"></a>     *   character in either the first or second person, regardless of how
<a name="319"></a>     *   the game refers to the PC.
<a name="320"></a>     *
<a name="321"></a>     *   If desired, the game can set this flag to nil to force the player
<a name="322"></a>     *   to use the correct pronoun to refer to the player character.  We
<a name="323"></a>     *   define "correct" in the case of first or second person as the
<a name="324"></a>     *   complement of what the game uses: if the game calls the PC "me",
<a name="325"></a>     *   the player must say "you", and vice versa.  In a third-person
<a name="326"></a>     *   game, the player must also refer to the PC in the third person.
<a name="327"></a>     *
<a name="328"></a>     *   We set the default to allow using "you" and "me" interchangeably
<a name="329"></a>     *   because (a) this will create no confusion in most games, and (b)
<a name="330"></a>     *   many players would be annoyed otherwise.  For one thing, most
<a name="331"></a>     *   experienced IF players will be rather set in their ways; they'll
<a name="332"></a>     *   be accustomed to using either "me" or "you" (but usually "me") to
<a name="333"></a>     *   refer to the PC, and will tend out of habit to do so even in games
<a name="334"></a>     *   that don't use the traditional second-person narration format.
<a name="335"></a>     *   For another thing, different players have different ideas about
<a name="336"></a>     *   whether the PC is "you" or "me" in input, even in a conventional
<a name="337"></a>     *   second-person game.  Some players think in terms of a conversation
<a name="338"></a>     *   with the narrator, in which case the narrator's "you" is the
<a name="339"></a>     *   player's "me", and vice versa; other players are rather more
<a name="340"></a>     *   literal-minded, assuming that if the game talks about "you" then
<a name="341"></a>     *   so should the player.
<a name="342"></a>     *
<a name="343"></a>     *   Even in games that use first-person or third-person narration, it
<a name="344"></a>     *   seems unlikely that there will be a separate second-person element
<a name="345"></a>     *   to the narration, and as long as that's true, it should cause no
<a name="346"></a>     *   confusion for the game to accept "you" and "me" as equivalent in
<a name="347"></a>     *   commands.  However, the library provides this option in case such
<a name="348"></a>     *   as situation does arise.
<a name="349"></a>     */
<a name="350"></a>    allowYouMeMixing = true
<a name="351"></a>
<a name="352"></a>    /*
<a name="353"></a>     *   Option flag: filter plural phrase matches exclude the most obvious
<a name="354"></a>     *   illogicalities, such as trying to TAKE an object that's already
<a name="355"></a>     *   being held, or trying to OPEN an object that's already open.
<a name="356"></a>     *
<a name="357"></a>     *   This is set to true by default, which means that we exclude an
<a name="358"></a>     *   object from matching a plural phrase when the object's "verify"
<a name="359"></a>     *   routine for the verb has an "illogical-already" or an
<a name="360"></a>     *   "illogical-self" result.
<a name="361"></a>     *
<a name="362"></a>     *   If you would prefer that plural words are simply matched to
<a name="363"></a>     *   everything present that matches the vocabulary, without any
<a name="364"></a>     *   filtering at all, override this and set it to nil.
<a name="365"></a>     */
<a name="366"></a>    filterPluralMatches = true
<a name="367"></a>
<a name="368"></a>    /*
<a name="369"></a>     *   Option flag: allow ALL to be used for every verb.  This is true by
<a name="370"></a>     *   default, which means that players will be allowed to use ALL with
<a name="371"></a>     *   any command - OPEN ALL, EXAMINE ALL, etc.
<a name="372"></a>     *
<a name="373"></a>     *   Some authors don't like to allow players to use ALL with so many
<a name="374"></a>     *   verbs, because they think it's a sort of "cheating" when players
<a name="375"></a>     *   try things like OPEN ALL.  This option lets you disable ALL for
<a name="376"></a>     *   most verbs; if you set this to nil, only the basic inventory
<a name="377"></a>     *   management verbs (TAKE, TAKE FROM, DROP, PUT IN, PUT ON) will
<a name="378"></a>     *   allow ALL, and other verbs will simply respond with an error
<a name="379"></a>     *   ("'All' isn't allowed with that verb").
<a name="380"></a>     *
<a name="381"></a>     *   If you're writing an especially puzzle-oriented game, you might
<a name="382"></a>     *   want to set this to nil.  It's a trade-off though, as some people
<a name="383"></a>     *   will think your game is less player-friendly if you disable ALL.
<a name="384"></a>     */
<a name="385"></a>    allVerbsAllowAll = true
<a name="386"></a>
<a name="387"></a>    /*
<a name="388"></a>     *   When a command fails, should we continue processing any remaining
<a name="389"></a>     *   commands on the same command line, or simply ignore them?  The
<a name="390"></a>     *   reason we might want to ignore additional commands is that they
<a name="391"></a>     *   might not do what the player was expecting if an earlier command
<a name="392"></a>     *   failed; this can sometimes create confusing situations, because
<a name="393"></a>     *   the player expected one effect but got something quite different.
<a name="394"></a>     *   On the other hand, *not* executing all the commands on the command
<a name="395"></a>     *   line could be confusing in its own way, since the game's
<a name="396"></a>     *   assessment of what constitutes "failure" might not be clear to the
<a name="397"></a>     *   player; from the player's perspective, the game might appear to be
<a name="398"></a>     *   inexplicably skipping commands.
<a name="399"></a>     *
<a name="400"></a>     *   There's no perfect solution.  As always, the ideal is to
<a name="401"></a>     *   understand the player's intentions and act accordingly.  But when
<a name="402"></a>     *   a command fails, it's usually because the player's idea of what's
<a name="403"></a>     *   going on is out of sync with the game's - in other words, if we're
<a name="404"></a>     *   in this situation to start with, it's probably because our best
<a name="405"></a>     *   effort to understand the player's intentions has already failed.
<a name="406"></a>     *   This isn't always the case; sometimes we understand the player's
<a name="407"></a>     *   intentions perfectly well, but the command fails anyway because of
<a name="408"></a>     *   some surprising new development.  In these cases, aborting the
<a name="409"></a>     *   rest of the command is arguably the right approach, because the
<a name="410"></a>     *   player will need a chance to reconsider the pre-typed commands in
<a name="411"></a>     *   light of the new information.  In other cases, though, it's not so
<a name="412"></a>     *   clear.  For many players, the prime virtue for the parser is to be
<a name="413"></a>     *   predictable, and the most predictable thing to do is to simply
<a name="414"></a>     *   plow through the rest of the command line in all cases.
<a name="415"></a>     *
<a name="416"></a>     *   Our traditional approach (from the early adv3 versions, and even
<a name="417"></a>     *   in tads 2) has been the simple-minded approach - just keep going
<a name="418"></a>     *   in all cases.  So, we make this the default.  You can abort
<a name="419"></a>     *   remaining commands on a command failure by setting this to true.
<a name="420"></a>     */
<a name="421"></a>    cancelCmdLineOnFailure = nil
<a name="422"></a>
<a name="423"></a>    /*
<a name="424"></a>     *   Should we use distinguishers when generating action object
<a name="425"></a>     *   announcement messages?  If this is set, announcement messages that
<a name="426"></a>     *   list objects by name will add distinguishing details to indicate
<a name="427"></a>     *   specifically which objects are being referred to.  This applies to
<a name="428"></a>     *   messages announcing default objects, vaguely matched objects, and
<a name="429"></a>     *   multiple objects.
<a name="430"></a>     *
<a name="431"></a>     *   A distinguisher is a parser object that tells two objects apart by
<a name="432"></a>     *   some feature that's different in the two objects.  The key thing
<a name="433"></a>     *   is that the difference has some natural language phrasing
<a name="434"></a>     *   associated with it, both on the input side and the output side.
<a name="435"></a>     *   For example, the locational distinguisher can tell two objects
<a name="436"></a>     *   apart if they have different containers, since it can describe the
<a name="437"></a>     *   objects by adding containment phrases like "in the box" or "on the
<a name="438"></a>     *   table".
<a name="439"></a>     *
<a name="440"></a>     *   When this flag is turned on, the parser will try to pick a
<a name="441"></a>     *   distinguisher that can tell apart the specific objects mentioned
<a name="442"></a>     *   in the announcement, from one another or from other objects in
<a name="443"></a>     *   scope, depending on the context.  The point is to help make it
<a name="444"></a>     *   clearer to the player the exact objects being referred to.
<a name="445"></a>     *
<a name="446"></a>     *   Even when this flag is set, the parser tries to minimize the use
<a name="447"></a>     *   of additional distinguishing detail.  The goal is to be natural in
<a name="448"></a>     *   the usage, adding detail only when a human speaker would, which is
<a name="449"></a>     *   when the phrasing would otherwise be ambiguous.
<a name="450"></a>     *
<a name="451"></a>     *   Setting this flag to nil makes the parser simply use the basic
<a name="452"></a>     *   name of each object in an announcement.  You can use this setting
<a name="453"></a>     *   if you find that the distinguisher mode generates too much fussy
<a name="454"></a>     *   detail for your taste.
<a name="455"></a>     */
<a name="456"></a>    useDistinguishersInAnnouncements = true
<a name="457"></a>
<a name="458"></a>    /*
<a name="459"></a>     *   How should we handle object announcements when an object is
<a name="460"></a>     *   automatically disambiguated?  This controls how an action is
<a name="461"></a>     *   described when the parser uses the logicalness rules to narrow
<a name="462"></a>     *   down the object for a noun phrase when the noun phrase could refer
<a name="463"></a>     *   to multiple in-scope objects.  There are three options:
<a name="464"></a>     *
<a name="465"></a>     *   AnnounceUnclear - Make a parenthetical announcement only when the
<a name="466"></a>     *   choice is *not* clear (as described below).  This is the original
<a name="467"></a>     *   library behavior, from before this option was added.
<a name="468"></a>     *
<a name="469"></a>     *   AnnounceClear - Make a parenthetical announcement (for example,
<a name="470"></a>     *   "(the red door)") for all disambiguated objects, whether clear or
<a name="471"></a>     *   unclear.  We don't make an announcement when there's only one
<a name="472"></a>     *   in-scope object matching the noun phrase - the announcement is
<a name="473"></a>     *   only when multiple objects match the words.
<a name="474"></a>     *
<a name="475"></a>     *   DescribeClear - For *unclear* disambiguation, make a parenthetical
<a name="476"></a>     *   announcement, to emphasize that the parser had to make a choice.
<a name="477"></a>     *   For *clear* disambiguation, skip the announcement, but *do* use a
<a name="478"></a>     *   verbose version of the library message in place of one of the
<a name="479"></a>     *   terse default replies.  For example, for &gt;TAKE BOX, instead of
<a name="480"></a>     *   "Taken", we would reply "You take the green box."  The longer
<a name="481"></a>     *   reply in these cases always mentions the involved object by name,
<a name="482"></a>     *   to make it clear exactly which object we chose to use.
<a name="483"></a>     *
<a name="484"></a>     *   The default setting is DescribeClear.
<a name="485"></a>     *
<a name="486"></a>     *   This only applies when the disambiguation choice is clear - that
<a name="487"></a>     *   is, when there's exactly one in-scope object that passes the
<a name="488"></a>     *   logicalness tests.  For example, if the current location contains
<a name="489"></a>     *   a red door that's open and a green door that's closed, CLOSE DOOR
<a name="490"></a>     *   clearly refers to the red door because the other one is already
<a name="491"></a>     *   closed - it's not logical.  There are other cases where the
<a name="492"></a>     *   disambiguation is a best guess rather than a clear choice, such as
<a name="493"></a>     *   when there are multiple logical objects but there's one that's
<a name="494"></a>     *   more likely than the others due to the logicalRank results.  In
<a name="495"></a>     *   those best-guess situations, the parser always announces its
<a name="496"></a>     *   decision, because it's entirely plausible that the player meant
<a name="497"></a>     *   one of the other logical, but less likely, choices.
<a name="498"></a>     */
<a name="499"></a>    ambigAnnounceMode = DescribeClear
<a name="500"></a>
<a name="501"></a>    /*
<a name="502"></a>     *   Should the "before" notifications (beforeAction, roomBeforeAction,
<a name="503"></a>     *   and actorAction) run before or after the "check" phase?
<a name="504"></a>     *
<a name="505"></a>     *   The library traditionally ran the "before" notifiers first, so
<a name="506"></a>     *   this is the default.  However, in many ways it's more logical and
<a name="507"></a>     *   useful to run "check" first.  That way, you can consider the
<a name="508"></a>     *   action to be more or less committed by the time the "before"
<a name="509"></a>     *   notifiers are invoked.  Of course, a command is never *truly*
<a name="510"></a>     *   committed until it's actually been executed, since a "before"
<a name="511"></a>     *   handler could always cancel it.  But this is relatively rare -
<a name="512"></a>     *   "before" handlers usually carry out side effects, so it's very
<a name="513"></a>     *   useful to be able to know that the command has already passed all
<a name="514"></a>     *   of its own internal checks by the time "before" is invoked - that
<a name="515"></a>     *   way, you can invoke side effects without worrying that the command
<a name="516"></a>     *   will subsequently fail.
<a name="517"></a>     */
<a name="518"></a>    beforeRunsBeforeCheck = true
<a name="519"></a>;
<a name="520"></a>
<a name="521"></a>/*
<a name="522"></a> *   The VERBOSE mode settings item.
<a name="523"></a> */
<a name="524"></a>verboseModeSettingsItem: BinarySettingsItem
<a name="525"></a>    /* VERBOSE mode is on by default */
<a name="526"></a>    isOn = true
<a name="527"></a>
<a name="528"></a>    /* our configuration file variable ID */
<a name="529"></a>    settingID = 'adv3.verbose'
<a name="530"></a>
<a name="531"></a>    /* show our description */
<a name="532"></a>    settingDesc = (gLibMessages.shortVerboseStatus(isOn))
<a name="533"></a>;
<a name="534"></a>
<a name="535"></a>/* ------------------------------------------------------------------------ */
<a name="536"></a>/*
<a name="537"></a> *   Clear the main game window.  In most cases, you should call this
<a name="538"></a> *   rather than calling the low-level clearScreen() function directly,
<a name="539"></a> *   since this routine takes care of a couple of chores that should
<a name="540"></a> *   usually be done at the same time.
<a name="541"></a> *
<a name="542"></a> *   First, we flush the transcript to ensure that no left-over reports
<a name="543"></a> *   that were displayed before we cleared the screen will show up on the
<a name="544"></a> *   new screen.  Second, we call the low-level clearScreen() function to
<a name="545"></a> *   actually clear the display window.  Finally, we re-display any
<a name="546"></a> *   &lt;ABOUTBOX&gt; tag, to ensure that the about-box will still be around;
<a name="547"></a> *   this is necessary because any existing &lt;ABOUTBOX&gt; tag is lost after
<a name="548"></a> *   the screen is cleared.
<a name="549"></a> */
<a name="550"></a>cls()
<a name="551"></a>{
<a name="552"></a>    /* flush any captured transcript output */
<a name="553"></a>    if (gTranscript != nil)
<a name="554"></a>        gTranscript.flushForInput();
<a name="555"></a>
<a name="556"></a>    /* clear the screen */
<a name="557"></a>    aioClearScreen();
<a name="558"></a>}
<a name="559"></a>
<a name="560"></a>/* ------------------------------------------------------------------------ */
<a name="561"></a>/*
<a name="562"></a> *   Run the game.  We start by showing the description of the initial
<a name="563"></a> *   location, if desired, and then we read and interpret commands until
<a name="564"></a> *   the game ends (via a "quit" command, winning, death of the player
<a name="565"></a> *   character, or any other way of terminating the game).
<a name="566"></a> *
<a name="567"></a> *   This routine doesn't return until the game ends.
<a name="568"></a> *
<a name="569"></a> *   Before calling this routine, the caller should already have set the
<a name="570"></a> *   global variable gPlayerChar to the player character actor.
<a name="571"></a> *
<a name="572"></a> *   'look' is a flag indicating whether or not to look around; if this is
<a name="573"></a> *   true, we'll show a full description of the player character's initial
<a name="574"></a> *   location, as though the player were to type "look around" as the first
<a name="575"></a> *   command.
<a name="576"></a> */
<a name="577"></a>runGame(look)
<a name="578"></a>{
<a name="579"></a>    /* show the starting location */
<a name="580"></a>    if (look)
<a name="581"></a>    {
<a name="582"></a>        /* run the initial "look around" in a dummy command context */
<a name="583"></a>        withActionEnv(EventAction, gPlayerChar,
<a name="584"></a>                      {: gPlayerChar.lookAround(true) });
<a name="585"></a>    }
<a name="586"></a>
<a name="587"></a>    /* run the scheduling loop until the game ends */
<a name="588"></a>    runScheduler();
<a name="589"></a>}
<a name="590"></a>
<a name="591"></a>/* ------------------------------------------------------------------------ */
<a name="592"></a>/*
<a name="593"></a> *   Main program entrypoint.  The core run-time start-up code calls this
<a name="594"></a> *   after running pre-initialization and load-time initialization.  This
<a name="595"></a> *   entrypoint is called when we're starting the game normally; when the
<a name="596"></a> *   game is launched through a saved-position file, mainRestore() will be
<a name="597"></a> *   invoked instead.
<a name="598"></a> */
<a name="599"></a>main(args)
<a name="600"></a>{
<a name="601"></a>    libGlobal.commandLineArgs = args;
<a name="602"></a>    mainCommon(&amp;newGame);
<a name="603"></a>}
<a name="604"></a>
<a name="605"></a>/*
<a name="606"></a> *   Main program entrypoint for restoring a saved-position file.  This is
<a name="607"></a> *   invoked from the core run-time start-up code when the game is launched
<a name="608"></a> *   from the operating system via a saved-position file.  For example, on
<a name="609"></a> *   Windows, double-clicking on a saved-position file on the Windows
<a name="610"></a> *   desktop launches the interpreter, which looks in the save file to find
<a name="611"></a> *   the game executable to run, then starts the game and invokes this
<a name="612"></a> *   entrypoint.
<a name="613"></a> */
<a name="614"></a>mainRestore(args, restoreFile)
<a name="615"></a>{
<a name="616"></a>    libGlobal.commandLineArgs = args;
<a name="617"></a>    mainCommon(&amp;restoreAndRunGame, restoreFile);
<a name="618"></a>}
<a name="619"></a>
<a name="620"></a>/*
<a name="621"></a> *   Common main entrypoint - this handles starting a new game or restoring
<a name="622"></a> *   an existing saved state.
<a name="623"></a> */
<a name="624"></a>mainCommon(prop, [args])
<a name="625"></a>{
<a name="626"></a>    try
<a name="627"></a>    {
<a name="628"></a>        /* restore the global default settings */
<a name="629"></a>        settingsManager.restoreSettings();
<a name="630"></a>    }
<a name="631"></a>    catch (Exception exc)
<a name="632"></a>    {
<a name="633"></a>        /*
<a name="634"></a>         *   ignore any errors restoring defaults - it's not critical that
<a name="635"></a>         *   we restore this file automatically
<a name="636"></a>         */
<a name="637"></a>    }
<a name="638"></a>
<a name="639"></a>    try
<a name="640"></a>    {
<a name="641"></a>        /* at the start of the session, set up the UI subsystem */
<a name="642"></a>        if (mainGlobal.restartID == 0)
<a name="643"></a>        {
<a name="644"></a>            /* initialize the UI */
<a name="645"></a>            initUI();
<a name="646"></a>
<a name="647"></a>            /*
<a name="648"></a>             *   tell the system library to call our UI shutdown function
<a name="649"></a>             *   at program exit
<a name="650"></a>             */
<a name="651"></a>            mainAtExit.addHandler(terminateUI);
<a name="652"></a>        }
<a name="653"></a>
<a name="654"></a>        /* initialize the display */
<a name="655"></a>        initDisplay();
<a name="656"></a>
<a name="657"></a>        /* call the appropriate gameMain method */
<a name="658"></a>        gameMain.(prop)(args...);
<a name="659"></a>    }
<a name="660"></a>    catch (QuittingException q)
<a name="661"></a>    {
<a name="662"></a>        /*
<a name="663"></a>         *   This exception is a signal to quit the game, which we will now
<a name="664"></a>         *   proceed to do by returning from this function, which exits the
<a name="665"></a>         *   program.
<a name="666"></a>         */
<a name="667"></a>    }
<a name="668"></a>}
<a name="669"></a>
<a name="670"></a>/* ------------------------------------------------------------------------ */
<a name="671"></a>/*
<a name="672"></a> *   Determine if the given object overrides the definition of the given
<a name="673"></a> *   property inherited from the given base class.  Returns true if the
<a name="674"></a> *   object derives from the given base class, and the object's definition
<a name="675"></a> *   of the property comes from a different place than the base class's
<a name="676"></a> *   definition of the property.
<a name="677"></a> */
<a name="678"></a>overrides(obj, base, prop)
<a name="679"></a>{
<a name="680"></a>    return (obj.ofKind(base)
<a name="681"></a>            &amp;&amp; (obj.propDefined(prop, PropDefGetClass)
<a name="682"></a>                != base.propDefined(prop, PropDefGetClass)));
<a name="683"></a>}
<a name="684"></a>
<a name="685"></a>/* ------------------------------------------------------------------------ */
<a name="686"></a>/*
<a name="687"></a> *   Library Pre-Initializer.  This object performs the following
<a name="688"></a> *   initialization operations immediately after compilation is completed:
<a name="689"></a> *
<a name="690"></a> *   - adds each defined Thing to its container's contents list
<a name="691"></a> *
<a name="692"></a> *   - adds each defined Sense to the global sense list
<a name="693"></a> *
<a name="694"></a> *   This object is named so that other libraries and/or user code can
<a name="695"></a> *   create initialization order dependencies upon it.
<a name="696"></a> */
<a name="697"></a>adv3LibPreinit: PreinitObject
<a name="698"></a>    execute()
<a name="699"></a>    {
<a name="700"></a>        /* save each SettingsItem's factory default settings */
<a name="701"></a>        forEachInstance(SettingsItem,
<a name="702"></a>                        {i: i.factoryDefault = i.settingToText()});
<a name="703"></a>
<a name="704"></a>        /* set the initial player character, as specified in gameMain */
<a name="705"></a>        gPlayerChar = gameMain.initialPlayerChar;
<a name="706"></a>
<a name="707"></a>        /*
<a name="708"></a>         *   visit every VocabObject, and run its vocabulary initializer
<a name="709"></a>         *   (this routine will be defined in the language-specific part
<a name="710"></a>         *   of the library to enter each object's vocabulary words into
<a name="711"></a>         *   the dictionary)
<a name="712"></a>         */
<a name="713"></a>        forEachInstance(VocabObject, { obj: obj.initializeVocab() });
<a name="714"></a>
<a name="715"></a>        /* visit every Thing, and run its general initializer */
<a name="716"></a>        forEachInstance(Thing, { obj: obj.initializeThing() });
<a name="717"></a>
<a name="718"></a>        /* initialize SpecialTopic objects */
<a name="719"></a>        forEachInstance(SpecialTopic, { obj: obj.initializeSpecialTopic() });
<a name="720"></a>
<a name="721"></a>        /*
<a name="722"></a>         *   Initialize each MultiInstance object.  Do this after
<a name="723"></a>         *   initializing the Thing objects, because we'll be dynamically
<a name="724"></a>         *   constructing new Thing objects for the instances.  Those new
<a name="725"></a>         *   Things will be initialized by their constructors, so we don't
<a name="726"></a>         *   want to initialize them redundantly with explicit
<a name="727"></a>         *   initializeThing calls.
<a name="728"></a>         */
<a name="729"></a>        forEachInstance(MultiInstance, { obj: obj.initializeLocation() });
<a name="730"></a>
<a name="731"></a>        /* add every Sense to the global sense list */
<a name="732"></a>        forEachInstance(Sense, { obj: libGlobal.allSenses += obj });
<a name="733"></a>
<a name="734"></a>        /*
<a name="735"></a>         *   initialize each ActorState - do this before initializing
<a name="736"></a>         *   actors, since we want each actor's initial state to plug
<a name="737"></a>         *   itself into its actor before we initialize the actors
<a name="738"></a>         */
<a name="739"></a>        forEachInstance(ActorState, { obj: obj.initializeActorState() });
<a name="740"></a>
<a name="741"></a>        /* initialize each Actor */
<a name="742"></a>        forEachInstance(Actor, { obj: obj.initializeActor() });
<a name="743"></a>
<a name="744"></a>        /*
<a name="745"></a>         *   initialize the AltTopics first, to set up their parents' lists
<a name="746"></a>         *   of their AltTopic children
<a name="747"></a>         */
<a name="748"></a>        forEachInstance(AltTopic, { obj: obj.initializeAltTopic() });
<a name="749"></a>
<a name="750"></a>        /* initialize the topic database entries */
<a name="751"></a>        forEachInstance(TopicEntry, { obj: obj.initializeTopicEntry() });
<a name="752"></a>
<a name="753"></a>        /* initialize the suggested topics */
<a name="754"></a>        forEachInstance(SuggestedTopic,
<a name="755"></a>            { obj: obj.initializeSuggestedTopic() });
<a name="756"></a>
<a name="757"></a>        /* initialize the master direction list */
<a name="758"></a>        Direction.initializeDirectionClass();
<a name="759"></a>
<a name="760"></a>        /* initialize the noise/odor notification daemon */
<a name="761"></a>        local d = new Daemon(SensoryEmanation, &amp;noteSenseChanges, 1);
<a name="762"></a>
<a name="763"></a>        /*
<a name="764"></a>         *   give it a later-than-default event order, so that it runs
<a name="765"></a>         *   after most other daemons and fuses
<a name="766"></a>         */
<a name="767"></a>        d.eventOrder = 500;
<a name="768"></a>
<a name="769"></a>        /* set up a daemon for the current location */
<a name="770"></a>        new Daemon(BasicLocation, &amp;dispatchRoomDaemon, 1);
<a name="771"></a>
<a name="772"></a>        /*
<a name="773"></a>         *   Initialize the status line daemon.  Set this daemon's event
<a name="774"></a>         *   order to a high value so that it runs last, after all other
<a name="775"></a>         *   daemons - we want this to be the last prompt daemon so that
<a name="776"></a>         *   the status line is updated after any other daemons have done
<a name="777"></a>         *   their jobs already, in case any of them move the player
<a name="778"></a>         *   character to a new location or affect the score, or make any
<a name="779"></a>         *   other changes that should be reflected on the status line.
<a name="780"></a>         */
<a name="781"></a>        local sld = new PromptDaemon(statusLine, &amp;showStatusLineDaemon);
<a name="782"></a>        sld.eventOrder = 1000;
<a name="783"></a>
<a name="784"></a>        /*
<a name="785"></a>         *   Attach the command sequencer output filter, the
<a name="786"></a>         *   language-specific message parameter substitution filter, the
<a name="787"></a>         *   style tag formatter filter, and the paragraph filter to the
<a name="788"></a>         *   main output stream.  Stack them so that the paragraph manager
<a name="789"></a>         *   is at the bottom, since the library tag filter can produce
<a name="790"></a>         *   paragraph tags and thus needs to sit atop the paragraph
<a name="791"></a>         *   filter.  Put the command sequencer above those, since it
<a name="792"></a>         *   might need to write style tags.  Finally, put the sense
<a name="793"></a>         *   context filter on top of those.
<a name="794"></a>         */
<a name="795"></a>        mainOutputStream.addOutputFilter(typographicalOutputFilter);
<a name="796"></a>        mainOutputStream.addOutputFilter(mainParagraphManager);
<a name="797"></a>        mainOutputStream.addOutputFilter(styleTagFilter);
<a name="798"></a>        mainOutputStream.addOutputFilter(langMessageBuilder);
<a name="799"></a>        mainOutputStream.addOutputFilter(commandSequencer);
<a name="800"></a>        mainOutputStream.addOutputFilter(conversationManager);
<a name="801"></a>        mainOutputStream.addOutputFilter(senseContext);
<a name="802"></a>
<a name="803"></a>        /*
<a name="804"></a>         *   Attach our message parameter filter and style tag filter to
<a name="805"></a>         *   the status line streams.  We don't need most of the main
<a name="806"></a>         *   window's filters in the status line.
<a name="807"></a>         */
<a name="808"></a>        statusTagOutputStream.addOutputFilter(styleTagFilter);
<a name="809"></a>        statusTagOutputStream.addOutputFilter(langMessageBuilder);
<a name="810"></a>
<a name="811"></a>        statusLeftOutputStream.addOutputFilter(styleTagFilter);
<a name="812"></a>        statusLeftOutputStream.addOutputFilter(langMessageBuilder);
<a name="813"></a>
<a name="814"></a>        statusRightOutputStream.addOutputFilter(styleTagFilter);
<a name="815"></a>        statusRightOutputStream.addOutputFilter(langMessageBuilder);
<a name="816"></a>    }
<a name="817"></a>
<a name="818"></a>    /*
<a name="819"></a>     *   Make sure the output streams we depend on are initialized before
<a name="820"></a>     *   me (so that they set up properly internally).  Also, make sure
<a name="821"></a>     *   that the message builder object (langMessageBuilder) is set up
<a name="822"></a>     *   first, so that we can add entries to its parameter substitution
<a name="823"></a>     *   table.
<a name="824"></a>     */
<a name="825"></a>    execBeforeMe = [mainOutputStream, statusTagOutputStream,
<a name="826"></a>                    statusLeftOutputStream, statusRightOutputStream,
<a name="827"></a>                    langMessageBuilder]
<a name="828"></a>;
<a name="829"></a>
<a name="830"></a>/* ------------------------------------------------------------------------ */
<a name="831"></a>/*
<a name="832"></a> *   Library Initializer.  This object performs the following
<a name="833"></a> *   initialization operations each time the game is started:
<a name="834"></a> *
<a name="835"></a> *   - sets up the library's default output function
<a name="836"></a> */
<a name="837"></a>adv3LibInit: InitObject
<a name="838"></a>    execute()
<a name="839"></a>    {
<a name="840"></a>        /*
<a name="841"></a>         *   Set up our default output function.  Note that we must do
<a name="842"></a>         *   this during run-time initialization each time we start the
<a name="843"></a>         *   game, rather than during pre-initialization, because the
<a name="844"></a>         *   default output function state is not part of the load-image
<a name="845"></a>         *   configuration.
<a name="846"></a>         */
<a name="847"></a>        t3SetSay(say);
<a name="848"></a>    }
<a name="849"></a>;
<a name="850"></a>
<a name="851"></a>
<a name="852"></a>/* ------------------------------------------------------------------------ */
<a name="853"></a>/*
<a name="854"></a> *   Generic script object.  This class can be used to implement a simple
<a name="855"></a> *   state machine.
<a name="856"></a> */
<a name="857"></a>class Script: object
<a name="858"></a>    /*
<a name="859"></a>     *   Get the current state.  This returns a value that gives the
<a name="860"></a>     *   current state of the script, which is usually simply an integer.
<a name="861"></a>     */
<a name="862"></a>    getScriptState()
<a name="863"></a>    {
<a name="864"></a>        /* by default, return our state property */
<a name="865"></a>        return curScriptState;
<a name="866"></a>    }
<a name="867"></a>
<a name="868"></a>    /*
<a name="869"></a>     *   Process the next step of the script.  This routine must be
<a name="870"></a>     *   overridden to perform the action of the script.  This routine's
<a name="871"></a>     *   action should call getScriptState() to get our current state, and
<a name="872"></a>     *   should update the internal state appropriately to take us to the
<a name="873"></a>     *   next step after the current one.
<a name="874"></a>     *
<a name="875"></a>     *   By default, we don't do anything at all.
<a name="876"></a>     */
<a name="877"></a>    doScript()
<a name="878"></a>    {
<a name="879"></a>        /* override to carry out the script */
<a name="880"></a>    }
<a name="881"></a>
<a name="882"></a>    /*
<a name="883"></a>     *   Property giving our current state.  This should never be used
<a name="884"></a>     *   directly; instead, getScriptState() should always be used, since
<a name="885"></a>     *   getScriptState() can be overridden so that the state depends on
<a name="886"></a>     *   something other than this internal state property. The meaning of
<a name="887"></a>     *   the state identifier is specific to each subclass.
<a name="888"></a>     */
<a name="889"></a>    curScriptState = 0
<a name="890"></a>;
<a name="891"></a>
<a name="892"></a>/*
<a name="893"></a> *   Random-Firing script add-in.  This is a mix-in class that you can add
<a name="894"></a> *   to the superclass list of any Script subclass to make the script
<a name="895"></a> *   execute only a given percentage of the time it's invoked.  Each time
<a name="896"></a> *   doScript() is invoked on the script, we'll look at the probability
<a name="897"></a> *   settings (see the properties below) to determine whether we really
<a name="898"></a> *   want to execute the script this time; if so, we'll proceed with the
<a name="899"></a> *   scripted event, otherwise we'll just return immediately, doing
<a name="900"></a> *   nothing.
<a name="901"></a> *
<a name="902"></a> *   Note that this must be used in the superclass list *before* the Script
<a name="903"></a> *   subclass:
<a name="904"></a> *
<a name="905"></a> *   myScript: RandomFiringScript, EventList
<a name="906"></a> *.    // ...my definitions...
<a name="907"></a> *.  ;
<a name="908"></a> *
<a name="909"></a> *   This class is especially useful for random atmospheric events, because
<a name="910"></a> *   it allows you to make the timing of scripted events random.  Rather
<a name="911"></a> *   than making a scripted event happen on every single turn, you can use
<a name="912"></a> *   this to make events happen only sporadically.  It can often feel too
<a name="913"></a> *   predictable and repetitious when a random background event happens on
<a name="914"></a> *   every single turn; firing events less frequently often makes them feel
<a name="915"></a> *   more realistic.
<a name="916"></a> */
<a name="917"></a>class RandomFiringScript: object
<a name="918"></a>    /*
<a name="919"></a>     *   Percentage of the time an event occurs.  By default, we execute an
<a name="920"></a>     *   event 100% of the time - meaning every time that doScript() is
<a name="921"></a>     *   invoked.  If you set this to a lower percentage, then each time
<a name="922"></a>     *   doScript() is invoked, we'll randomly decide whether or not to
<a name="923"></a>     *   execute an event based on this percentage.  For example, if you
<a name="924"></a>     *   want an event to execute on average about a third of the time, set
<a name="925"></a>     *   this to 33.
<a name="926"></a>     *
<a name="927"></a>     *   Note that this is a probabilistic frequency.  Setting this to 33
<a name="928"></a>     *   does *not* mean that we'll execute exactly every third time.
<a name="929"></a>     *   Rather, it means that we'll randomly execute or not on each
<a name="930"></a>     *   invocation, and averaged over a large number of invocations, we'll
<a name="931"></a>     *   execute about a third of the time.
<a name="932"></a>     */
<a name="933"></a>    eventPercent = 100
<a name="934"></a>
<a name="935"></a>    /*
<a name="936"></a>     *   Random atmospheric events can get repetitive after a while, so we
<a name="937"></a>     *   provide an easy way to reduce the frequency of our events after a
<a name="938"></a>     *   while.  This way, we'll generate the events more frequently at
<a name="939"></a>     *   first, but once the player has seen them enough to get the idea,
<a name="940"></a>     *   we'll cut back.  Sometimes, the player will spend a lot of time in
<a name="941"></a>     *   one place trying to solve a puzzle, so the same set of random
<a name="942"></a>     *   events can get stale.  Set eventReduceAfter to the number of times
<a name="943"></a>     *   you want the events to be generated at full frequency; after we've
<a name="944"></a>     *   fired events that many times, we'll change eventPercent to
<a name="945"></a>     *   eventReduceTo.  If eventReduceAfter is nil, we won't ever change
<a name="946"></a>     *   eventPercent.
<a name="947"></a>     */
<a name="948"></a>    eventReduceAfter = nil
<a name="949"></a>    eventReduceTo = nil
<a name="950"></a>
<a name="951"></a>    /*
<a name="952"></a>     *   When doScript() is invoked, check the event probabilities before
<a name="953"></a>     *   proceeding.
<a name="954"></a>     */
<a name="955"></a>    doScript()
<a name="956"></a>    {
<a name="957"></a>        /* process the script step only if the event odds allow it */
<a name="958"></a>        if (checkEventOdds())
<a name="959"></a>            inherited();
<a name="960"></a>    }
<a name="961"></a>
<a name="962"></a>    /*
<a name="963"></a>     *   Check the event odds to see if we want to fire an event at all on
<a name="964"></a>     *   this invocation.
<a name="965"></a>     */
<a name="966"></a>    checkEventOdds()
<a name="967"></a>    {
<a name="968"></a>        /*
<a name="969"></a>         *   check the event odds to see if we fire an event this time; if
<a name="970"></a>         *   not, we're done with the script invocation
<a name="971"></a>         */
<a name="972"></a>        if (rand(100) &gt;= eventPercent)
<a name="973"></a>            return nil;
<a name="974"></a>
<a name="975"></a>        /*
<a name="976"></a>         *   we're firing an event this time, so count this against the
<a name="977"></a>         *   reduction limit, if there is one
<a name="978"></a>         */
<a name="979"></a>        if (eventReduceAfter != nil)
<a name="980"></a>        {
<a name="981"></a>            /* decrement the limit counter */
<a name="982"></a>            --eventReduceAfter;
<a name="983"></a>
<a name="984"></a>            /* if it has reached zero, apply the reduced frequency */
<a name="985"></a>            if (eventReduceAfter == 0)
<a name="986"></a>            {
<a name="987"></a>                /* apply the reduced frequency */
<a name="988"></a>                eventPercent = eventReduceTo;
<a name="989"></a>
<a name="990"></a>                /* we no longer have a limit to look for */
<a name="991"></a>                eventReduceAfter = nil;
<a name="992"></a>            }
<a name="993"></a>        }
<a name="994"></a>
<a name="995"></a>        /* indicate that we do want to fire an event */
<a name="996"></a>        return true;
<a name="997"></a>    }
<a name="998"></a>;
<a name="999"></a>
<a name="1000"></a>/* ------------------------------------------------------------------------ */
<a name="1001"></a>/*
<a name="1002"></a> *   An "event list."  This is a general-purpose type of script that lets
<a name="1003"></a> *   you define the scripted events separately from the Script object.
<a name="1004"></a> *
<a name="1005"></a> *   The script is driven by a list of values; each value represents one
<a name="1006"></a> *   step of the script.  Each value can be a single-quoted string, in
<a name="1007"></a> *   which case the string is simply displayed; a function pointer, in
<a name="1008"></a> *   which case the function is invoked without arguments; another Script
<a name="1009"></a> *   object, in which case the object's doScript() method is invoked; a
<a name="1010"></a> *   property pointer, in which case the property of 'self' (the EventList
<a name="1011"></a> *   object) is invoked with no arguments; or nil, in which case nothing
<a name="1012"></a> *   happens.
<a name="1013"></a> *
<a name="1014"></a> *   This base type of event list runs through the list once, in order, and
<a name="1015"></a> *   then simply stops doing anything once we pass the last event.
<a name="1016"></a> */
<a name="1017"></a>class EventList: Script
<a name="1018"></a>    construct(lst) { eventList = lst; }
<a name="1019"></a>
<a name="1020"></a>    /* the list of events */
<a name="1021"></a>    eventList = []
<a name="1022"></a>
<a name="1023"></a>    /* cached length of the event list */
<a name="1024"></a>    eventListLen = (eventList.length())
<a name="1025"></a>
<a name="1026"></a>    /* advance to the next state */
<a name="1027"></a>    advanceState()
<a name="1028"></a>    {
<a name="1029"></a>        /* increment our state index */
<a name="1030"></a>        ++curScriptState;
<a name="1031"></a>    }
<a name="1032"></a>
<a name="1033"></a>    /* by default, start at the first list element */
<a name="1034"></a>    curScriptState = 1
<a name="1035"></a>
<a name="1036"></a>    /* process the next step of the script */
<a name="1037"></a>    doScript()
<a name="1038"></a>    {
<a name="1039"></a>        /* get our current event state */
<a name="1040"></a>        local idx = getScriptState();
<a name="1041"></a>
<a name="1042"></a>        /* get the list (evaluate it once to avoid repeated side effects) */
<a name="1043"></a>        local lst = eventList;
<a name="1044"></a>
<a name="1045"></a>        /* cache the length */
<a name="1046"></a>        eventListLen = lst.length();
<a name="1047"></a>
<a name="1048"></a>        /* if it's a valid index in our list, fire the event */
<a name="1049"></a>        if (idx &gt;= 1 &amp;&amp; idx &lt;= eventListLen)
<a name="1050"></a>        {
<a name="1051"></a>            /* carry out the event */
<a name="1052"></a>            doScriptEvent(lst[idx]);
<a name="1053"></a>        }
<a name="1054"></a>
<a name="1055"></a>        /* perform any end-of-script processing */
<a name="1056"></a>        scriptDone();
<a name="1057"></a>    }
<a name="1058"></a>
<a name="1059"></a>    /* carry out one script event */
<a name="1060"></a>    doScriptEvent(evt)
<a name="1061"></a>    {
<a name="1062"></a>        /* check what kind of event we have */
<a name="1063"></a>        switch (dataTypeXlat(evt))
<a name="1064"></a>        {
<a name="1065"></a>        case TypeSString:
<a name="1066"></a>            /* it's a string - display it */
<a name="1067"></a>            say(evt);
<a name="1068"></a>            break;
<a name="1069"></a>
<a name="1070"></a>        case TypeObject:
<a name="1071"></a>            /* it must be a Script object - invoke its doScript() method */
<a name="1072"></a>            evt.doScript();
<a name="1073"></a>            break;
<a name="1074"></a>
<a name="1075"></a>        case TypeFuncPtr:
<a name="1076"></a>            /* it's a function pointer - invoke it */
<a name="1077"></a>            (evt)();
<a name="1078"></a>            break;
<a name="1079"></a>
<a name="1080"></a>        case TypeProp:
<a name="1081"></a>            /* it's a property of self - invoke it */
<a name="1082"></a>            self.(evt)();
<a name="1083"></a>            break;
<a name="1084"></a>
<a name="1085"></a>        default:
<a name="1086"></a>            /* do nothing in other cases */
<a name="1087"></a>            break;
<a name="1088"></a>        }
<a name="1089"></a>    }
<a name="1090"></a>
<a name="1091"></a>    /*
<a name="1092"></a>     *   Perform any end-of-script processing.  By default, we advance the
<a name="1093"></a>     *   script to the next state.
<a name="1094"></a>     *
<a name="1095"></a>     *   Some scripts might want to override this.  For example, a script
<a name="1096"></a>     *   could be driven entirely by some external timing; the state of a
<a name="1097"></a>     *   script could vary once per turn, for example, or could change each
<a name="1098"></a>     *   time an actor pushes a button.  In these cases, invoking the
<a name="1099"></a>     *   script wouldn't affect the state of the event list, so the
<a name="1100"></a>     *   subclass would override scriptDone() so that it does nothing at
<a name="1101"></a>     *   all.
<a name="1102"></a>     */
<a name="1103"></a>    scriptDone()
<a name="1104"></a>    {
<a name="1105"></a>        /* advance to the next state */
<a name="1106"></a>        advanceState();
<a name="1107"></a>    }
<a name="1108"></a>;
<a name="1109"></a>
<a name="1110"></a>/*
<a name="1111"></a> *   An "external" event list is one whose state is driven externally to
<a name="1112"></a> *   the script.  Specifically, the state is *not* advanced by invoking the
<a name="1113"></a> *   script; the state is advanced exclusively by some external process
<a name="1114"></a> *   (for example, by a daemon that invokes the event list's advanceState()
<a name="1115"></a> *   method).
<a name="1116"></a> */
<a name="1117"></a>class ExternalEventList: EventList
<a name="1118"></a>    scriptDone() { }
<a name="1119"></a>;
<a name="1120"></a>
<a name="1121"></a>/*
<a name="1122"></a> *   A cyclical event list - this runs through the event list in order,
<a name="1123"></a> *   returning to the first element when we pass the last element.
<a name="1124"></a> */
<a name="1125"></a>class CyclicEventList: EventList
<a name="1126"></a>    advanceState()
<a name="1127"></a>    {
<a name="1128"></a>        /* go to the next state */
<a name="1129"></a>        ++curScriptState;
<a name="1130"></a>
<a name="1131"></a>        /* if we've passed the end of the list, loop back to the start */
<a name="1132"></a>        if (curScriptState &gt; eventListLen)
<a name="1133"></a>            curScriptState = 1;
<a name="1134"></a>    }
<a name="1135"></a>;
<a name="1136"></a>
<a name="1137"></a>/*
<a name="1138"></a> *   A stopping event list - this runs through the event list in order,
<a name="1139"></a> *   then stops at the last item and repeats it each time the script is
<a name="1140"></a> *   subsequently invoked.
<a name="1141"></a> *
<a name="1142"></a> *   This is often useful for things like ASK ABOUT topics, where we reveal
<a name="1143"></a> *   more information when asked repeatedly about a topic, but eventually
<a name="1144"></a> *   reach a point where we've said everything:
<a name="1145"></a> *
<a name="1146"></a> *.  &gt;ask bob about black book
<a name="1147"></a> *.  "What makes you think I know anything about it?" he says, his
<a name="1148"></a> *   voice shaking.
<a name="1149"></a> *
<a name="1150"></a> *   &gt;again
<a name="1151"></a> *.  "No! You can't make me tell you!"
<a name="1152"></a> *
<a name="1153"></a> *   &gt;again
<a name="1154"></a> *.  "All right, I'll tell you what you want to know!  But I warn you,
<a name="1155"></a> *   these are things mortal men were never meant to know.  Your life, your
<a name="1156"></a> *   very soul will be in danger from the moment you hear these dark secrets!"
<a name="1157"></a> *
<a name="1158"></a> *   &gt;again
<a name="1159"></a> *.  [scene missing]
<a name="1160"></a> *
<a name="1161"></a> *   &gt;again
<a name="1162"></a> *.  "I've already told you all I know."
<a name="1163"></a> *
<a name="1164"></a> *   &gt;again
<a name="1165"></a> *.  "I've already told you all I know."
<a name="1166"></a> */
<a name="1167"></a>class StopEventList: EventList
<a name="1168"></a>    advanceState()
<a name="1169"></a>    {
<a name="1170"></a>        /* if we haven't yet reached the last state, go to the next one */
<a name="1171"></a>        if (curScriptState &lt; eventListLen)
<a name="1172"></a>            ++curScriptState;
<a name="1173"></a>    }
<a name="1174"></a>;
<a name="1175"></a>
<a name="1176"></a>/*
<a name="1177"></a> *   A synchronized event list.  This is an event list that takes its
<a name="1178"></a> *   actions from a separate event list object.  We get our current state
<a name="1179"></a> *   from the other list, and advancing our state advances the other list's
<a name="1180"></a> *   state in lock step.  Set 'masterObject' to refer to the master list
<a name="1181"></a> *   whose state we synchronize with.
<a name="1182"></a> *
<a name="1183"></a> *   This can be useful, for example, when we have messages that reflect
<a name="1184"></a> *   two different points of view on the same events: the messages for each
<a name="1185"></a> *   point of view can be kept in a separate list, but the one list can be
<a name="1186"></a> *   a slave of the other to ensure that the two lists are based on a
<a name="1187"></a> *   common state.
<a name="1188"></a> */
<a name="1189"></a>class SyncEventList: EventList
<a name="1190"></a>    /* my master event list object */
<a name="1191"></a>    masterObject = nil
<a name="1192"></a>
<a name="1193"></a>    /* my state is simply the master list's state */
<a name="1194"></a>    getScriptState() { return masterObject.getScriptState(); }
<a name="1195"></a>
<a name="1196"></a>    /* to advance my state, advance the master list's state */
<a name="1197"></a>    advanceState() { masterObject.advanceState(); }
<a name="1198"></a>
<a name="1199"></a>    /* let the master list take care of finishing a script step */
<a name="1200"></a>    scriptDone() { masterObject.scriptDone(); }
<a name="1201"></a>;
<a name="1202"></a>
<a name="1203"></a>/*
<a name="1204"></a> *   Randomized event list.  This is similar to a regular event list, but
<a name="1205"></a> *   chooses an event at random each time it's invoked.
<a name="1206"></a> */
<a name="1207"></a>class RandomEventList: RandomFiringScript, EventList
<a name="1208"></a>    /* process the next step of the script */
<a name="1209"></a>    doScript()
<a name="1210"></a>    {
<a name="1211"></a>        /* check the odds to see if we want to fire an event at all */
<a name="1212"></a>        if (!checkEventOdds())
<a name="1213"></a>            return;
<a name="1214"></a>
<a name="1215"></a>        /* get our next random number */
<a name="1216"></a>        local idx = getNextRandom();
<a name="1217"></a>
<a name="1218"></a>        /* cache the list and its length, to avoid repeated side effects */
<a name="1219"></a>        local lst = eventList;
<a name="1220"></a>        eventListLen = lst.length();
<a name="1221"></a>
<a name="1222"></a>        /* run the event, if the index is valid */
<a name="1223"></a>        if (idx &gt;= 1 &amp;&amp; idx &lt;= eventListLen)
<a name="1224"></a>            doScriptEvent(lst[idx]);
<a name="1225"></a>    }
<a name="1226"></a>
<a name="1227"></a>    /*
<a name="1228"></a>     *   Get the next random state.  By default, we simply return a number
<a name="1229"></a>     *   from 1 to the number of entries in our event list.  This is a
<a name="1230"></a>     *   separate method to allow subclasses to customize the way the
<a name="1231"></a>     *   random number is selected.
<a name="1232"></a>     */
<a name="1233"></a>    getNextRandom()
<a name="1234"></a>    {
<a name="1235"></a>        /*
<a name="1236"></a>         *   Note that rand(n) returns a number from 0 to n-1 inclusive;
<a name="1237"></a>         *   since list indices run from 1 to list.length, add one to the
<a name="1238"></a>         *   result of rand(list.length) to get a value in the proper range
<a name="1239"></a>         *   for a list index.
<a name="1240"></a>         */
<a name="1241"></a>        return rand(eventListLen) + 1;
<a name="1242"></a>    }
<a name="1243"></a>;
<a name="1244"></a>
<a name="1245"></a>/*
<a name="1246"></a> *   Shuffled event list.  This is similar to a random event list, except
<a name="1247"></a> *   that we fire our events in a "shuffled" order rather than an
<a name="1248"></a> *   independently random order.  "Shuffled order" means that we fire the
<a name="1249"></a> *   events in random order, but we don't re-fire an event until we've run
<a name="1250"></a> *   through all of the other events.  The effect is as though we were
<a name="1251"></a> *   dealing from a deck of cards.
<a name="1252"></a> *
<a name="1253"></a> *   For the first time through the main list, we normally shuffle the
<a name="1254"></a> *   strings immediately at startup, but this is optional.  If shuffleFirst
<a name="1255"></a> *   is set to nil, we will NOT shuffle the list the first time through -
<a name="1256"></a> *   we'll run through it once in the given order, then shuffle for the
<a name="1257"></a> *   next time through, then shuffle again for the next, and so on.  So, if
<a name="1258"></a> *   you want a specific order for the first time through, just define the
<a name="1259"></a> *   list in the desired order and set shuffleFirst to nil.
<a name="1260"></a> *
<a name="1261"></a> *   You can optionally specify a separate list of one-time-only sequential
<a name="1262"></a> *   strings in the property firstEvents.  We'll run through these strings
<a name="1263"></a> *   once.  When we've exhausted them, we'll switch to the main eventList
<a name="1264"></a> *   list, showing it one time through in its given order, then shuffling
<a name="1265"></a> *   it and running through it again, and so on.  The firstEvents list is
<a name="1266"></a> *   never shuffled - it's always shown in exactly the order given.
<a name="1267"></a> */
<a name="1268"></a>class ShuffledEventList: RandomFiringScript, EventList
<a name="1269"></a>    /*
<a name="1270"></a>     *   a list of events to go through sequentially, in the exact order
<a name="1271"></a>     *   specified, before firing any events from the main list
<a name="1272"></a>     */
<a name="1273"></a>    firstEvents = []
<a name="1274"></a>
<a name="1275"></a>    /*
<a name="1276"></a>     *   Flag: shuffle the eventList list before we show it for the first
<a name="1277"></a>     *   time.  By default, this is set to true, so that the behavior is
<a name="1278"></a>     *   random on each independent run of the game.  However, it might be
<a name="1279"></a>     *   desirable in some cases to always use the original ordering of the
<a name="1280"></a>     *   eventList list the first time through the list.  If this is set to
<a name="1281"></a>     *   nil, we won't shuffle the list the first time through.
<a name="1282"></a>     */
<a name="1283"></a>    shuffleFirst = true
<a name="1284"></a>
<a name="1285"></a>    /*
<a name="1286"></a>     *   Flag: suppress repeats in the shuffle.  If this is true, it
<a name="1287"></a>     *   prevents a given event from showing up twice in a row, which could
<a name="1288"></a>     *   otherwise happen right after a shuffle.  This is ignored for lists
<a name="1289"></a>     *   with one or two events: it's impossible to prevent repeats in a
<a name="1290"></a>     *   one-element list, and doing so in a two-element list would produce
<a name="1291"></a>     *   a predictable A-B-A-B... pattern.
<a name="1292"></a>     *
<a name="1293"></a>     *   You might want to set this to nil for lists of three or four
<a name="1294"></a>     *   elements, since such short lists can result in fairly
<a name="1295"></a>     *   un-random-looking sequences when repeats are suppressed, because
<a name="1296"></a>     *   the available number of permutations drops significantly.
<a name="1297"></a>     */
<a name="1298"></a>    suppressRepeats = true
<a name="1299"></a>
<a name="1300"></a>    /* process the next step of the script */
<a name="1301"></a>    doScript()
<a name="1302"></a>    {
<a name="1303"></a>        /* cache the lists to avoid repeated side effects */
<a name="1304"></a>        local firstLst = firstEvents;
<a name="1305"></a>        local firstLen = firstLst.length();
<a name="1306"></a>        local lst = eventList;
<a name="1307"></a>        eventListLen = lst.length();
<a name="1308"></a>
<a name="1309"></a>        /* process the script step only if the event odds allow it */
<a name="1310"></a>        if (!checkEventOdds())
<a name="1311"></a>            return;
<a name="1312"></a>
<a name="1313"></a>        /*
<a name="1314"></a>         *   States 1..N, where N is the number of elements in the
<a name="1315"></a>         *   firstEvents list, simply show the firstEvents elements in
<a name="1316"></a>         *   order.
<a name="1317"></a>         *
<a name="1318"></a>         *   If we're set to shuffle the main eventList list initially, all
<a name="1319"></a>         *   states above N simply show elements from the eventList list in
<a name="1320"></a>         *   shuffled order.
<a name="1321"></a>         *
<a name="1322"></a>         *   If we're NOT set to shuffle the main eventList list initially,
<a name="1323"></a>         *   the following apply:
<a name="1324"></a>         *
<a name="1325"></a>         *   States N+1..N+M, where M is the number of elements in the
<a name="1326"></a>         *   eventList list, show the eventList elements in order.
<a name="1327"></a>         *
<a name="1328"></a>         *   States above N+M show elements from the eventList list in
<a name="1329"></a>         *   shuffled order.
<a name="1330"></a>         */
<a name="1331"></a>        local evt;
<a name="1332"></a>        if (curScriptState &lt;= firstLen)
<a name="1333"></a>        {
<a name="1334"></a>            /* simply fetch the next string from firstEvents */
<a name="1335"></a>            evt = firstEvents[curScriptState++];
<a name="1336"></a>        }
<a name="1337"></a>        else if (!shuffleFirst &amp;&amp; curScriptState &lt;= firstLen + eventListLen)
<a name="1338"></a>        {
<a name="1339"></a>            /* fetch the next string from eventList */
<a name="1340"></a>            evt = lst[curScriptState++ - firstLen];
<a name="1341"></a>        }
<a name="1342"></a>        else
<a name="1343"></a>        {
<a name="1344"></a>            /* we're showing shuffled strings from the eventList list */
<a name="1345"></a>            evt = lst[getNextRandom()];
<a name="1346"></a>        }
<a name="1347"></a>
<a name="1348"></a>        /* execute the event */
<a name="1349"></a>        doScriptEvent(evt);
<a name="1350"></a>    }
<a name="1351"></a>
<a name="1352"></a>
<a name="1353"></a>    /*
<a name="1354"></a>     *   Get the next random event.  We'll pick an event from our list of
<a name="1355"></a>     *   events using a ShuffledIntegerList to ensure we pick each value
<a name="1356"></a>     *   once before re-using any values.
<a name="1357"></a>     */
<a name="1358"></a>    getNextRandom()
<a name="1359"></a>    {
<a name="1360"></a>        /* if we haven't created our shuffled list yet, do so now */
<a name="1361"></a>        if (shuffledList_ == nil)
<a name="1362"></a>        {
<a name="1363"></a>            /*
<a name="1364"></a>             *   create a shuffled integer list - we'll use these shuffled
<a name="1365"></a>             *   integers as indices into our event list
<a name="1366"></a>             */
<a name="1367"></a>            shuffledList_ = new ShuffledIntegerList(1, eventListLen);
<a name="1368"></a>
<a name="1369"></a>            /* apply our suppressRepeats option to the shuffled list */
<a name="1370"></a>            shuffledList_.suppressRepeats = suppressRepeats;
<a name="1371"></a>        }
<a name="1372"></a>
<a name="1373"></a>        /* ask the shuffled list to pick an element */
<a name="1374"></a>        return shuffledList_.getNextValue();
<a name="1375"></a>    }
<a name="1376"></a>
<a name="1377"></a>    /* our ShuffledList - we'll initialize this on demand */
<a name="1378"></a>    shuffledList_ = nil
<a name="1379"></a>;
<a name="1380"></a>
<a name="1381"></a>/* ------------------------------------------------------------------------ */
<a name="1382"></a>/*
<a name="1383"></a> *   Shuffled List - this class keeps a list of values that can be returned
<a name="1384"></a> *   in random order, but with the constraint that we never repeat a value
<a name="1385"></a> *   until we've handed out every value.  Think of a shuffled deck of
<a name="1386"></a> *   cards: the order of the cards handed out is random, but once a card is
<a name="1387"></a> *   dealt, it can't be dealt again until we put everything back into the
<a name="1388"></a> *   deck and reshuffle.
<a name="1389"></a> */
<a name="1390"></a>class ShuffledList: object
<a name="1391"></a>    /*
<a name="1392"></a>     *   the list of values we want to shuffle - initialize this in each
<a name="1393"></a>     *   instance to the set of values we want to return in random order
<a name="1394"></a>     */
<a name="1395"></a>    valueList = []
<a name="1396"></a>
<a name="1397"></a>    /*
<a name="1398"></a>     *   Flag: suppress repeated values.  We mostly suppress repeats by our
<a name="1399"></a>     *   very design, since we run through the entire list before repeating
<a name="1400"></a>     *   anything in the list.  However, there's one situation (in a list
<a name="1401"></a>     *   with more than one element) where a repeat can occur: immediately
<a name="1402"></a>     *   after a shuffle, we could select the last element from the
<a name="1403"></a>     *   previous shuffle as the first element of the new shuffle.  If this
<a name="1404"></a>     *   flag is set, we'll suppress this type of repeat by choosing again
<a name="1405"></a>     *   any time we're about to choose a repeat.
<a name="1406"></a>     *
<a name="1407"></a>     *   Note that we ignore this for a list of one element, since it's
<a name="1408"></a>     *   obviously impossible to avoid repeats in this case.  We also
<a name="1409"></a>     *   ignore it for a two-element list, since this would produce the
<a name="1410"></a>     *   predictable pattern A-B-A-B..., defeating the purpose of the
<a name="1411"></a>     *   shuffle.
<a name="1412"></a>     */
<a name="1413"></a>    suppressRepeats = nil
<a name="1414"></a>
<a name="1415"></a>    /* create from a given list */
<a name="1416"></a>    construct(lst)
<a name="1417"></a>    {
<a name="1418"></a>        /* remember our list of values */
<a name="1419"></a>        valueList = lst;
<a name="1420"></a>    }
<a name="1421"></a>
<a name="1422"></a>    /*
<a name="1423"></a>     *   Get a random value.  This will return a randomly-selected element
<a name="1424"></a>     *   from 'valueList', but we'll return every element of 'valueList'
<a name="1425"></a>     *   once before repeating any element.
<a name="1426"></a>     *
<a name="1427"></a>     *   If we've returned every value on the current round, we'll
<a name="1428"></a>     *   automatically shuffle the values and start a new round.
<a name="1429"></a>     */
<a name="1430"></a>    getNextValue()
<a name="1431"></a>    {
<a name="1432"></a>        local i;
<a name="1433"></a>        local ret;
<a name="1434"></a>        local justReshuffled = nil;
<a name="1435"></a>
<a name="1436"></a>        /* if we haven't initialized our vector, do so now */
<a name="1437"></a>        if (valuesVec == nil)
<a name="1438"></a>        {
<a name="1439"></a>            /* create the vector */
<a name="1440"></a>            valuesVec = new Vector(valueList.length(), valueList);
<a name="1441"></a>
<a name="1442"></a>            /* all values are initially available */
<a name="1443"></a>            valuesAvail = valuesVec.length();
<a name="1444"></a>        }
<a name="1445"></a>
<a name="1446"></a>        /* if we've exhausted our values on this round, start over */
<a name="1447"></a>        if (valuesAvail == 0)
<a name="1448"></a>        {
<a name="1449"></a>            /* shuffle the elements */
<a name="1450"></a>            reshuffle();
<a name="1451"></a>
<a name="1452"></a>            /* note that we just did a shuffle */
<a name="1453"></a>            justReshuffled = true;
<a name="1454"></a>        }
<a name="1455"></a>
<a name="1456"></a>        /* pick a random element from the 'available' partition */
<a name="1457"></a>        i = rand(valuesAvail) + 1;
<a name="1458"></a>
<a name="1459"></a>        /*
<a name="1460"></a>         *   If we just reshuffled, and we're configured to suppress a
<a name="1461"></a>         *   repeat immediately after a reshuffle, and we chose the first
<a name="1462"></a>         *   element of the vector, and we have at least three elements,
<a name="1463"></a>         *   choose a different element.  The first element in the vector is
<a name="1464"></a>         *   always the last element we return from each run-through, since
<a name="1465"></a>         *   the 'available' partition is at the start of the list and thus
<a name="1466"></a>         *   shrinks down until it contains only the first element.
<a name="1467"></a>         *
<a name="1468"></a>         *   If we have one element, there's obviously no point in trying to
<a name="1469"></a>         *   suppress repeats.  If we have two elements, we *still* don't
<a name="1470"></a>         *   want to suppress repeats, because in this case we'd generate a
<a name="1471"></a>         *   predicatable A-B-A-B pattern (because we could never have two
<a name="1472"></a>         *   A's or two B's in a row).
<a name="1473"></a>         */
<a name="1474"></a>        if (justReshuffled &amp;&amp; suppressRepeats &amp;&amp; valuesAvail &gt; 2)
<a name="1475"></a>        {
<a name="1476"></a>            /*
<a name="1477"></a>             *   we don't want repeats, so choose anything besides the
<a name="1478"></a>             *   first element; keep choosing until we get another element
<a name="1479"></a>             */
<a name="1480"></a>            while (i == 1)
<a name="1481"></a>                i = rand(valuesAvail) + 1;
<a name="1482"></a>        }
<a name="1483"></a>
<a name="1484"></a>        /* remember the element we're returning */
<a name="1485"></a>        ret = valuesVec[i];
<a name="1486"></a>
<a name="1487"></a>        /*
<a name="1488"></a>         *   Move the value at the top of the 'available' partition down
<a name="1489"></a>         *   into the hole we're creating at 'i', since we're about to
<a name="1490"></a>         *   reduce the size of the 'available' partition to reflect the
<a name="1491"></a>         *   use of one more value; that would leave the element at the top
<a name="1492"></a>         *   of the partition homeless, so we need somewhere to put it.
<a name="1493"></a>         *   Luckily, we also need to delete element 'i', since we're using
<a name="1494"></a>         *   this element.  Solve both problems at once by moving element
<a name="1495"></a>         *   we're rendering homeless into the hole we're creating.
<a name="1496"></a>         */
<a name="1497"></a>        valuesVec[i] = valuesVec[valuesAvail];
<a name="1498"></a>
<a name="1499"></a>        /* move the value we're returning into the top slot */
<a name="1500"></a>        valuesVec[valuesAvail] = ret;
<a name="1501"></a>
<a name="1502"></a>        /* reduce the 'available' partition by one */
<a name="1503"></a>        --valuesAvail;
<a name="1504"></a>
<a name="1505"></a>        /* return the result */
<a name="1506"></a>        return ret;
<a name="1507"></a>    }
<a name="1508"></a>
<a name="1509"></a>    /*
<a name="1510"></a>     *   Shuffle the values.  This puts all of the values back into the
<a name="1511"></a>     *   deck (as it were) for a new round.  It's never required to call
<a name="1512"></a>     *   this, because getNextValue() automatically shuffles the deck and
<a name="1513"></a>     *   starts over each time it runs through the entire deck.  This is
<a name="1514"></a>     *   provided in case the caller has a reason to want to put all the
<a name="1515"></a>     *   values back into play immediately, before every value has been
<a name="1516"></a>     *   dealt on the current round.
<a name="1517"></a>     */
<a name="1518"></a>    reshuffle()
<a name="1519"></a>    {
<a name="1520"></a>        /*
<a name="1521"></a>         *   Simply reset the counter of available values.  Go with the
<a name="1522"></a>         *   original source list's length, in case we haven't initialized
<a name="1523"></a>         *   our internal vector yet.
<a name="1524"></a>         */
<a name="1525"></a>        valuesAvail = valueList.length();
<a name="1526"></a>    }
<a name="1527"></a>
<a name="1528"></a>    /*
<a name="1529"></a>     *   Internal vector of available/used values.  Elements from 1 to
<a name="1530"></a>     *   'valuesAvail', inclusive, are still available for use on this
<a name="1531"></a>     *   round.  Elements above 'valuesAvail' have already been used.
<a name="1532"></a>     */
<a name="1533"></a>    valuesVec = nil
<a name="1534"></a>
<a name="1535"></a>    /* number of values still available on this round */
<a name="1536"></a>    valuesAvail = 0
<a name="1537"></a>;
<a name="1538"></a>
<a name="1539"></a>/*
<a name="1540"></a> *   A Shuffled Integer List is a special kind of Shuffled List that
<a name="1541"></a> *   returns integers in a given range.  Like an ordinary Shuffled List,
<a name="1542"></a> *   we'll return integers in the given range in random order, but we'll
<a name="1543"></a> *   only return each integer once during a given round; when we exhaust
<a name="1544"></a> *   the supply, we'll reshuffle the set of integers and start over.
<a name="1545"></a> */
<a name="1546"></a>class ShuffledIntegerList: ShuffledList
<a name="1547"></a>    /*
<a name="1548"></a>     *   The minimum and maximum values for our range.  Instances should
<a name="1549"></a>     *   define these to the range desired.
<a name="1550"></a>     */
<a name="1551"></a>    rangeMin = 1
<a name="1552"></a>    rangeMax = 10
<a name="1553"></a>
<a name="1554"></a>    /* initialize the value list on demand */
<a name="1555"></a>    valueList = nil
<a name="1556"></a>
<a name="1557"></a>    /* construct with the given range */
<a name="1558"></a>    construct(rmin, rmax)
<a name="1559"></a>    {
<a name="1560"></a>        rangeMin = rmin;
<a name="1561"></a>        rangeMax = rmax;
<a name="1562"></a>    }
<a name="1563"></a>
<a name="1564"></a>    /* get the next value */
<a name="1565"></a>    getNextValue()
<a name="1566"></a>    {
<a name="1567"></a>        /*
<a name="1568"></a>         *   If we haven't set up our value list yet, do so now.  This is
<a name="1569"></a>         *   simply a list of integers from rangeMin to rangeMax.
<a name="1570"></a>         */
<a name="1571"></a>        if (valueList == nil)
<a name="1572"></a>        {
<a name="1573"></a>            local ele = rangeMin;
<a name="1574"></a>            valueList = List.generate({i: ele++}, rangeMax - rangeMin + 1);
<a name="1575"></a>        }
<a name="1576"></a>
<a name="1577"></a>        /* use the inherited handling to select from our value list */
<a name="1578"></a>        return inherited();
<a name="1579"></a>    }
<a name="1580"></a>;
<a name="1581"></a>
<a name="1582"></a>
<a name="1583"></a>/* ------------------------------------------------------------------------ */
<a name="1584"></a>/*
<a name="1585"></a> *   Library global variables
<a name="1586"></a> */
<a name="1587"></a>libGlobal: object
<a name="1588"></a>    /*
<a name="1589"></a>     *   The current library messages object.  This is the source object
<a name="1590"></a>     *   for messages that don't logically relate to the actor carrying out
<a name="1591"></a>     *   the comamand.  It's mostly used for meta-command replies, and for
<a name="1592"></a>     *   text fragments that are used to construct descriptions.
<a name="1593"></a>     *
<a name="1594"></a>     *   This message object isn't generally used for parser messages or
<a name="1595"></a>     *   action replies - most of those come from the objects given by the
<a name="1596"></a>     *   current actor's getParserMessageObj() or getActionMessageObj(),
<a name="1597"></a>     *   respectively.
<a name="1598"></a>     *
<a name="1599"></a>     *   By default, this is set to libMessages.  The library never changes
<a name="1600"></a>     *   this itself, but a game can change this if it wants to switch to a
<a name="1601"></a>     *   new set of messages during a game.  (If you don't need to change
<a name="1602"></a>     *   messages during a game, but simply want to customize some of the
<a name="1603"></a>     *   default messages, you don't need to set this variable - you can
<a name="1604"></a>     *   simply use 'modify libMessages' instead.  This variable is
<a name="1605"></a>     *   designed for cases where you want to *dynamically* change the
<a name="1606"></a>     *   standard messages during the game.)
<a name="1607"></a>     */
<a name="1608"></a>    libMessageObj = libMessages
<a name="1609"></a>
<a name="1610"></a>    /*
<a name="1611"></a>     *   Sense cache - we keep SenseInfo lists here, keyed by [pov,sense];
<a name="1612"></a>     *   we normally discard the cached information at the start of each
<a name="1613"></a>     *   turn, and disable caching entirely at the start of the "action"
<a name="1614"></a>     *   phase of each turn.  We leave caching disabled during each turn's
<a name="1615"></a>     *   action phase because this is the phase where simulation state
<a name="1616"></a>     *   changes are typically made, and hence it would be difficult to
<a name="1617"></a>     *   keep the cache coherent during this phase.
<a name="1618"></a>     *
<a name="1619"></a>     *   When this is nil, it indicates that caching is disabled.  We only
<a name="1620"></a>     *   allow caching during certain phases of execution, when game state
<a name="1621"></a>     *   is not conventionally altered, so that we don't have to do a lot
<a name="1622"></a>     *   of work to keep the cache up to date.
<a name="1623"></a>     */
<a name="1624"></a>    senseCache = nil
<a name="1625"></a>
<a name="1626"></a>    /*
<a name="1627"></a>     *   Can-Touch cache - we keep CanTouchInfo entries here, keyed by
<a name="1628"></a>     *   [from,to].  This cache is the touch-path equivalent of the sense
<a name="1629"></a>     *   cache, and is enabled and disabled
<a name="1630"></a>     */
<a name="1631"></a>    canTouchCache = nil
<a name="1632"></a>
<a name="1633"></a>    /*
<a name="1634"></a>     *   Connection list cache - this is a cache of all of the objects
<a name="1635"></a>     *   connected by containment to a given object.
<a name="1636"></a>     */
<a name="1637"></a>    connectionCache = nil
<a name="1638"></a>
<a name="1639"></a>    /*
<a name="1640"></a>     *   Actor visual ambient cache - this keeps track of the ambient light
<a name="1641"></a>     *   level at the given actor.
<a name="1642"></a>     */
<a name="1643"></a>    actorVisualAmbientCache = nil
<a name="1644"></a>
<a name="1645"></a>    /* enable the cache, clearing any old cached information */
<a name="1646"></a>    enableSenseCache()
<a name="1647"></a>    {
<a name="1648"></a>        /* create a new, empty lookup table for the sense cache */
<a name="1649"></a>        senseCache = new LookupTable(32, 64);
<a name="1650"></a>
<a name="1651"></a>        /* create the can-touch cache */
<a name="1652"></a>        canTouchCache = new LookupTable(32, 64);
<a name="1653"></a>
<a name="1654"></a>        /* create the actor visual ambient cache */
<a name="1655"></a>        actorVisualAmbientCache = new LookupTable(32, 64);
<a name="1656"></a>
<a name="1657"></a>        /* create a connection list cache */
<a name="1658"></a>        connectionCache = new LookupTable(32, 64);
<a name="1659"></a>    }
<a name="1660"></a>
<a name="1661"></a>    /* disable the cache */
<a name="1662"></a>    disableSenseCache()
<a name="1663"></a>    {
<a name="1664"></a>        /* forget the cache tables */
<a name="1665"></a>        senseCache = nil;
<a name="1666"></a>        canTouchCache = nil;
<a name="1667"></a>        actorVisualAmbientCache = nil;
<a name="1668"></a>        connectionCache = nil;
<a name="1669"></a>    }
<a name="1670"></a>
<a name="1671"></a>    /*
<a name="1672"></a>     *   Invalidate the sense cache.  This can be called if something
<a name="1673"></a>     *   happens during noun resolution or verification that causes any
<a name="1674"></a>     *   cached sense information to become out of date.  For example, if
<a name="1675"></a>     *   you have to create a new game-world object during noun-phrase
<a name="1676"></a>     *   resolution, this should be called to ensure that the new object's
<a name="1677"></a>     *   visibility is properly calculated and incorporated into the cached
<a name="1678"></a>     *   information.
<a name="1679"></a>     */
<a name="1680"></a>    invalSenseCache()
<a name="1681"></a>    {
<a name="1682"></a>        /* remember whether or not caching is currently enabled */
<a name="1683"></a>        local wasEnabled = (senseCache != nil);
<a name="1684"></a>
<a name="1685"></a>        /* clear the cache by disabling it */
<a name="1686"></a>        disableSenseCache();
<a name="1687"></a>
<a name="1688"></a>        /* if the cache was previously enabled, re-enable it */
<a name="1689"></a>        if (wasEnabled)
<a name="1690"></a>            enableSenseCache();
<a name="1691"></a>    }
<a name="1692"></a>
<a name="1693"></a>    /*
<a name="1694"></a>     *   List of all of the senses.  The library pre-initializer will load
<a name="1695"></a>     *   this list with a reference to each instance of class Sense.
<a name="1696"></a>     */
<a name="1697"></a>    allSenses = []
<a name="1698"></a>
<a name="1699"></a>    /*
<a name="1700"></a>     *   The current player character
<a name="1701"></a>     */
<a name="1702"></a>    playerChar = nil
<a name="1703"></a>
<a name="1704"></a>    /*
<a name="1705"></a>     *   The current perspective actor.  This is the actor who's performing
<a name="1706"></a>     *   the action (LOOK AROUND, EXAMINE, SMELL, etc) that's generating
<a name="1707"></a>     *   the current description.
<a name="1708"></a>     */
<a name="1709"></a>    pointOfViewActor = nil
<a name="1710"></a>
<a name="1711"></a>    /*
<a name="1712"></a>     *   The current perspective object.  This is *usually* the actor
<a name="1713"></a>     *   performing the current command, but can be a different object when
<a name="1714"></a>     *   the actor is viewing the location being described via an
<a name="1715"></a>     *   intermediary, such as through a closed-circuit TV camera.
<a name="1716"></a>     */
<a name="1717"></a>    pointOfView = nil
<a name="1718"></a>
<a name="1719"></a>    /*
<a name="1720"></a>     *   The stack of point of view objects.  The last element of the
<a name="1721"></a>     *   vector is the most recent point of view after the current point
<a name="1722"></a>     *   of view.
<a name="1723"></a>     */
<a name="1724"></a>    povStack = static new Vector(32)
<a name="1725"></a>
<a name="1726"></a>    /*
<a name="1727"></a>     *   The global score object.  We use a global for this, rather than
<a name="1728"></a>     *   referencing libScore directly, to allow the score module to be
<a name="1729"></a>     *   left out entirely if the game doesn't make use of scoring.  The
<a name="1730"></a>     *   score module should set this during pre-initialization.
<a name="1731"></a>     */
<a name="1732"></a>    scoreObj = nil
<a name="1733"></a>
<a name="1734"></a>    /*
<a name="1735"></a>     *   The global Footnote class object.  We use a global for this,
<a name="1736"></a>     *   rather than referencing Footnote directly, to allow the footnote
<a name="1737"></a>     *   module to be left out entirely if the game doesn't make use of
<a name="1738"></a>     *   footnotes.  The footnote class should set this during
<a name="1739"></a>     *   pre-initialization.
<a name="1740"></a>     */
<a name="1741"></a>    footnoteClass = nil
<a name="1742"></a>
<a name="1743"></a>    /* the total number of turns so far */
<a name="1744"></a>    totalTurns = 0
<a name="1745"></a>
<a name="1746"></a>    /*
<a name="1747"></a>     *   flag: the parser is in 'debug' mode, in which it displays the
<a name="1748"></a>     *   parse tree for each command entered
<a name="1749"></a>     */
<a name="1750"></a>    parserDebugMode = nil
<a name="1751"></a>
<a name="1752"></a>    /*
<a name="1753"></a>     *   Most recent command, for 'undo' purposes.  This is the last
<a name="1754"></a>     *   command the player character performed, or the last initial
<a name="1755"></a>     *   command a player directed to an NPC.
<a name="1756"></a>     *
<a name="1757"></a>     *   Note that if the player directed a series of commands to an NPC
<a name="1758"></a>     *   with a single command line, only the first command on such a
<a name="1759"></a>     *   command line is retained here, because it is only the first such
<a name="1760"></a>     *   command that counts as a player's turn in terms of the game
<a name="1761"></a>     *   clock.  Subsequent commands are executed by the NPC's on the
<a name="1762"></a>     *   NPC's own time, and do not count against the PC's game clock
<a name="1763"></a>     *   time.  The first command counts against the PC's clock because of
<a name="1764"></a>     *   the time it takes the PC to give the command to the NPC.
<a name="1765"></a>     */
<a name="1766"></a>    lastCommandForUndo = ''
<a name="1767"></a>
<a name="1768"></a>    /*
<a name="1769"></a>     *   Most recent target actor phrase; this goes with
<a name="1770"></a>     *   lastCommandForUndo.  This is nil if the last command did not
<a name="1771"></a>     *   specify an actor (i.e., was implicitly for the player character),
<a name="1772"></a>     *   otherwise is the string the player typed specifying a target
<a name="1773"></a>     *   actor.
<a name="1774"></a>     */
<a name="1775"></a>    lastActorForUndo = ''
<a name="1776"></a>
<a name="1777"></a>    /*
<a name="1778"></a>     *   Current command information.  We keep track of the current
<a name="1779"></a>     *   command's actor and action here, as well as the verification
<a name="1780"></a>     *   result list and the command report list.
<a name="1781"></a>     */
<a name="1782"></a>    curActor = nil
<a name="1783"></a>    curIssuingActor = nil
<a name="1784"></a>    curAction = nil
<a name="1785"></a>    curVerifyResults = nil
<a name="1786"></a>
<a name="1787"></a>    /* the exitLister object, if included in the build */
<a name="1788"></a>    exitListerObj = nil
<a name="1789"></a>
<a name="1790"></a>    /* the hint manager, if included in the build */
<a name="1791"></a>    hintManagerObj = nil
<a name="1792"></a>
<a name="1793"></a>    /*
<a name="1794"></a>     *   The game's IFID, as defined in the game's main module ID object.
<a name="1795"></a>     *   If the game has multiple IFIDs in the module list, this will store
<a name="1796"></a>     *   only the first IFID in the list.  NOTE: the library initializes
<a name="1797"></a>     *   this automatically during preinit; don't set this manually.
<a name="1798"></a>     */
<a name="1799"></a>    IFID = nil
<a name="1800"></a>
<a name="1801"></a>    /*
<a name="1802"></a>     *   Command line arguments.  The library sets this to a list of
<a name="1803"></a>     *   strings containing the arguments passed to the program on the
<a name="1804"></a>     *   command line.  This list contains the command line arguments
<a name="1805"></a>     *   parsed according to the local conventions for the operating system
<a name="1806"></a>     *   and C++ library.  The standard parsing procedure used by most
<a name="1807"></a>     *   systems is to break the line into tokens delimited by space
<a name="1808"></a>     *   characters.  Many systems also allow space characters to be
<a name="1809"></a>     *   embedded in tokens by quoting the tokens.  The first argument is
<a name="1810"></a>     *   always the name of the .t3 file currently executing.
<a name="1811"></a>     */
<a name="1812"></a>    commandLineArgs = []
<a name="1813"></a>
<a name="1814"></a>    /*
<a name="1815"></a>     *   Retrieve a "switch" from the command line.  Switches are options
<a name="1816"></a>     *   specifies with the conventional Unix "-xxx" notation.  This
<a name="1817"></a>     *   searches for a command option that equals the given string or
<a name="1818"></a>     *   starts with the given substring.  If we find it, we return the
<a name="1819"></a>     *   part of the option after the given substring - this is
<a name="1820"></a>     *   conventionally the value of the switch.  For example, the command
<a name="1821"></a>     *   line might look like this:
<a name="1822"></a>     *
<a name="1823"></a>     *.    t3run mygame.t3 -name=MyGame -user=Bob
<a name="1824"></a>     *
<a name="1825"></a>     *   Searching for '-name=' would return 'MyGame', and searching for
<a name="1826"></a>     *   '-user=' would return' Bob'.
<a name="1827"></a>     *
<a name="1828"></a>     *   If the switch is found but has no value attached, the return value
<a name="1829"></a>     *   is an empty string.  If the switch isn't found at all, the return
<a name="1830"></a>     *   value is nil.
<a name="1831"></a>     */
<a name="1832"></a>    getCommandSwitch(s)
<a name="1833"></a>    {
<a name="1834"></a>        /* search from argument 2 to the last switch argument */
<a name="1835"></a>        local args = commandLineArgs;
<a name="1836"></a>        for (local i in 2..args.length())
<a name="1837"></a>        {
<a name="1838"></a>            /*
<a name="1839"></a>             *   if this isn't a switch, or is the special "-" last switch
<a name="1840"></a>             *   marker, we're done
<a name="1841"></a>             */
<a name="1842"></a>            local a = args[i];
<a name="1843"></a>            if (!a.startsWith('-') || a == '-')
<a name="1844"></a>                return nil;
<a name="1845"></a>
<a name="1846"></a>            /* check for a match */
<a name="1847"></a>            if (a.startsWith(s))
<a name="1848"></a>                return a.substr(s.length() + 1);
<a name="1849"></a>        }
<a name="1850"></a>
<a name="1851"></a>        /* didn't find it */
<a name="1852"></a>        return nil;
<a name="1853"></a>    }
<a name="1854"></a>;
<a name="1855"></a>
<a name="1856"></a>/* ------------------------------------------------------------------------ */
<a name="1857"></a>/*
<a name="1858"></a> *   FinishType objects are used in finishGameMsg() to indicate what kind
<a name="1859"></a> *   of game-over message to display.  We provide a couple of standard
<a name="1860"></a> *   objects for the most common cases.
<a name="1861"></a> */
<a name="1862"></a>class FinishType: object
<a name="1863"></a>    /* the finishing message, as a string or library message property */
<a name="1864"></a>    finishMsg = nil
<a name="1865"></a>;
<a name="1866"></a>
<a name="1867"></a>/* 'death' - the game has ended due to the player character's demise */
<a name="1868"></a>ftDeath: FinishType finishMsg = &amp;finishDeathMsg;
<a name="1869"></a>
<a name="1870"></a>/* 'victory' - the player has won the game */
<a name="1871"></a>ftVictory: FinishType finishMsg = &amp;finishVictoryMsg;
<a name="1872"></a>
<a name="1873"></a>/* 'failure' - the game has ended in failure (but not necessarily death) */
<a name="1874"></a>ftFailure: FinishType finishMsg = &amp;finishFailureMsg;
<a name="1875"></a>
<a name="1876"></a>/* 'game over' - the game has simply ended */
<a name="1877"></a>ftGameOver: FinishType finishMsg = &amp;finishGameOverMsg;
<a name="1878"></a>
<a name="1879"></a>/*
<a name="1880"></a> *   Finish the game, showing a message explaining why the game has ended.
<a name="1881"></a> *   This can be called when an event occurs that ends the game, such as
<a name="1882"></a> *   the player character's death, winning, or any other endpoint in the
<a name="1883"></a> *   story.
<a name="1884"></a> *
<a name="1885"></a> *   We'll show a message defined by 'msg', using a standard format.  The
<a name="1886"></a> *   format depends on the language, but in English, it's usually the
<a name="1887"></a> *   message surrounded by asterisks: "*** You have won! ***".  'msg' can
<a name="1888"></a> *   be:
<a name="1889"></a> *
<a name="1890"></a> *.    - nil, in which case we display nothing
<a name="1891"></a> *.    - a string, which we'll display as the message
<a name="1892"></a> *.    - a FinishType object, from which we'll get the message
<a name="1893"></a> *
<a name="1894"></a> *   After showing the message (if any), we'll prompt the user with
<a name="1895"></a> *   options for how to proceed.  We'll always show the QUIT, RESTART, and
<a name="1896"></a> *   RESTORE options; other options can be offered by listing one or more
<a name="1897"></a> *   FinishOption objects in the 'extra' parameter, which is given as a
<a name="1898"></a> *   list of FinishOption objects.  The library defines a few non-default
<a name="1899"></a> *   finish options, such as finishOptionUndo and finishOptionCredits; in
<a name="1900"></a> *   addition, the game can subclass FinishOption to create its own custom
<a name="1901"></a> *   options, as desired.
<a name="1902"></a> */
<a name="1903"></a>finishGameMsg(msg, extra)
<a name="1904"></a>{
<a name="1905"></a>    local lst;
<a name="1906"></a>
<a name="1907"></a>    /*
<a name="1908"></a>     *   Adjust the turn counter to take into account the action currently
<a name="1909"></a>     *   in progress, if any, and to reflect any turns that the player
<a name="1910"></a>     *   character has already completed and which aren't yet reflected in
<a name="1911"></a>     *   the turn counter.  If we're processing a daemon, the PC's next
<a name="1912"></a>     *   schedulable run time will already reflect the last turn the PC
<a name="1913"></a>     *   completed, but the global turn counter won't be there yet, since
<a name="1914"></a>     *   we're still scheduling daemons that were ready to run on the same
<a name="1915"></a>     *   turn as the player's last action.
<a name="1916"></a>     */
<a name="1917"></a>    libGlobal.totalTurns = gPlayerChar.nextRunTime + gAction.actionTime;
<a name="1918"></a>
<a name="1919"></a>    /*
<a name="1920"></a>     *   Explicitly run any final score notification now.  This will ensure
<a name="1921"></a>     *   that any points awarded in the course of the final command that
<a name="1922"></a>     *   brought us to this point will generate the usual notification, and
<a name="1923"></a>     *   that the notification will appear at a reasonable place, just
<a name="1924"></a>     *   before the termination message.
<a name="1925"></a>     */
<a name="1926"></a>    if (libGlobal.scoreObj != nil)
<a name="1927"></a>        libGlobal.scoreObj.runScoreNotifier();
<a name="1928"></a>
<a name="1929"></a>    /* translate the message, if specified */
<a name="1930"></a>    if (dataType(msg) == TypeObject)
<a name="1931"></a>    {
<a name="1932"></a>        /* it's a FinishType object - get its message property or string */
<a name="1933"></a>        msg = msg.finishMsg;
<a name="1934"></a>
<a name="1935"></a>        /* if it's a library message property, look it up */
<a name="1936"></a>        if (dataType(msg) == TypeProp)
<a name="1937"></a>            msg = gLibMessages.(msg);
<a name="1938"></a>    }
<a name="1939"></a>
<a name="1940"></a>    /* if we have a message, display it */
<a name="1941"></a>    if (msg != nil)
<a name="1942"></a>        gLibMessages.showFinishMsg(msg);
<a name="1943"></a>
<a name="1944"></a>    /* if the extra options include a scoring option, show the score */
<a name="1945"></a>    if (extra != nil &amp;&amp; extra.indexWhich({x: x.showScoreInFinish}) != nil)
<a name="1946"></a>    {
<a name="1947"></a>        "&lt;.p&gt;";
<a name="1948"></a>        libGlobal.scoreObj.showScore();
<a name="1949"></a>        "&lt;.p&gt;";
<a name="1950"></a>    }
<a name="1951"></a>
<a name="1952"></a>    /*
<a name="1953"></a>     *   Since we need to interact directly with the player, any sense
<a name="1954"></a>     *   context currently in effect is now irrelevant.  Reset the sense
<a name="1955"></a>     *   context by setting the 'source' object to nil to indicate that we
<a name="1956"></a>     *   don't need any sense blocking at all.  We can just set the context
<a name="1957"></a>     *   directly, since this routine will never return into the
<a name="1958"></a>     *   surrounding command processing - we always either terminate the
<a name="1959"></a>     *   program or proceed to a different game context (via undo, restore,
<a name="1960"></a>     *   restart, etc).  By the same token, the actor we're talking to now
<a name="1961"></a>     *   is the player character.
<a name="1962"></a>     */
<a name="1963"></a>    senseContext.setSenseContext(nil, sight);
<a name="1964"></a>    gActor = gPlayerChar;
<a name="1965"></a>
<a name="1966"></a>    /* start with the standard options */
<a name="1967"></a>    lst = [finishOptionRestore, finishOptionRestart];
<a name="1968"></a>
<a name="1969"></a>    /* add any additional options in the 'extra' parameter */
<a name="1970"></a>    if (extra != nil)
<a name="1971"></a>        lst += extra;
<a name="1972"></a>
<a name="1973"></a>    /* always add 'quit' as the last option */
<a name="1974"></a>    lst += finishOptionQuit;
<a name="1975"></a>
<a name="1976"></a>    /* process the options */
<a name="1977"></a>    processOptions(lst);
<a name="1978"></a>}
<a name="1979"></a>
<a name="1980"></a>/* finish the game, offering the given extra options but no message */
<a name="1981"></a>finishGame(extra)
<a name="1982"></a>{
<a name="1983"></a>    finishGameMsg(nil, extra);
<a name="1984"></a>}
<a name="1985"></a>
<a name="1986"></a>/*
<a name="1987"></a> *   Show failed startup restore options.  If a restore operation fails at
<a name="1988"></a> *   startup, we won't just proceed with the game, but ask the user what
<a name="1989"></a> *   they want to do; we'll offer the options of restoring another game,
<a name="1990"></a> *   quitting, or starting the game from the beginning.
<a name="1991"></a> */
<a name="1992"></a>failedRestoreOptions()
<a name="1993"></a>{
<a name="1994"></a>    /* process our set of options */
<a name="1995"></a>    processOptions([restoreOptionRestoreAnother, restoreOptionStartOver,
<a name="1996"></a>                    finishOptionQuit]);
<a name="1997"></a>}
<a name="1998"></a>
<a name="1999"></a>/*
<a name="2000"></a> *   Process a list of finishing options.  We'll loop, showing prompts and
<a name="2001"></a> *   reading responses, until we get a response that terminates the loop.
<a name="2002"></a> */
<a name="2003"></a>processOptions(lst)
<a name="2004"></a>{
<a name="2005"></a>    /* keep going until we get a valid response */
<a name="2006"></a>promptLoop:
<a name="2007"></a>    for (;;)
<a name="2008"></a>    {
<a name="2009"></a>        local resp;
<a name="2010"></a>
<a name="2011"></a>        /* show the options */
<a name="2012"></a>        finishOptionsLister.showListAll(lst, 0, 0);
<a name="2013"></a>
<a name="2014"></a>        /* switch to before-command mode for reading the interactive input */
<a name="2015"></a>        "&lt;.commandbefore&gt;";
<a name="2016"></a>
<a name="2017"></a>        /*
<a name="2018"></a>         *   update the status line, in case the score or turn counter has
<a name="2019"></a>         *   changed (this is especially likely when we first enter this
<a name="2020"></a>         *   loop, since we might have just finished the game with our
<a name="2021"></a>         *   previous action, and that action might well have awarded us
<a name="2022"></a>         *   some points)
<a name="2023"></a>         */
<a name="2024"></a>        statusLine.showStatusLine();
<a name="2025"></a>
<a name="2026"></a>        /* read a response */
<a name="2027"></a>        resp = inputManager.getInputLine(nil, nil);
<a name="2028"></a>
<a name="2029"></a>        /* switch to command-after mode */
<a name="2030"></a>        "&lt;.commandafter&gt;";
<a name="2031"></a>
<a name="2032"></a>        /* check for a match to each of the options in our list */
<a name="2033"></a>        foreach (local cur in lst)
<a name="2034"></a>        {
<a name="2035"></a>            /* if this one matches, process the option */
<a name="2036"></a>            if (cur.responseMatches(resp))
<a name="2037"></a>            {
<a name="2038"></a>                /* it matches - carry out the option */
<a name="2039"></a>                if (cur.doOption())
<a name="2040"></a>                {
<a name="2041"></a>                    /*
<a name="2042"></a>                     *   they returned true - they want to continue asking
<a name="2043"></a>                     *   for more options
<a name="2044"></a>                     */
<a name="2045"></a>                    continue promptLoop;
<a name="2046"></a>                }
<a name="2047"></a>                else
<a name="2048"></a>                {
<a name="2049"></a>                    /*
<a name="2050"></a>                     *   they returned nil - they want us to stop asking
<a name="2051"></a>                     *   for options and return to our caller
<a name="2052"></a>                     */
<a name="2053"></a>                    return;
<a name="2054"></a>                }
<a name="2055"></a>            }
<a name="2056"></a>        }
<a name="2057"></a>
<a name="2058"></a>        /*
<a name="2059"></a>         *   If we got this far, it means that we didn't get a valid
<a name="2060"></a>         *   option.  Display our "invalid option" message, and continue
<a name="2061"></a>         *   looping so that we show the prompt again and read a new
<a name="2062"></a>         *   option.
<a name="2063"></a>         */
<a name="2064"></a>        gLibMessages.invalidFinishOption(resp);
<a name="2065"></a>    }
<a name="2066"></a>}
<a name="2067"></a>
<a name="2068"></a>/*
<a name="2069"></a> *   Finish Option class.  This is the base class for the abstract objects
<a name="2070"></a> *   representing options offered by finishGame.
<a name="2071"></a> */
<a name="2072"></a>class FinishOption: object
<a name="2073"></a>    /*
<a name="2074"></a>     *   The description, as displayed in the list of options.  For the
<a name="2075"></a>     *   default English messages, this is expected to be a verb phrase in
<a name="2076"></a>     *   infinitive form, and should show the keyword accepted as a
<a name="2077"></a>     *   response in all capitals: "RESTART", "see some AMUSING things to
<a name="2078"></a>     *   do", "show CREDITS".
<a name="2079"></a>     */
<a name="2080"></a>    desc = ""
<a name="2081"></a>
<a name="2082"></a>    /*
<a name="2083"></a>     *   By default, the item is listed.  If you want to create an
<a name="2084"></a>     *   invisible option that's accepted but which isn't listed in the
<a name="2085"></a>     *   prompt, just set this to nil.  Invisible options are sometimes
<a name="2086"></a>     *   useful when the output of one option mentions another option; for
<a name="2087"></a>     *   example, the CREDITS message might mention a LICENSE command for
<a name="2088"></a>     *   displaying the license, so you want to make that command available
<a name="2089"></a>     *   without cluttering the prompt with it.
<a name="2090"></a>     */
<a name="2091"></a>    isListed = true
<a name="2092"></a>
<a name="2093"></a>    /* our response keyword */
<a name="2094"></a>    responseKeyword = ''
<a name="2095"></a>
<a name="2096"></a>    /*
<a name="2097"></a>     *   a single character we accept as an alternative to our full
<a name="2098"></a>     *   response keyword, or nil if we don't accept a single-character
<a name="2099"></a>     *   response
<a name="2100"></a>     */
<a name="2101"></a>    responseChar = nil
<a name="2102"></a>
<a name="2103"></a>    /*
<a name="2104"></a>     *   Match a response string to this option.  Returns true if the
<a name="2105"></a>     *   string matches our response, nil otherwise.  By default, we'll
<a name="2106"></a>     *   return true if the string exactly matches responseKeyword or
<a name="2107"></a>     *   exactly matches our responseChar (if that's non-nil), but this
<a name="2108"></a>     *   can be overridden to match other strings if desired.  By default,
<a name="2109"></a>     *   we'll match the response without regard to case.
<a name="2110"></a>     */
<a name="2111"></a>    responseMatches(response)
<a name="2112"></a>    {
<a name="2113"></a>        /* do all of our work in lower-case */
<a name="2114"></a>        response = response.toLower();
<a name="2115"></a>
<a name="2116"></a>        /*
<a name="2117"></a>         *   check for a match the full response keyword or to the single
<a name="2118"></a>         *   response character
<a name="2119"></a>         */
<a name="2120"></a>        return (response == responseKeyword.toLower()
<a name="2121"></a>                || (responseChar != nil
<a name="2122"></a>                    &amp;&amp; response == responseChar.toLower()));
<a name="2123"></a>    }
<a name="2124"></a>
<a name="2125"></a>    /*
<a name="2126"></a>     *   Carry out the option.  This is called when the player enters a
<a name="2127"></a>     *   response that matches this option.  This routine must perform the
<a name="2128"></a>     *   action of the option, then return true to indicate that we should
<a name="2129"></a>     *   ask for another option, or nil to indicate that the finishGame()
<a name="2130"></a>     *   routine should simply return.
<a name="2131"></a>     */
<a name="2132"></a>    doOption()
<a name="2133"></a>    {
<a name="2134"></a>        /* tell finishGame() to ask for another option */
<a name="2135"></a>        return true;
<a name="2136"></a>    }
<a name="2137"></a>
<a name="2138"></a>    /*
<a name="2139"></a>     *   Flag: show the score with the end-of-game announcement.  If any
<a name="2140"></a>     *   option in the list of finishing options has this flag set, we'll
<a name="2141"></a>     *   show the score using the same message that the SCORE command
<a name="2142"></a>     *   uses.
<a name="2143"></a>     */
<a name="2144"></a>    showScoreInFinish = nil
<a name="2145"></a>;
<a name="2146"></a>
<a name="2147"></a>/*
<a name="2148"></a> *   QUIT option for finishGame.  The language-specific code should modify
<a name="2149"></a> *   this to specify the description and response keywords.
<a name="2150"></a> */
<a name="2151"></a>finishOptionQuit: FinishOption
<a name="2152"></a>    doOption()
<a name="2153"></a>    {
<a name="2154"></a>        /*
<a name="2155"></a>         *   carry out the Quit action - this will signal a
<a name="2156"></a>         *   QuittingException, so this call will never return
<a name="2157"></a>         */
<a name="2158"></a>        QuitAction.terminateGame();
<a name="2159"></a>    }
<a name="2160"></a>;
<a name="2161"></a>
<a name="2162"></a>/*
<a name="2163"></a> *   RESTORE option for finishGame.
<a name="2164"></a> */
<a name="2165"></a>finishOptionRestore: FinishOption
<a name="2166"></a>    doOption()
<a name="2167"></a>    {
<a name="2168"></a>        /*
<a name="2169"></a>         *   Try restoring.  If this succeeds (i.e., it returns true), tell
<a name="2170"></a>         *   the caller to stop looping and to proceed with the game by
<a name="2171"></a>         *   returning nil.  If this fails, tell the caller to keep looping
<a name="2172"></a>         *   by returning true.
<a name="2173"></a>         */
<a name="2174"></a>        if (RestoreAction.askAndRestore())
<a name="2175"></a>        {
<a name="2176"></a>            /*
<a name="2177"></a>             *   we succeeded, so we're now restored to some prior game
<a name="2178"></a>             *   state - terminate any remaining processing in the command
<a name="2179"></a>             *   that triggered the end-of-game options
<a name="2180"></a>             */
<a name="2181"></a>            throw new TerminateCommandException();
<a name="2182"></a>        }
<a name="2183"></a>        else
<a name="2184"></a>        {
<a name="2185"></a>            /* it failed - tell the caller to keep looping */
<a name="2186"></a>            return true;
<a name="2187"></a>        }
<a name="2188"></a>    }
<a name="2189"></a>;
<a name="2190"></a>
<a name="2191"></a>/*
<a name="2192"></a> *   RESTART option for finishGame
<a name="2193"></a> */
<a name="2194"></a>finishOptionRestart: FinishOption
<a name="2195"></a>    doOption()
<a name="2196"></a>    {
<a name="2197"></a>        /*
<a name="2198"></a>         *   carry out the restart - this will not return, since we'll
<a name="2199"></a>         *   reset the game state and re-enter the game at the restart
<a name="2200"></a>         *   entrypoint
<a name="2201"></a>         */
<a name="2202"></a>        RestartAction.doRestartGame();
<a name="2203"></a>    }
<a name="2204"></a>;
<a name="2205"></a>
<a name="2206"></a>/*
<a name="2207"></a> *   START FROM BEGINNING option for failed startup restore.  This is just
<a name="2208"></a> *   like finishOptionRestart, but shows a different option name.
<a name="2209"></a> */
<a name="2210"></a>restoreOptionStartOver: finishOptionRestart
<a name="2211"></a>;
<a name="2212"></a>
<a name="2213"></a>/*
<a name="2214"></a> *   RESTORE ANOTHER GAME option for failed startup restore.  This is just
<a name="2215"></a> *   like finishOptionRestore, but shows a different option name.
<a name="2216"></a> */
<a name="2217"></a>restoreOptionRestoreAnother: finishOptionRestore
<a name="2218"></a>;
<a name="2219"></a>
<a name="2220"></a>/*
<a name="2221"></a> *   UNDO option for finishGame
<a name="2222"></a> */
<a name="2223"></a>finishOptionUndo: FinishOption
<a name="2224"></a>    doOption()
<a name="2225"></a>    {
<a name="2226"></a>        /* try performing the undo */
<a name="2227"></a>        if (UndoAction.performUndo(nil))
<a name="2228"></a>        {
<a name="2229"></a>            /* act as though UNDO were the last actual command, for AGAIN */
<a name="2230"></a>            AgainAction.saveForAgain(gPlayerChar, gPlayerChar,
<a name="2231"></a>                                     nil, UndoAction);
<a name="2232"></a>
<a name="2233"></a>            /*
<a name="2234"></a>             *   Success - terminate the current command with no further
<a name="2235"></a>             *   processing.
<a name="2236"></a>             */
<a name="2237"></a>            throw new TerminateCommandException();
<a name="2238"></a>        }
<a name="2239"></a>        else
<a name="2240"></a>        {
<a name="2241"></a>            /*
<a name="2242"></a>             *   failure - show a blank line and tell the caller to ask
<a name="2243"></a>             *   for another option, since we couldn't carry out this
<a name="2244"></a>             *   option
<a name="2245"></a>             */
<a name="2246"></a>            "&lt;.p&gt;";
<a name="2247"></a>            return true;
<a name="2248"></a>        }
<a name="2249"></a>    }
<a name="2250"></a>;
<a name="2251"></a>
<a name="2252"></a>/*
<a name="2253"></a> *   FULL SCORE option for finishGame
<a name="2254"></a> */
<a name="2255"></a>finishOptionFullScore: FinishOption
<a name="2256"></a>    doOption()
<a name="2257"></a>    {
<a name="2258"></a>        /* show a blank line before the score display */
<a name="2259"></a>        "\b";
<a name="2260"></a>
<a name="2261"></a>        /* run the Full Score action */
<a name="2262"></a>        FullScoreAction.showFullScore();
<a name="2263"></a>
<a name="2264"></a>        /* show a paragraph break after the score display */
<a name="2265"></a>        "&lt;.p&gt;";
<a name="2266"></a>
<a name="2267"></a>        /*
<a name="2268"></a>         *   this option has now had its full effect, so tell the caller
<a name="2269"></a>         *   to go back and ask for a new option
<a name="2270"></a>         */
<a name="2271"></a>        return true;
<a name="2272"></a>    }
<a name="2273"></a>
<a name="2274"></a>    /*
<a name="2275"></a>     *   by default, show the score with the end-of-game announcement when
<a name="2276"></a>     *   this option is included
<a name="2277"></a>     */
<a name="2278"></a>    showScoreInFinish = true
<a name="2279"></a>;
<a name="2280"></a>
<a name="2281"></a>/*
<a name="2282"></a> *   Option to show the score in finishGame.  This doesn't create a listed
<a name="2283"></a> *   option in the set of offered options, but rather is simply a flag to
<a name="2284"></a> *   finishGame() that the score should be announced along with the
<a name="2285"></a> *   end-of-game announcement message.
<a name="2286"></a> */
<a name="2287"></a>finishOptionScore: FinishOption
<a name="2288"></a>    /* show the score in the end-of-game announcement */
<a name="2289"></a>    showScoreInFinish = true
<a name="2290"></a>
<a name="2291"></a>    /* this is not a listed option */
<a name="2292"></a>    isListed = nil
<a name="2293"></a>
<a name="2294"></a>    /* this option isn't selectable, so it has no effect */
<a name="2295"></a>    doOption() { }
<a name="2296"></a>;
<a name="2297"></a>
<a name="2298"></a>/*
<a name="2299"></a> *   CREDITS option for finishGame
<a name="2300"></a> */
<a name="2301"></a>finishOptionCredits: FinishOption
<a name="2302"></a>    doOption()
<a name="2303"></a>    {
<a name="2304"></a>        /* show a blank line before the credits */
<a name="2305"></a>        "\b";
<a name="2306"></a>
<a name="2307"></a>        /* run the Credits action */
<a name="2308"></a>        CreditsAction.execSystemAction();
<a name="2309"></a>
<a name="2310"></a>        /* show a paragraph break after the credits */
<a name="2311"></a>        "&lt;.p&gt;";
<a name="2312"></a>
<a name="2313"></a>        /*
<a name="2314"></a>         *   this option has now had its full effect, so tell the caller
<a name="2315"></a>         *   to go back and ask for a new option
<a name="2316"></a>         */
<a name="2317"></a>        return true;
<a name="2318"></a>    }
<a name="2319"></a>;
<a name="2320"></a>
<a name="2321"></a>/*
<a name="2322"></a> *   AMUSING option for finishGame
<a name="2323"></a> */
<a name="2324"></a>finishOptionAmusing: FinishOption
<a name="2325"></a>    /*
<a name="2326"></a>     *   The game must modify this object to define a doOption method.  We
<a name="2327"></a>     *   have no built-in way to show a list of amusing things to try, so
<a name="2328"></a>     *   if a game wants to offer this option, it must provide a suitable
<a name="2329"></a>     *   definition here.  (We never offer this option by default, so a
<a name="2330"></a>     *   game need not provide a definition if the game doesn't explicitly
<a name="2331"></a>     *   offer this option via the 'extra' argument to finishGame()).
<a name="2332"></a>     */
<a name="2333"></a>;
<a name="2334"></a>
<a name="2335"></a>/* ------------------------------------------------------------------------ */
<a name="2336"></a>/*
<a name="2337"></a> *   The settings user interface.  This is a subclass of the Settings
<a name="2338"></a> *   Manager that adds a command-line user interface, particularly to allow
<a name="2339"></a> *   the user to view, save, and load the default settings.
<a name="2340"></a> *
<a name="2341"></a> *   Our user interface consists mainly of a pair of special commands: SAVE
<a name="2342"></a> *   DEFAULTS and RESTORE DEFAULTS.  The SAVE DEFAULTS command tells the
<a name="2343"></a> *   library to write out all of the current settings (at least, all of
<a name="2344"></a> *   those that participate in this framework) to a file.  RESTORE DEFAULTS
<a name="2345"></a> *   explicitly reads that same file and puts the stored settings into
<a name="2346"></a> *   effect.  Finally, we'll also read the file and activate its stored
<a name="2347"></a> *   settings when we start (or RESTART) the game.
<a name="2348"></a> *
<a name="2349"></a> */
<a name="2350"></a>settingsUI: settingsManager
<a name="2351"></a>    /* display all of the current settings */
<a name="2352"></a>    showAll()
<a name="2353"></a>    {
<a name="2354"></a>        local first = true;
<a name="2355"></a>
<a name="2356"></a>        /* loop over all SettingsItem instances */
<a name="2357"></a>        forEachInstance(SettingsItem, function(item)
<a name="2358"></a>        {
<a name="2359"></a>            /* include only items that want to participate in the listing */
<a name="2360"></a>            if (item.includeInListing)
<a name="2361"></a>            {
<a name="2362"></a>                /* add a separator if this isn't the first one */
<a name="2363"></a>                if (!first)
<a name="2364"></a>                    gLibMessages.settingsItemSeparator;
<a name="2365"></a>
<a name="2366"></a>                /* show this item's description */
<a name="2367"></a>                item.settingDesc;
<a name="2368"></a>
<a name="2369"></a>                /* it's no longer the first */
<a name="2370"></a>                first = nil;
<a name="2371"></a>            }
<a name="2372"></a>        });
<a name="2373"></a>    }
<a name="2374"></a>
<a name="2375"></a>    /*
<a name="2376"></a>     *   Save settings, and display an acknowledgment message (or an error
<a name="2377"></a>     *   message, if necessary) for the user's edification.
<a name="2378"></a>     */
<a name="2379"></a>    saveSettingsMsg()
<a name="2380"></a>    {
<a name="2381"></a>        /* catch any errors */
<a name="2382"></a>        try
<a name="2383"></a>        {
<a name="2384"></a>            /* save the settings */
<a name="2385"></a>            saveSettings();
<a name="2386"></a>
<a name="2387"></a>            /* if we got this far, declare success */
<a name="2388"></a>            gLibMessages.savedDefaults();
<a name="2389"></a>        }
<a name="2390"></a>        catch (Exception exc)
<a name="2391"></a>        {
<a name="2392"></a>            /* we couldn't open the file */
<a name="2393"></a>            gLibMessages.defaultsFileWriteError;
<a name="2394"></a>        }
<a name="2395"></a>    }
<a name="2396"></a>
<a name="2397"></a>    /*
<a name="2398"></a>     *   Restore settings, and display an acknowledgment or error message,
<a name="2399"></a>     *   as appropriate.
<a name="2400"></a>     */
<a name="2401"></a>    restoreSettingsMsg()
<a name="2402"></a>    {
<a name="2403"></a>        /* catch any errors */
<a name="2404"></a>        try
<a name="2405"></a>        {
<a name="2406"></a>            /* restore the settings */
<a name="2407"></a>            restoreSettings();
<a name="2408"></a>
<a name="2409"></a>            /* if we got this far, declare success */
<a name="2410"></a>            gLibMessages.restoredDefaults();
<a name="2411"></a>        }
<a name="2412"></a>        catch (SettingsNotSupportedException sns)
<a name="2413"></a>        {
<a name="2414"></a>            /* this interpreter doesn't support the settings file */
<a name="2415"></a>            gLibMessages.defaultsFileNotSupported;
<a name="2416"></a>        }
<a name="2417"></a>        catch (Exception exc)
<a name="2418"></a>        {
<a name="2419"></a>            /* display other errors */
<a name="2420"></a>            gLibMessages.defaultsFileReadError(exc);
<a name="2421"></a>        }
<a name="2422"></a>    }
<a name="2423"></a>;
<a name="2424"></a>
<a name="2425"></a>/* ------------------------------------------------------------------------ */
<a name="2426"></a>/*
<a name="2427"></a> *   Utility functions
<a name="2428"></a> */
<a name="2429"></a>
<a name="2430"></a>/*
<a name="2431"></a> *   nilToList - convert a 'nil' value to an empty list.  This can be
<a name="2432"></a> *   useful for mix-in classes that will be used in different inheritance
<a name="2433"></a> *   contexts, since the classes might or might not inherit a base class
<a name="2434"></a> *   definition for list-valued methods such as preconditions.  This
<a name="2435"></a> *   provides a usable default for list-valued methods that return nothing
<a name="2436"></a> *   from superclasses.
<a name="2437"></a> */
<a name="2438"></a>nilToList(val)
<a name="2439"></a>{
<a name="2440"></a>    return (val != nil ? val : []);
<a name="2441"></a>}
<a name="2442"></a>
<a name="2443"></a>/*
<a name="2444"></a> *   partitionList - partition a list into a pair of two lists, the first
<a name="2445"></a> *   containing items that match the predicate 'fn', the second containing
<a name="2446"></a> *   items that don't match 'fn'.  'fn' is a function pointer (usually an
<a name="2447"></a> *   anonymous function) that takes a single argument - a list element -
<a name="2448"></a> *   and returns true or nil.
<a name="2449"></a> *
<a name="2450"></a> *   The return value is a list with two elements.  The first element is a
<a name="2451"></a> *   list giving the elements of the original list for which 'fn' returns
<a name="2452"></a> *   true, the second element is a list giving the elements for which 'fn'
<a name="2453"></a> *   returns nil.
<a name="2454"></a> *
<a name="2455"></a> *   (Contributed by Tommy Nordgren.)
<a name="2456"></a> */
<a name="2457"></a>partitionList(lst, fn)
<a name="2458"></a>{
<a name="2459"></a>    local lst1 = lst.subset(fn);
<a name="2460"></a>    local lst2 = lst.subset({x : !fn(x)});
<a name="2461"></a>
<a name="2462"></a>    return [lst1, lst2];
<a name="2463"></a>}
<a name="2464"></a>
<a name="2465"></a>/*
<a name="2466"></a> *   Determine if list a is a subset of list b.  a is a subset of b if
<a name="2467"></a> *   every element of a is in b.
<a name="2468"></a> */
<a name="2469"></a>isListSubset(a, b)
<a name="2470"></a>{
<a name="2471"></a>    /* a can't be a subset if it has more elements than b */
<a name="2472"></a>    if (a.length() &gt; b.length())
<a name="2473"></a>        return nil;
<a name="2474"></a>
<a name="2475"></a>    /* check each element of a to see if it's also in b */
<a name="2476"></a>    foreach (local cur in a)
<a name="2477"></a>    {
<a name="2478"></a>        /* if this element of a is not in b, a is not a subset of b */
<a name="2479"></a>        if (b.indexOf(cur) == nil)
<a name="2480"></a>            return nil;
<a name="2481"></a>    }
<a name="2482"></a>
<a name="2483"></a>    /*
<a name="2484"></a>     *   we didn't find any elements of a that are not also in b, so a is a
<a name="2485"></a>     *   subset of b
<a name="2486"></a>     */
<a name="2487"></a>    return true;
<a name="2488"></a>}
<a name="2489"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
