<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>exec.t</title></head><body>
<table class=ban><tr><td><h1>exec.t</h1><td align=right><a href="../file/exec.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *
<a name="6"></a> *   TADS 3 Library: command execution
<a name="7"></a> *
<a name="8"></a> *   This module defines functions that perform command execution.
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>#include "adv3.h"
<a name="12"></a>
<a name="13"></a>
<a name="14"></a>/* ------------------------------------------------------------------------ */
<a name="15"></a>/*
<a name="16"></a> *   Execute a command line, as issued by the given actor and as given as a
<a name="17"></a> *   list of tokens.
<a name="18"></a> *
<a name="19"></a> *   If 'firstInSentence' is true, we're at the start of a "sentence."  The
<a name="20"></a> *   meaning and effect of this may vary by language.  In English, a
<a name="21"></a> *   sentence ends with certain punctuation marks (a period, semicolon,
<a name="22"></a> *   exclamation mark, or question mark), so anything after one of these
<a name="23"></a> *   punctuation marks is the start of a new sentence.  Also in English, we
<a name="24"></a> *   can address a command to an explicit target actor using the "actor,"
<a name="25"></a> *   prefix syntax, which we can't use except at the start of a sentence.
<a name="26"></a> *
<a name="27"></a> *   If the command line consists of multiple commands, we will only
<a name="28"></a> *   actually execute the first command before returning.  We'll schedule
<a name="29"></a> *   any additional commands for later execution by putting them into the
<a name="30"></a> *   target actor's pending command queue before we return, but we won't
<a name="31"></a> *   actually execute them.
<a name="32"></a> */
<a name="33"></a>executeCommand(targetActor, issuingActor, toks, firstInSentence)
<a name="34"></a>{
<a name="35"></a>    local actorPhrase;
<a name="36"></a>    local actorSpecified;
<a name="37"></a>
<a name="38"></a>    /*
<a name="39"></a>     *   Turn on sense caching while we're working, until execution
<a name="40"></a>     *   begins.  The parsing and resolution phases of command processing
<a name="41"></a>     *   don't involve any changes to game state, so we can safely cache
<a name="42"></a>     *   sense information; caching sense information during these phases
<a name="43"></a>     *   is desirable because these steps (noun resolution in particular)
<a name="44"></a>     *   involve repeated inspection of the current sensory environment,
<a name="45"></a>     *   which can require expensive calculations.
<a name="46"></a>     */
<a name="47"></a>    libGlobal.enableSenseCache();
<a name="48"></a>
<a name="49"></a>    /* we don't have an explicit actor phrase yet */
<a name="50"></a>    actorPhrase = nil;
<a name="51"></a>
<a name="52"></a>    /* presume an actor will not be specified */
<a name="53"></a>    actorSpecified = nil;
<a name="54"></a>
<a name="55"></a>    /*
<a name="56"></a>     *   If this is the start of a new sentence, and the issuing actor
<a name="57"></a>     *   wants to cancel any target actor designation at the end of each
<a name="58"></a>     *   sentence, change the target actor back to the issuing actor.
<a name="59"></a>     */
<a name="60"></a>    if (firstInSentence
<a name="61"></a>        &amp;&amp; issuingActor != targetActor
<a name="62"></a>        &amp;&amp; issuingActor.revertTargetActorAtEndOfSentence)
<a name="63"></a>    {
<a name="64"></a>        /* switch to the target actor */
<a name="65"></a>        targetActor = issuingActor;
<a name="66"></a>
<a name="67"></a>        /* switch to the issuer's sense context */
<a name="68"></a>        senseContext.setSenseContext(issuingActor, sight);
<a name="69"></a>    }
<a name="70"></a>
<a name="71"></a>    /*
<a name="72"></a>     *   Keep going until we've processed the command.  This might take
<a name="73"></a>     *   several iterations, because we might have replacement commands to
<a name="74"></a>     *   execute.
<a name="75"></a>     */
<a name="76"></a>parseTokenLoop:
<a name="77"></a>    for (;;)
<a name="78"></a>    {
<a name="79"></a>        local lst;
<a name="80"></a>        local action;
<a name="81"></a>        local match;
<a name="82"></a>        local nextIdx;
<a name="83"></a>        local nextCommandTokens;
<a name="84"></a>        local extraIdx;
<a name="85"></a>        local extraTokens;
<a name="86"></a>
<a name="87"></a>        /*
<a name="88"></a>         *   Catch any errors that occur while executing the command,
<a name="89"></a>         *   since some of them are signals to us that we should reparse
<a name="90"></a>         *   some new text read or generated deep down inside the command
<a name="91"></a>         *   processing.
<a name="92"></a>         */
<a name="93"></a>        try
<a name="94"></a>        {
<a name="95"></a>            local rankings;
<a name="96"></a>
<a name="97"></a>            /* we have no extra tokens yet */
<a name="98"></a>            extraTokens = [];
<a name="99"></a>
<a name="100"></a>            /*
<a name="101"></a>             *   Parse the token list.  If this is the first command on
<a name="102"></a>             *   the command line, allow an actor prefix.  Otherwise, just
<a name="103"></a>             *   look for a command.
<a name="104"></a>             */
<a name="105"></a>            lst = (firstInSentence ? firstCommandPhrase : commandPhrase)
<a name="106"></a>                  .parseTokens(toks, cmdDict);
<a name="107"></a>
<a name="108"></a>            /*
<a name="109"></a>             *   As a first cut at reducing the list of possible matches
<a name="110"></a>             *   to those that make sense, eliminate from this list any
<a name="111"></a>             *   matches which do not have valid actions.  In grammars for
<a name="112"></a>             *   "scrambling" languages (i.e., languages with flexible
<a name="113"></a>             *   word ordering), it is possible to construct commands that
<a name="114"></a>             *   fit the grammatical rules of sentence construction but
<a name="115"></a>             *   which make no sense because of the specific constraints
<a name="116"></a>             *   of the verbs involved; we can filter out such nonsense
<a name="117"></a>             *   interpretations immediately by keeping only those
<a name="118"></a>             *   structural interpretations that can resolve to valid
<a name="119"></a>             *   actions.
<a name="120"></a>             */
<a name="121"></a>            lst = lst.subset(
<a name="122"></a>                {x: x.resolveFirstAction(issuingActor, targetActor) != nil});
<a name="123"></a>
<a name="124"></a>            /* if we have no matches, the command isn't understood */
<a name="125"></a>            if (lst.length() == 0)
<a name="126"></a>            {
<a name="127"></a>                /*
<a name="128"></a>                 *   If this is a first-in-sentence phrase, try looking for
<a name="129"></a>                 *   a target actor phrase.  If we can find one, we can
<a name="130"></a>                 *   direct the 'oops' to that actor, to allow the game to
<a name="131"></a>                 *   customize messages more specifically.
<a name="132"></a>                 */
<a name="133"></a>                if (firstInSentence)
<a name="134"></a>                {
<a name="135"></a>                    local i;
<a name="136"></a>
<a name="137"></a>                    /* try parsing an "actor, &lt;unknown&gt;" phrase */
<a name="138"></a>                    lst = actorBadCommandPhrase.parseTokens(toks, cmdDict);
<a name="139"></a>
<a name="140"></a>                    /* if we got any matches, try to resolve actors */
<a name="141"></a>                    lst = lst.mapAll({x: x.resolveNouns(
<a name="142"></a>                        issuingActor, issuingActor,
<a name="143"></a>                        new TryAsActorResolveResults())});
<a name="144"></a>
<a name="145"></a>                    /* drop any that didn't yield any results */
<a name="146"></a>                    lst = lst.subset({x: x != nil &amp;&amp; x.length() != 0});
<a name="147"></a>
<a name="148"></a>                    /*
<a name="149"></a>                     *
<a name="150"></a>                     *   if anything's left, and one of the entries
<a name="151"></a>                     *   resolves to an actor, arbitrarily pick the
<a name="152"></a>                     *   first such entry use the resolved actor as the
<a name="153"></a>                     *   new target actor
<a name="154"></a>                     */
<a name="155"></a>                    if (lst.length() != 0
<a name="156"></a>                        &amp;&amp; (i = lst.indexWhich(
<a name="157"></a>                            {x: x[1].obj_.ofKind(Actor)})) != nil)
<a name="158"></a>                        targetActor = lst[i][1].obj_;
<a name="159"></a>                }
<a name="160"></a>
<a name="161"></a>                /*
<a name="162"></a>                 *   We don't understand the command.  Check for unknown
<a name="163"></a>                 *   words - if we have any, give them a chance to use
<a name="164"></a>                 *   OOPS to correct a typo.
<a name="165"></a>                 */
<a name="166"></a>                tryOops(toks, issuingActor, targetActor,
<a name="167"></a>                        1, toks, rmcCommand);
<a name="168"></a>
<a name="169"></a>                /*
<a name="170"></a>                 *   try running it by the SpecialTopic history to see if
<a name="171"></a>                 *   they're trying to use a special topic in the wrong
<a name="172"></a>                 *   context - if so, explain that they can't use the
<a name="173"></a>                 *   command right now, rather than claiming that the
<a name="174"></a>                 *   command is completely invalid
<a name="175"></a>                 */
<a name="176"></a>                if (specialTopicHistory.checkHistory(toks))
<a name="177"></a>                {
<a name="178"></a>                    /* the special command is not currently available */
<a name="179"></a>                    targetActor.notifyParseFailure(
<a name="180"></a>                        issuingActor, &amp;specialTopicInactive, []);
<a name="181"></a>                }
<a name="182"></a>                else
<a name="183"></a>                {
<a name="184"></a>                    /* tell the issuer we didn't understand the command */
<a name="185"></a>                    targetActor.notifyParseFailure(
<a name="186"></a>                        issuingActor, &amp;commandNotUnderstood, []);
<a name="187"></a>                }
<a name="188"></a>
<a name="189"></a>                /*
<a name="190"></a>                 *   we're done with this command, and we want to abort
<a name="191"></a>                 *   any subsequent commands on the command line
<a name="192"></a>                 */
<a name="193"></a>                return;
<a name="194"></a>            }
<a name="195"></a>
<a name="196"></a>            /* show the matches if we're in debug mode */
<a name="197"></a>            dbgShowGrammarList(lst);
<a name="198"></a>
<a name="199"></a>            /*
<a name="200"></a>             *   Perform a tentative resolution on each alternative
<a name="201"></a>             *   structural interpretation of the command, and rank the
<a name="202"></a>             *   interpretations in order of "goodness" as determined by
<a name="203"></a>             *   our ranking criteria encoded in CommandRanking.
<a name="204"></a>             *
<a name="205"></a>             *   Note that we perform the tentative resolution and ranking
<a name="206"></a>             *   even if we have only one interpretation, because the
<a name="207"></a>             *   tentative resolution is often useful for the final
<a name="208"></a>             *   resolution pass.
<a name="209"></a>             */
<a name="210"></a>            rankings = CommandRanking
<a name="211"></a>                       .sortByRanking(lst, issuingActor, targetActor);
<a name="212"></a>
<a name="213"></a>            /*
<a name="214"></a>             *   Take the interpretation that came up best in the rankings
<a name="215"></a>             *   (or, if we have multiple at the same ranking, arbitrarily
<a name="216"></a>             *   pick the one that happened to come up first in the list)
<a name="217"></a>             *   - they're ranked in descending order of goodness, so take
<a name="218"></a>             *   the first one.
<a name="219"></a>             */
<a name="220"></a>            match = rankings[1].match;
<a name="221"></a>
<a name="222"></a>            /* if we're in debug mode, show the winner */
<a name="223"></a>            dbgShowGrammarWithCaption('Winner', match);
<a name="224"></a>
<a name="225"></a>            /*
<a name="226"></a>             *   Get the token list for the rest of the command after what
<a name="227"></a>             *   we've parsed so far.
<a name="228"></a>             *
<a name="229"></a>             *   Note that we'll start over and parse these tokens anew,
<a name="230"></a>             *   even though we might have parsed them already into a
<a name="231"></a>             *   subcommand on the previous iteration.  Even if we already
<a name="232"></a>             *   parsed these tokens, we want to parse them again, because
<a name="233"></a>             *   we did not have a suitable context for evaluating the
<a name="234"></a>             *   semantic strengths of the possible structural
<a name="235"></a>             *   interpretations this command on the previous iteration;
<a name="236"></a>             *   for example, it was not possible to resolve noun phrases
<a name="237"></a>             *   in this command because we could not guess what the scope
<a name="238"></a>             *   would be when we got to this point.  So, we'll simply
<a name="239"></a>             *   discard the previous match tree, and start over, treating
<a name="240"></a>             *   the new tokens as a brand new command.
<a name="241"></a>             */
<a name="242"></a>            nextIdx = match.getNextCommandIndex();
<a name="243"></a>            nextCommandTokens = toks.sublist(nextIdx);
<a name="244"></a>
<a name="245"></a>            /* if the pending command list is empty, make it nil */
<a name="246"></a>            if (nextCommandTokens.length() == 0)
<a name="247"></a>                nextCommandTokens = nil;
<a name="248"></a>
<a name="249"></a>            /*
<a name="250"></a>             *   Get the part of the token list that the match doesn't use
<a name="251"></a>             *   at all.  These are the tokens following the tokens we
<a name="252"></a>             *   matched.
<a name="253"></a>             */
<a name="254"></a>            extraIdx = match.tokenList.length() + 1;
<a name="255"></a>            extraTokens = toks.sublist(extraIdx);
<a name="256"></a>
<a name="257"></a>            /*
<a name="258"></a>             *   We now have the best match for the command tree.
<a name="259"></a>             *
<a name="260"></a>             *   If the command has an actor clause, resolve the actor, so
<a name="261"></a>             *   that we can direct the command to that actor.  If the
<a name="262"></a>             *   command has no actor clause, the command is to the actor
<a name="263"></a>             *   who issued the command.
<a name="264"></a>             *
<a name="265"></a>             *   Do NOT process the actor clause if we've already done so.
<a name="266"></a>             *   If we edit the token list and retry the command after
<a name="267"></a>             *   this point, there is no need to resolve the actor part
<a name="268"></a>             *   again.  Doing so could be bad - if resolving the actor
<a name="269"></a>             *   required player interaction, such as asking for help with
<a name="270"></a>             *   an ambiguous noun phrase, we do not want to go through
<a name="271"></a>             *   the same interaction again just because we have to edit
<a name="272"></a>             *   and retry a later part of the command.
<a name="273"></a>             */
<a name="274"></a>            if (match.hasTargetActor())
<a name="275"></a>            {
<a name="276"></a>                local actorResults;
<a name="277"></a>
<a name="278"></a>                /*
<a name="279"></a>                 *   If we haven't yet explicitly specified a target
<a name="280"></a>                 *   actor, and the default target actor is different from
<a name="281"></a>                 *   the issuing actor, then this is really a new command
<a name="282"></a>                 *   from the issuing actor.
<a name="283"></a>                 *
<a name="284"></a>                 *   First, an actor change mid-command is allowed only if
<a name="285"></a>                 *   the issuing actor waits for NPC commands to be
<a name="286"></a>                 *   carried out; if not, then we can't change the actor
<a name="287"></a>                 *   mid-command.
<a name="288"></a>                 *
<a name="289"></a>                 *   Second, since the command comes from the issuing
<a name="290"></a>                 *   actor, not from the default target actor, we want to
<a name="291"></a>                 *   issue the orders on the issuing actor's turn, so put
<a name="292"></a>                 *   the command into the queue for the issuer, and let
<a name="293"></a>                 *   the issuer re-parse the command on the issuer's next
<a name="294"></a>                 *   turn.
<a name="295"></a>                 */
<a name="296"></a>                if (!actorSpecified &amp;&amp; issuingActor != targetActor)
<a name="297"></a>                {
<a name="298"></a>                    /*
<a name="299"></a>                     *   don't allow the command if the issuing actor
<a name="300"></a>                     *   doesn't wait for orders to be completed
<a name="301"></a>                     */
<a name="302"></a>                    if (!issuingActor.issueCommandsSynchronously)
<a name="303"></a>                    {
<a name="304"></a>                        /* turn off any sense capturing */
<a name="305"></a>                        senseContext.setSenseContext(nil, sight);
<a name="306"></a>
<a name="307"></a>                        /* show the error */
<a name="308"></a>                        issuingActor.getParserMessageObj()
<a name="309"></a>                            .cannotChangeActor();
<a name="310"></a>
<a name="311"></a>                        /* done */
<a name="312"></a>                        return;
<a name="313"></a>                    }
<a name="314"></a>
<a name="315"></a>                    /* put the command into the issuer's queue */
<a name="316"></a>                    issuingActor.addFirstPendingCommand(
<a name="317"></a>                        firstInSentence, issuingActor, toks);
<a name="318"></a>
<a name="319"></a>                    /* done */
<a name="320"></a>                    return;
<a name="321"></a>                }
<a name="322"></a>
<a name="323"></a>                /* create an actor-specialized results object */
<a name="324"></a>                actorResults = new ActorResolveResults();
<a name="325"></a>
<a name="326"></a>                /* set up the actors in the results object */
<a name="327"></a>                actorResults.setActors(targetActor, issuingActor);
<a name="328"></a>
<a name="329"></a>                /* resolve the actor object */
<a name="330"></a>                match.resolveNouns(issuingActor, targetActor, actorResults);
<a name="331"></a>
<a name="332"></a>                /* get the target actor from the command */
<a name="333"></a>                targetActor = match.getTargetActor();
<a name="334"></a>
<a name="335"></a>                /* pull out the phrase specifying the actor */
<a name="336"></a>                actorPhrase = match.getActorPhrase();
<a name="337"></a>
<a name="338"></a>                /*
<a name="339"></a>                 *   Copy antecedents from the issuing actor to the target
<a name="340"></a>                 *   actor.  Since the issuer is giving us a new command
<a name="341"></a>                 *   here, pronouns will be given from the issuer's
<a name="342"></a>                 *   perspective.
<a name="343"></a>                 */
<a name="344"></a>                targetActor.copyPronounAntecedentsFrom(issuingActor);
<a name="345"></a>
<a name="346"></a>                /* let the actor phrase know we're actually using it */
<a name="347"></a>                match.execActorPhrase(issuingActor);
<a name="348"></a>
<a name="349"></a>                /*
<a name="350"></a>                 *   Ask the target actor if it's interested in the
<a name="351"></a>                 *   command at all.  This only applies when the actor was
<a name="352"></a>                 *   actually specified - if an actor wasn't specified,
<a name="353"></a>                 *   the command is either directed to the issuer itself,
<a name="354"></a>                 *   in which case the command will always be accepted; or
<a name="355"></a>                 *   the command is a continuation of a command line
<a name="356"></a>                 *   previously accepted.
<a name="357"></a>                 */
<a name="358"></a>                if (!targetActor.acceptCommand(issuingActor))
<a name="359"></a>                {
<a name="360"></a>                    /*
<a name="361"></a>                     *   the command was immediately rejected - abandon
<a name="362"></a>                     *   the command and any subsequent commands on the
<a name="363"></a>                     *   same line
<a name="364"></a>                     */
<a name="365"></a>                    return;
<a name="366"></a>                }
<a name="367"></a>
<a name="368"></a>                /* note that an actor was specified */
<a name="369"></a>                actorSpecified = true;
<a name="370"></a>
<a name="371"></a>                /*
<a name="372"></a>                 *   Pull out the rest of the command (other than the
<a name="373"></a>                 *   target actor specification) and start over with a
<a name="374"></a>                 *   fresh parse of the whole thing.  We must do this
<a name="375"></a>                 *   because our tentative resolution pass that we used to
<a name="376"></a>                 *   pick the best structural interpretation of the
<a name="377"></a>                 *   command couldn't go far enough - since we didn't know
<a name="378"></a>                 *   the actor involved, we weren't able to resolve nouns
<a name="379"></a>                 *   in the rest of the command.  Now that we know the
<a name="380"></a>                 *   actor, we can start over and resolve everything in
<a name="381"></a>                 *   the rest of the command, and thus choose the right
<a name="382"></a>                 *   structural match for the command.
<a name="383"></a>                 */
<a name="384"></a>                toks = match.getCommandTokens();
<a name="385"></a>
<a name="386"></a>                /* what follows obviously isn't first in the sentence */
<a name="387"></a>                firstInSentence = nil;
<a name="388"></a>
<a name="389"></a>                /* go back to parse the rest */
<a name="390"></a>                continue parseTokenLoop;
<a name="391"></a>            }
<a name="392"></a>
<a name="393"></a>            /* pull out the first action from the command */
<a name="394"></a>            action = match.resolveFirstAction(issuingActor, targetActor);
<a name="395"></a>
<a name="396"></a>            /*
<a name="397"></a>             *   If the winning interpretation had any unknown words, run
<a name="398"></a>             *   a resolution pass to resolve those interactively, if
<a name="399"></a>             *   possible.  We want to do this before doing any other
<a name="400"></a>             *   interactive resolution because OOPS has the unique
<a name="401"></a>             *   property of forcing us to reparse the command; if we
<a name="402"></a>             *   allowed any other interactive resolution to happen before
<a name="403"></a>             *   processing an OOPS, we'd likely have to repeat the other
<a name="404"></a>             *   resolution on the reparse, which would confuse and
<a name="405"></a>             *   irritate users by asking the same question more than once
<a name="406"></a>             *   for what is apparently the same command.
<a name="407"></a>             */
<a name="408"></a>            if (rankings[1].unknownWordCount != 0)
<a name="409"></a>            {
<a name="410"></a>                /*
<a name="411"></a>                 *   resolve using the OOPS results gatherer - this runs
<a name="412"></a>                 *   essentially the same preliminary resolution process
<a name="413"></a>                 *   as the ranking results gatherer, but does perform
<a name="414"></a>                 *   interactive resolution of unknown words via OOPS
<a name="415"></a>                 */
<a name="416"></a>                match.resolveNouns(
<a name="417"></a>                    issuingActor, targetActor,
<a name="418"></a>                    new OopsResults(issuingActor, targetActor));
<a name="419"></a>            }
<a name="420"></a>
<a name="421"></a>            /*
<a name="422"></a>             *   If the command is directed to a different actor than the
<a name="423"></a>             *   issuer, change to the target actor's sense context.
<a name="424"></a>             *
<a name="425"></a>             *   On the other hand, if this is a conversational command
<a name="426"></a>             *   (e.g., BOB, YES or BOB, GOODBYE), execute it within the
<a name="427"></a>             *   sense context of the issuer, even when a target is
<a name="428"></a>             *   specified.  Target actors in conversational commands
<a name="429"></a>             *   designate the interlocutor rather than the performing
<a name="430"></a>             *   actor: BOB, YES doesn't ask Bob to say "yes", but rather
<a name="431"></a>             *   means that the player character (the issuer) is saying
<a name="432"></a>             *   "yes" to Bob.
<a name="433"></a>             */
<a name="434"></a>            if (action != nil &amp;&amp; action.isConversational(issuingActor))
<a name="435"></a>                senseContext.setSenseContext(issuingActor, sight);
<a name="436"></a>            else if (actorSpecified &amp;&amp; targetActor != issuingActor)
<a name="437"></a>                senseContext.setSenseContext(targetActor, sight);
<a name="438"></a>
<a name="439"></a>            /* set up a transcript to receive the command results */
<a name="440"></a>            withCommandTranscript(CommandTranscript, function()
<a name="441"></a>            {
<a name="442"></a>                /*
<a name="443"></a>                 *   Execute the action.
<a name="444"></a>                 *
<a name="445"></a>                 *   If a target actor was specified, and it's not the same
<a name="446"></a>                 *   as the issuing actor, this counts as a turn for the
<a name="447"></a>                 *   issuing actor.
<a name="448"></a>                 */
<a name="449"></a>                executeAction(targetActor, actorPhrase, issuingActor,
<a name="450"></a>                              actorSpecified &amp;&amp; issuingActor != targetActor,
<a name="451"></a>                              action);
<a name="452"></a>            });
<a name="453"></a>
<a name="454"></a>            /*
<a name="455"></a>             *   If we have anything remaining on the command line, insert
<a name="456"></a>             *   the remaining commands at the start of the target actor's
<a name="457"></a>             *   command queue, since we want the target actor to continue
<a name="458"></a>             *   with the rest of this command line as its next operation.
<a name="459"></a>             *
<a name="460"></a>             *   Since the remainder of the line represents part of the
<a name="461"></a>             *   work the actor pulled out of the queue in order to call
<a name="462"></a>             *   us, put the remainder back in at the START of the actor's
<a name="463"></a>             *   queue - it was before anything else that might be in the
<a name="464"></a>             *   actor's queue before, so it should stay ahead of anything
<a name="465"></a>             *   else now.
<a name="466"></a>             */
<a name="467"></a>            if (nextCommandTokens != nil)
<a name="468"></a>            {
<a name="469"></a>                /*
<a name="470"></a>                 *   Prepend the remaining commands to the actor's queue.
<a name="471"></a>                 *   The next command is the start of a new sentence if
<a name="472"></a>                 *   the command we just executed ends the sentence.
<a name="473"></a>                 */
<a name="474"></a>                targetActor.addFirstPendingCommand(
<a name="475"></a>                    match.isEndOfSentence(), issuingActor, nextCommandTokens);
<a name="476"></a>            }
<a name="477"></a>
<a name="478"></a>            /*
<a name="479"></a>             *   If the command was directed from the issuer to a
<a name="480"></a>             *   different target actor, and the issuer wants to wait for
<a name="481"></a>             *   the full set of issued commands to complete before
<a name="482"></a>             *   getting another turn, tell the issuer to begin waiting.
<a name="483"></a>             */
<a name="484"></a>            if (actorSpecified &amp;&amp; issuingActor != targetActor)
<a name="485"></a>                issuingActor.waitForIssuedCommand(targetActor);
<a name="486"></a>
<a name="487"></a>            /* we're done */
<a name="488"></a>            return;
<a name="489"></a>        }
<a name="490"></a>        catch (ParseFailureException rfExc)
<a name="491"></a>        {
<a name="492"></a>            /*
<a name="493"></a>             *   Parsing failed in such a way that we cannot proceed.
<a name="494"></a>             *   Tell the target actor to notify the issuing actor.
<a name="495"></a>             */
<a name="496"></a>            rfExc.notifyActor(targetActor, issuingActor);
<a name="497"></a>
<a name="498"></a>            /*
<a name="499"></a>             *   the command cannot proceed, so abandon any remaining
<a name="500"></a>             *   tokens on the command line
<a name="501"></a>             */
<a name="502"></a>            return;
<a name="503"></a>        }
<a name="504"></a>        catch (CancelCommandLineException cclExc)
<a name="505"></a>        {
<a name="506"></a>            /*
<a name="507"></a>             *   if there are any tokens remaining, the game might want to
<a name="508"></a>             *   show an explanation
<a name="509"></a>             */
<a name="510"></a>            if (nextCommandTokens != nil)
<a name="511"></a>                targetActor.getParserMessageObj().explainCancelCommandLine();
<a name="512"></a>
<a name="513"></a>            /* stop now, abandoning the rest of the command line */
<a name="514"></a>            return;
<a name="515"></a>        }
<a name="516"></a>        catch (TerminateCommandException tcExc)
<a name="517"></a>        {
<a name="518"></a>            /*
<a name="519"></a>             *   the command cannot proceed - we can't do any more
<a name="520"></a>             *   processing of this command, so simply return, abandoning
<a name="521"></a>             *   any additional tokens we have
<a name="522"></a>             */
<a name="523"></a>            return;
<a name="524"></a>        }
<a name="525"></a>        catch (RetryCommandTokensException rctExc)
<a name="526"></a>        {
<a name="527"></a>            /*
<a name="528"></a>             *   We want to replace the current command's token list with
<a name="529"></a>             *   the new token list - get the new list, and then go back
<a name="530"></a>             *   and start over processing it.
<a name="531"></a>             *
<a name="532"></a>             *   Note that we must retain any tokens beyond those that the
<a name="533"></a>             *   match tree used.  The exception only edits the current
<a name="534"></a>             *   match tree's matched tokens, since it doesn't have access
<a name="535"></a>             *   to any of the original tokens beyond those, so we must
<a name="536"></a>             *   now add back in any tokens beyond the originals.
<a name="537"></a>             */
<a name="538"></a>            toks = rctExc.newTokens_ + extraTokens;
<a name="539"></a>
<a name="540"></a>            /* go back and process the command again with the new tokens */
<a name="541"></a>            continue parseTokenLoop;
<a name="542"></a>        }
<a name="543"></a>        catch (ReplacementCommandStringException rcsExc)
<a name="544"></a>        {
<a name="545"></a>            local str;
<a name="546"></a>
<a name="547"></a>            /* retrieve the new command string from the exception */
<a name="548"></a>            str = rcsExc.newCommand_;
<a name="549"></a>
<a name="550"></a>            /*
<a name="551"></a>             *   if the command string is nil, it means that the command
<a name="552"></a>             *   has been fully handled already, so we simply return
<a name="553"></a>             *   without any further work
<a name="554"></a>             */
<a name="555"></a>            if (str == nil)
<a name="556"></a>                return;
<a name="557"></a>
<a name="558"></a>            /*
<a name="559"></a>             *   Replace the entire command string with the one from the
<a name="560"></a>             *   exception - this cancels any previous command that we
<a name="561"></a>             *   had.
<a name="562"></a>             */
<a name="563"></a>            toks = cmdTokenizer.tokenize(str);
<a name="564"></a>
<a name="565"></a>            /*
<a name="566"></a>             *   we have a brand new command line, so we're starting a
<a name="567"></a>             *   brand new sentence
<a name="568"></a>             */
<a name="569"></a>            firstInSentence = true;
<a name="570"></a>
<a name="571"></a>            /* set the issuing and target actor according to the exception */
<a name="572"></a>            issuingActor = rcsExc.issuingActor_;
<a name="573"></a>            targetActor = rcsExc.targetActor_;
<a name="574"></a>
<a name="575"></a>            /*
<a name="576"></a>             *   Put this work into the target actor's work queue, so that
<a name="577"></a>             *   the issuer will carry out the command at the next
<a name="578"></a>             *   opportunity.  This is a brand new command line, so it
<a name="579"></a>             *   starts a new sentence.
<a name="580"></a>             */
<a name="581"></a>            targetActor.addPendingCommand(true, issuingActor, toks);
<a name="582"></a>
<a name="583"></a>            /* we're done processing this command */
<a name="584"></a>            return;
<a name="585"></a>        }
<a name="586"></a>    }
<a name="587"></a>}
<a name="588"></a>
<a name="589"></a>/* ------------------------------------------------------------------------ */
<a name="590"></a>/*
<a name="591"></a> *   GlobalRemapping makes it possible to transform one action into another
<a name="592"></a> *   globally - as opposed to the remapTo mechanism, which lets an object
<a name="593"></a> *   involved in the command perform a remapping.  The key difference
<a name="594"></a> *   between global remappings and remapTo is that the latter can't happen
<a name="595"></a> *   until after the objects are resolved (for fairly obvious reasons: each
<a name="596"></a> *   remapTo mapping is associated with an object, so you can't know which
<a name="597"></a> *   mapping to apply until you know which object is involved).  In
<a name="598"></a> *   contrast, global remappings are performed *before* object resolution -
<a name="599"></a> *   this is possible because the mappings don't depend on the objects
<a name="600"></a> *   involved in the action.
<a name="601"></a> *
<a name="602"></a> *   Whenever an action is about to be executed, the parser runs through
<a name="603"></a> *   all of the defined global remappings, and gives each one a chance to
<a name="604"></a> *   remap the command.  If any remapping succeeds, we replace the original
<a name="605"></a> *   command with the remapped version, then repeat the scan of the global
<a name="606"></a> *   remapping list from the start - we do another complete scan of the
<a name="607"></a> *   list in case there's another global mapping that applies to the
<a name="608"></a> *   remapped version of the command.  We repeat this process until we make
<a name="609"></a> *   it through the whole list without finding a remapping.
<a name="610"></a> *
<a name="611"></a> *   GlobalRemapping instances are added to the master list of mappings
<a name="612"></a> *   automatically at pre-init time, and any time you construct one
<a name="613"></a> *   dynamically with 'new'.
<a name="614"></a> */
<a name="615"></a>class GlobalRemapping: PreinitObject
<a name="616"></a>    /*
<a name="617"></a>     *   Check for and apply a remapping.  This method must be implemented
<a name="618"></a>     *   in each GlobalRemapping instance to perform the actual remapping
<a name="619"></a>     *   work.
<a name="620"></a>     *
<a name="621"></a>     *   This routine should first check to see if the command is relevant
<a name="622"></a>     *   to this remapping.  In most cases, this means checking that the
<a name="623"></a>     *   command matches some template, such as having a particular action
<a name="624"></a>     *   (verb) and combination of potential objects.  Note that the
<a name="625"></a>     *   objects aren't fully resolved during global remapping - the whole
<a name="626"></a>     *   point of global remapping is to catch certain phrasings before we
<a name="627"></a>     *   get to the noun resolution phase - but the *phrases* involved will
<a name="628"></a>     *   be known, so the range of potential matches is knowable.
<a name="629"></a>     *
<a name="630"></a>     *   If the routine decides that the action isn't relevant to this
<a name="631"></a>     *   remapping, it should simply return nil.
<a name="632"></a>     *
<a name="633"></a>     *   If the action decides to remap the action, it must create a new
<a name="634"></a>     *   Action object representing the replacement version of the command.
<a name="635"></a>     *   Then, return a list, [targetActor, action], giving the new target
<a name="636"></a>     *   actor and the new action.  You don't have to change the target
<a name="637"></a>     *   actor, of course, but it's included in the result so that you can
<a name="638"></a>     *   change it if you want to.  For example, you could use this to
<a name="639"></a>     *   remap a command of the form "X, GIVE ME Y" to "ME, ASK X FOR Y" -
<a name="640"></a>     *   note that the target actor changes from X to ME.
<a name="641"></a>     */
<a name="642"></a>    getRemapping(issuingActor, targetActor, action)
<a name="643"></a>    {
<a name="644"></a>        /*
<a name="645"></a>         *   this must be overridden to perform the actual remapping; by
<a name="646"></a>         *   default, simply return nil to indicate that we don't want to
<a name="647"></a>         *   remap this action
<a name="648"></a>         */
<a name="649"></a>        return nil;
<a name="650"></a>    }
<a name="651"></a>
<a name="652"></a>    /*
<a name="653"></a>     *   Remapping order - the parser applies global remappings in
<a name="654"></a>     *   ascending order of this value.  In most cases, the order shouldn't
<a name="655"></a>     *   matter, since most remappings should be narrow enough that a given
<a name="656"></a>     *   command will only be subject to one remapping rule.  However, in
<a name="657"></a>     *   some cases you might need to define rules that overlap, so the
<a name="658"></a>     *   ordering lets you specify which one goes first.  In most cases
<a name="659"></a>     *   you'll want to apply the more specific rule first.
<a name="660"></a>     */
<a name="661"></a>    remappingOrder = 100
<a name="662"></a>
<a name="663"></a>    /*
<a name="664"></a>     *   Static class method: look for a remapping.  This runs through the
<a name="665"></a>     *   master list of mappings, looking for a mapping that applies to the
<a name="666"></a>     *   given command.  If we find one, we'll replace the command with the
<a name="667"></a>     *   remapped version, then start over with a fresh scan of the entire
<a name="668"></a>     *   list to see if there's a remapping for the *new* version of the
<a name="669"></a>     *   command.  We repeat this until we get through the whole list
<a name="670"></a>     *   without finding a remapping.
<a name="671"></a>     *
<a name="672"></a>     *   The return value is a list, [targetActor, action], giving the
<a name="673"></a>     *   resulting target actor and new action object.  If we don't find
<a name="674"></a>     *   any remapping, this will simply be the original values passed in
<a name="675"></a>     *   as our arguments; if we do find a remapping, this will be the new
<a name="676"></a>     *   version of the command.
<a name="677"></a>     */
<a name="678"></a>    findGlobalRemapping(issuingActor, targetActor, action)
<a name="679"></a>    {
<a name="680"></a>        /* get the global remapping list */
<a name="681"></a>        local v = GlobalRemapping.allGlobalRemappings;
<a name="682"></a>        local cnt = v.length();
<a name="683"></a>
<a name="684"></a>        /* if necessary, sort the list */
<a name="685"></a>        if (GlobalRemapping.listNeedsSorting)
<a name="686"></a>        {
<a name="687"></a>            /* sort it by ascending remappingOrder value */
<a name="688"></a>            v.sort(SortAsc, {a, b: a.remappingOrder - b.remappingOrder});
<a name="689"></a>
<a name="690"></a>            /* note that it's now sorted */
<a name="691"></a>            GlobalRemapping.listNeedsSorting = nil;
<a name="692"></a>        }
<a name="693"></a>
<a name="694"></a>        /*
<a name="695"></a>         *   iterate through the list repeatedly, until we make it all the
<a name="696"></a>         *   way through without finding a mapping
<a name="697"></a>         */
<a name="698"></a>        for (local done = nil ; !done ; )
<a name="699"></a>        {
<a name="700"></a>            /* presume we won't find a remapping on this iteration */
<a name="701"></a>            done = true;
<a name="702"></a>
<a name="703"></a>            /* run through the list, looking for a remapping */
<a name="704"></a>            for (local i = 1 ; i &lt;= cnt ; ++i)
<a name="705"></a>            {
<a name="706"></a>                local rm;
<a name="707"></a>
<a name="708"></a>                /* check for a remapping */
<a name="709"></a>                rm = v[i].getRemapping(issuingActor, targetActor, action);
<a name="710"></a>                if (rm != nil)
<a name="711"></a>                {
<a name="712"></a>                    /* found a remapping - apply it */
<a name="713"></a>                    targetActor = rm[1];
<a name="714"></a>                    action = rm[2];
<a name="715"></a>
<a name="716"></a>                    /*
<a name="717"></a>                     *   we found a remapping, so we have to repeat the
<a name="718"></a>                     *   scan of the whole list - note that we're not done,
<a name="719"></a>                     *   and break out of the current scan so that we start
<a name="720"></a>                     *   over with a fresh scan
<a name="721"></a>                     */
<a name="722"></a>                    done = nil;
<a name="723"></a>                    break;
<a name="724"></a>                }
<a name="725"></a>            }
<a name="726"></a>        }
<a name="727"></a>
<a name="728"></a>        /* return the final version of the command */
<a name="729"></a>        return [targetActor, action];
<a name="730"></a>    }
<a name="731"></a>
<a name="732"></a>    /* pre-initialization: add each instance to the master list */
<a name="733"></a>    execute()
<a name="734"></a>    {
<a name="735"></a>        /* add me to the master list */
<a name="736"></a>        registerGlobalRemapping();
<a name="737"></a>    }
<a name="738"></a>
<a name="739"></a>    /* construction: add myself to the master list */
<a name="740"></a>    construct()
<a name="741"></a>    {
<a name="742"></a>        /* add me to the master list */
<a name="743"></a>        registerGlobalRemapping();
<a name="744"></a>    }
<a name="745"></a>
<a name="746"></a>    /* register myself with the global list, making this an active mapping */
<a name="747"></a>    registerGlobalRemapping()
<a name="748"></a>    {
<a name="749"></a>        /* add myself to the global list */
<a name="750"></a>        GlobalRemapping.allGlobalRemappings.append(self);
<a name="751"></a>
<a name="752"></a>        /* note that a sort is required the next time we run */
<a name="753"></a>        GlobalRemapping.listNeedsSorting = true;
<a name="754"></a>    }
<a name="755"></a>
<a name="756"></a>    /*
<a name="757"></a>     *   unregister - this removes me from the global list, making this
<a name="758"></a>     *   mapping inactive: after being unregistered, the parser won't apply
<a name="759"></a>     *   this mapping to new commands
<a name="760"></a>     */
<a name="761"></a>    unregisterGlobalRemapping()
<a name="762"></a>    {
<a name="763"></a>        GlobalRemapping.allGlobalRemappings.removeElement(self);
<a name="764"></a>    }
<a name="765"></a>
<a name="766"></a>    /*
<a name="767"></a>     *   Static class property: the master list of remappings.  We build
<a name="768"></a>     *   this automatically at preinit time, and manipulate it via our
<a name="769"></a>     *   constructor.
<a name="770"></a>     */
<a name="771"></a>    allGlobalRemappings = static new Vector(10)
<a name="772"></a>
<a name="773"></a>    /*
<a name="774"></a>     *   static class property: the master list needs to be sorted; this is
<a name="775"></a>     *   set to true each time we update the list, so that the list scanner
<a name="776"></a>     *   knows to sort it before doing its scan
<a name="777"></a>     */
<a name="778"></a>    listNeedsSorting = nil
<a name="779"></a>;
<a name="780"></a>
<a name="781"></a>
<a name="782"></a>
<a name="783"></a>/* ------------------------------------------------------------------------ */
<a name="784"></a>/*
<a name="785"></a> *   Execute an action, as specified by an Action object.  We'll resolve
<a name="786"></a> *   the nouns in the action, then perform the action.
<a name="787"></a> */
<a name="788"></a>executeAction(targetActor, targetActorPhrase,
<a name="789"></a>              issuingActor, countsAsIssuerTurn, action)
<a name="790"></a>{
<a name="791"></a>    local rm, results;
<a name="792"></a>
<a name="793"></a>startOver:
<a name="794"></a>    /* check for a global remapping */
<a name="795"></a>    rm = GlobalRemapping.findGlobalRemapping(
<a name="796"></a>        issuingActor, targetActor, action);
<a name="797"></a>    targetActor = rm[1];
<a name="798"></a>    action = rm[2];
<a name="799"></a>
<a name="800"></a>    /* create a basic results object to handle the resolution */
<a name="801"></a>    results = new BasicResolveResults();
<a name="802"></a>
<a name="803"></a>    /* set up the actors in the results object */
<a name="804"></a>    results.setActors(targetActor, issuingActor);
<a name="805"></a>
<a name="806"></a>    /* catch any "remap" signals while resolving noun phrases */
<a name="807"></a>    try
<a name="808"></a>    {
<a name="809"></a>        /* resolve noun phrases */
<a name="810"></a>        action.resolveNouns(issuingActor, targetActor, results);
<a name="811"></a>    }
<a name="812"></a>    catch (RemapActionSignal sig)
<a name="813"></a>    {
<a name="814"></a>        /* mark the new action as remapped */
<a name="815"></a>        sig.action_.setRemapped(action);
<a name="816"></a>
<a name="817"></a>        /* get the new action from the signal */
<a name="818"></a>        action = sig.action_;
<a name="819"></a>
<a name="820"></a>        /* start over with the new action */
<a name="821"></a>        goto startOver;
<a name="822"></a>    }
<a name="823"></a>
<a name="824"></a>    /*
<a name="825"></a>     *   Check to see if we should create an undo savepoint for the
<a name="826"></a>     *   command.  If the action is not marked for inclusion in the undo
<a name="827"></a>     *   log, there is no need to log a savepoint for it.
<a name="828"></a>     *
<a name="829"></a>     *   Don't save undo for nested commands.  A nested command is part of
<a name="830"></a>     *   a main command, and we only want to save undo for the main
<a name="831"></a>     *   command, not for its individual sub-commands.
<a name="832"></a>     */
<a name="833"></a>    if (action.includeInUndo
<a name="834"></a>        &amp;&amp; action.parentAction == nil
<a name="835"></a>        &amp;&amp; (targetActor.isPlayerChar()
<a name="836"></a>            || (issuingActor.isPlayerChar() &amp;&amp; countsAsIssuerTurn)))
<a name="837"></a>    {
<a name="838"></a>        /*
<a name="839"></a>         *   Remember the command we're about to perform, so that if we
<a name="840"></a>         *   undo to here we'll be able to report what we undid.  Note that
<a name="841"></a>         *   we do this *before* setting the savepoint, because we want
<a name="842"></a>         *   after the undo to know the command we were about to issue at
<a name="843"></a>         *   the savepoint.
<a name="844"></a>         */
<a name="845"></a>        libGlobal.lastCommandForUndo = action.getOrigText();
<a name="846"></a>        libGlobal.lastActorForUndo =
<a name="847"></a>            (targetActorPhrase == nil
<a name="848"></a>             ? nil
<a name="849"></a>             : targetActorPhrase.getOrigText());
<a name="850"></a>
<a name="851"></a>        /*
<a name="852"></a>         *   set a savepoint here, so that we on 'undo' we'll restore
<a name="853"></a>         *   conditions to what they were just before we executed this
<a name="854"></a>         *   command
<a name="855"></a>         */
<a name="856"></a>        savepoint();
<a name="857"></a>    }
<a name="858"></a>
<a name="859"></a>    /*
<a name="860"></a>     *   If this counts as a turn for the issuer, adjust the issuer's busy
<a name="861"></a>     *   time.
<a name="862"></a>     *
<a name="863"></a>     *   However, this doesn't apply if the command is conversational (that
<a name="864"></a>     *   is, it's something like "BOB, HELLO").  A conversational command
<a name="865"></a>     *   is conceptually carried out by the issuer, not the target actor,
<a name="866"></a>     *   since the action consists of the issuer actually saying something
<a name="867"></a>     *   to the target actor.  The normal turn accounting in Action will
<a name="868"></a>     *   count a conversational command this way, so we don't have to do
<a name="869"></a>     *   the extra bookkeeping for such a command here.
<a name="870"></a>     */
<a name="871"></a>    if (countsAsIssuerTurn &amp;&amp; !action.isConversational(issuingActor))
<a name="872"></a>    {
<a name="873"></a>        /*
<a name="874"></a>         *   note in the issuer that the target is the most recent
<a name="875"></a>         *   conversational partner
<a name="876"></a>         */
<a name="877"></a>        issuingActor.lastInterlocutor = targetActor;
<a name="878"></a>
<a name="879"></a>        /* make the issuer busy for the order-giving interval */
<a name="880"></a>        issuingActor.addBusyTime(nil,
<a name="881"></a>                                 issuingActor.orderingTime(targetActor));
<a name="882"></a>
<a name="883"></a>        /* notify the target that this will be a non-idle turn */
<a name="884"></a>        targetActor.nonIdleTurn();
<a name="885"></a>    }
<a name="886"></a>
<a name="887"></a>    /*
<a name="888"></a>     *   If the issuer is directing the command to a different actor, and
<a name="889"></a>     *   it's not a conversational command, check with the target actor to
<a name="890"></a>     *   see if it wants to accept the command.  Don't check
<a name="891"></a>     *   conversational commands, since these aren't of the nature of
<a name="892"></a>     *   orders to be obeyed.
<a name="893"></a>     */
<a name="894"></a>    if (issuingActor != targetActor
<a name="895"></a>        &amp;&amp; !action.isConversational(issuingActor)
<a name="896"></a>        &amp;&amp; !targetActor.obeyCommand(issuingActor, action))
<a name="897"></a>    {
<a name="898"></a>        /*
<a name="899"></a>         *   if the issuing actor's "ordering time" is zero, make this take
<a name="900"></a>         *   up a turn anyway, just for the refusal
<a name="901"></a>         */
<a name="902"></a>        if (issuingActor.orderingTime(targetActor) == 0)
<a name="903"></a>            issuingActor.addBusyTime(nil, 1);
<a name="904"></a>
<a name="905"></a>        /*
<a name="906"></a>         *   Since we're aborting the command, we won't get into the normal
<a name="907"></a>         *   execution for it.  However, we might still want to save it for
<a name="908"></a>         *   an attempted re-issue with AGAIN, so do so explicitly now.
<a name="909"></a>         */
<a name="910"></a>        action.saveActionForAgain(issuingActor, countsAsIssuerTurn,
<a name="911"></a>                                  targetActor, targetActorPhrase);
<a name="912"></a>
<a name="913"></a>        /*
<a name="914"></a>         *   This command was rejected, so don't process it any further,
<a name="915"></a>         *   and give up on processing any remaining commands on the same
<a name="916"></a>         *   command line.
<a name="917"></a>         */
<a name="918"></a>        throw new TerminateCommandException();
<a name="919"></a>    }
<a name="920"></a>
<a name="921"></a>    /* execute the action */
<a name="922"></a>    action.doAction(issuingActor, targetActor, targetActorPhrase,
<a name="923"></a>                    countsAsIssuerTurn);
<a name="924"></a>}
<a name="925"></a>
<a name="926"></a>/* ------------------------------------------------------------------------ */
<a name="927"></a>/*
<a name="928"></a> *   Try an implicit action.
<a name="929"></a> *
<a name="930"></a> *   Returns true if the action was attempted, whether or not it
<a name="931"></a> *   succeeded, nil if the command was not even attempted.  We will not
<a name="932"></a> *   attempt an implied command that verifies as "dangerous," since this
<a name="933"></a> *   means that it should be obvious to the player character that such a
<a name="934"></a> *   command should not be performed lightly.
<a name="935"></a> */
<a name="936"></a>_tryImplicitAction(issuingActor, targetActor, msgProp, actionClass, [objs])
<a name="937"></a>{
<a name="938"></a>    local action;
<a name="939"></a>
<a name="940"></a>    /* create an instance of the desired action class */
<a name="941"></a>    action = actionClass.createActionInstance();
<a name="942"></a>
<a name="943"></a>    /* mark the action as implicit */
<a name="944"></a>    action.setImplicit(msgProp);
<a name="945"></a>
<a name="946"></a>    /* install the resolved objects in the action */
<a name="947"></a>    action.setResolvedObjects(objs...);
<a name="948"></a>
<a name="949"></a>    /*
<a name="950"></a>     *   For an implicit action, we must check the objects involved to make
<a name="951"></a>     *   sure they're in scope.  If any of the objects aren't in scope,
<a name="952"></a>     *   there is no way the actor would know to perform the command, so
<a name="953"></a>     *   the command would not be implied in the first place.  Simply fail
<a name="954"></a>     *   without trying the command.
<a name="955"></a>     */
<a name="956"></a>    if (!action.resolvedObjectsInScope())
<a name="957"></a>        return nil;
<a name="958"></a>
<a name="959"></a>    /*
<a name="960"></a>     *   catch the abort-implicit signal, so we can turn it into a result
<a name="961"></a>     *   code for our caller instead of an exception
<a name="962"></a>     */
<a name="963"></a>    try
<a name="964"></a>    {
<a name="965"></a>        /* in NPC mode, add a command separator before each implied action */
<a name="966"></a>        if (targetActor.impliedCommandMode() == ModeNPC)
<a name="967"></a>            gTranscript.addCommandSep();
<a name="968"></a>
<a name="969"></a>        /* execute the action */
<a name="970"></a>        action.doAction(issuingActor, targetActor, nil, nil);
<a name="971"></a>
<a name="972"></a>        /*
<a name="973"></a>         *   if the actor is in "NPC" mode for implied commands, do some
<a name="974"></a>         *   extra work
<a name="975"></a>         */
<a name="976"></a>        if (targetActor.impliedCommandMode() == ModeNPC)
<a name="977"></a>        {
<a name="978"></a>            /*
<a name="979"></a>             *   we're in NPC mode, so if the implied action failed, then
<a name="980"></a>             *   act as though the command had never been attempted
<a name="981"></a>             */
<a name="982"></a>            if (gTranscript.actionFailed(action))
<a name="983"></a>            {
<a name="984"></a>                /* the implied command failed - act like we didn't even try */
<a name="985"></a>                return nil;
<a name="986"></a>            }
<a name="987"></a>
<a name="988"></a>            /*
<a name="989"></a>             *   In "NPC" mode, we display the results from implied
<a name="990"></a>             *   commands as though they had been explicitly entered as
<a name="991"></a>             *   separate actions.  So, add visual separation after the
<a name="992"></a>             *   results from the implied command.
<a name="993"></a>             */
<a name="994"></a>            gTranscript.addCommandSep();
<a name="995"></a>        }
<a name="996"></a>
<a name="997"></a>        /* tell the caller we at least tried to execute the command */
<a name="998"></a>        return true;
<a name="999"></a>    }
<a name="1000"></a>    catch (AbortImplicitSignal sig)
<a name="1001"></a>    {
<a name="1002"></a>        /* tell the caller we didn't execute the command at all */
<a name="1003"></a>        return nil;
<a name="1004"></a>    }
<a name="1005"></a>    catch (ParseFailureException exc)
<a name="1006"></a>    {
<a name="1007"></a>        /*
<a name="1008"></a>         *   Parse failure.  If the actor is in NPC mode, we can't have
<a name="1009"></a>         *   asked for a new command, so this must be some failure in
<a name="1010"></a>         *   processing the implied command itself; most likely, we tried
<a name="1011"></a>         *   to resolve a missing object or the like and found that we
<a name="1012"></a>         *   couldn't perform interactive resolution (because of the NPC
<a name="1013"></a>         *   mode).  In this case, simply treat this as a failure of the
<a name="1014"></a>         *   implied command itself, and act as though we didn't even try
<a name="1015"></a>         *   the implied command.
<a name="1016"></a>         *
<a name="1017"></a>         *   If the actor is in player mode, then we *can* perform
<a name="1018"></a>         *   interactive resolution, so we won't have thrown a parser
<a name="1019"></a>         *   failure before trying to solve the problem interactively.  The
<a name="1020"></a>         *   failure must therefore be in an interactive response.  In this
<a name="1021"></a>         *   case, simply re-throw the failure so that it reaches the main
<a name="1022"></a>         *   parser.
<a name="1023"></a>         */
<a name="1024"></a>        if (targetActor.impliedCommandMode() == ModeNPC)
<a name="1025"></a>        {
<a name="1026"></a>            /* NPC mode - the implied command itself failed */
<a name="1027"></a>            return nil;
<a name="1028"></a>        }
<a name="1029"></a>        else
<a name="1030"></a>        {
<a name="1031"></a>            /* player mode - interactive resolution failed */
<a name="1032"></a>            throw exc;
<a name="1033"></a>        }
<a name="1034"></a>    }
<a name="1035"></a>}
<a name="1036"></a>
<a name="1037"></a>/* ------------------------------------------------------------------------ */
<a name="1038"></a>/*
<a name="1039"></a> *   Run a replacement action.
<a name="1040"></a> */
<a name="1041"></a>_replaceAction(actor, actionClass, [objs])
<a name="1042"></a>{
<a name="1043"></a>    /* run the replacement action as a nested action */
<a name="1044"></a>    _nestedAction(true, actor, actionClass, objs...);
<a name="1045"></a>
<a name="1046"></a>    /* the invoking command is done */
<a name="1047"></a>    exit;
<a name="1048"></a>}
<a name="1049"></a>
<a name="1050"></a>/* ------------------------------------------------------------------------ */
<a name="1051"></a>/*
<a name="1052"></a> *   Resolve and execute a replacement action.  This differs from the
<a name="1053"></a> *   normal replacement action execution in that the action we execute
<a name="1054"></a> *   requires resolution before execution.
<a name="1055"></a> */
<a name="1056"></a>resolveAndReplaceAction(newAction)
<a name="1057"></a>{
<a name="1058"></a>    /* prepare the replacement action */
<a name="1059"></a>    prepareNestedAction(true, nil, newAction);
<a name="1060"></a>
<a name="1061"></a>    /*
<a name="1062"></a>     *   resolve and execute the new action, using the same target and
<a name="1063"></a>     *   issuing actors as the original action
<a name="1064"></a>     */
<a name="1065"></a>    executeAction(gActor, nil, gIssuingActor, nil, newAction);
<a name="1066"></a>
<a name="1067"></a>    /* the invoking command has been replaced, so it's done */
<a name="1068"></a>    exit;
<a name="1069"></a>}
<a name="1070"></a>
<a name="1071"></a>/* ------------------------------------------------------------------------ */
<a name="1072"></a>/*
<a name="1073"></a> *   Run an action as a new turn.  Returns the CommandTranscript describing
<a name="1074"></a> *   the action's results.
<a name="1075"></a> */
<a name="1076"></a>_newAction(transcriptClass, issuingActor, targetActor, actionClass, [objs])
<a name="1077"></a>{
<a name="1078"></a>    local action;
<a name="1079"></a>
<a name="1080"></a>    /* create an instance of the desired action class */
<a name="1081"></a>    action = actionClass.createActionInstance();
<a name="1082"></a>
<a name="1083"></a>    /* execute the command with the action instance */
<a name="1084"></a>    return newActionObj(transcriptClass, issuingActor, targetActor,
<a name="1085"></a>                        action, objs...);
<a name="1086"></a>}
<a name="1087"></a>
<a name="1088"></a>/*
<a name="1089"></a> *   Run an action as a new turn.  This is almost the same as _newAction,
<a name="1090"></a> *   but should be used when the caller has already explicitly created an
<a name="1091"></a> *   instance of the Action to be performed.
<a name="1092"></a> *
<a name="1093"></a> *   If issuingActor is nil, we'll use the current global issuing actor; if
<a name="1094"></a> *   that's also nil, we'll use the target actor.
<a name="1095"></a> *
<a name="1096"></a> *   Returns a CommandTranscript object describing the result of the
<a name="1097"></a> *   action.
<a name="1098"></a> */
<a name="1099"></a>newActionObj(transcriptClass, issuingActor, targetActor, actionObj, [objs])
<a name="1100"></a>{
<a name="1101"></a>    /* create the results object and install it as the global transcript */
<a name="1102"></a>    return withCommandTranscript(transcriptClass, function()
<a name="1103"></a>    {
<a name="1104"></a>        /* install the resolved objects in the action */
<a name="1105"></a>        actionObj.setResolvedObjects(objs...);
<a name="1106"></a>
<a name="1107"></a>        /*
<a name="1108"></a>         *   if the issuing actor isn't specified, use the current global
<a name="1109"></a>         *   issuing actor; if that's also not set, use the target actor
<a name="1110"></a>         */
<a name="1111"></a>        if (issuingActor == nil)
<a name="1112"></a>            issuingActor = gIssuingActor;
<a name="1113"></a>        if (issuingActor == nil)
<a name="1114"></a>            issuingActor = targetActor;
<a name="1115"></a>
<a name="1116"></a>        /*
<a name="1117"></a>         *   Execute the given action.  Because this is a new action,
<a name="1118"></a>         *   execute the action in a new sense context for the given actor.
<a name="1119"></a>         */
<a name="1120"></a>        callWithSenseContext(targetActor.isPlayerChar()
<a name="1121"></a>                             ? nil : targetActor, sight,
<a name="1122"></a>            {: actionObj.doAction(issuingActor, targetActor, nil, nil)});
<a name="1123"></a>
<a name="1124"></a>        /* return the current global transcript object */
<a name="1125"></a>        return gTranscript;
<a name="1126"></a>    });
<a name="1127"></a>}
<a name="1128"></a>
<a name="1129"></a>/* ------------------------------------------------------------------------ */
<a name="1130"></a>/*
<a name="1131"></a> *   Run a nested action.  'isReplacement' has the same meaning as in
<a name="1132"></a> *   execNestedAction().
<a name="1133"></a> */
<a name="1134"></a>_nestedAction(isReplacement, actor, actionClass, [objs])
<a name="1135"></a>{
<a name="1136"></a>    local action;
<a name="1137"></a>
<a name="1138"></a>    /* create an instance of the desired action class */
<a name="1139"></a>    action = actionClass.createActionInstance();
<a name="1140"></a>
<a name="1141"></a>    /* install the resolved objects in the action */
<a name="1142"></a>    action.setResolvedObjects(objs...);
<a name="1143"></a>
<a name="1144"></a>    /* execute the new action */
<a name="1145"></a>    execNestedAction(isReplacement, nil, actor, action);
<a name="1146"></a>}
<a name="1147"></a>
<a name="1148"></a>/*
<a name="1149"></a> *   Execute a fully-constructed nested action.
<a name="1150"></a> *
<a name="1151"></a> *   'isReplacement' indicates whether the action is a full replacement or
<a name="1152"></a> *   an ordinary nested action.  If it's a replacement, then we use the
<a name="1153"></a> *   game time taken by the replacement, and set the enclosing action
<a name="1154"></a> *   (i.e., the current gAction) to take zero time.  If it's an ordinary
<a name="1155"></a> *   nested action, then we consider the nested action to take zero time,
<a name="1156"></a> *   using the current action's time as the overall command time.
<a name="1157"></a> *
<a name="1158"></a> *   'isRemapping' indicates whether or not this is a remapped action.  If
<a name="1159"></a> *   we're remapping from one action to another, this will be true; for
<a name="1160"></a> *   any other kind of nested or replacement action, this should be nil.
<a name="1161"></a> */
<a name="1162"></a>execNestedAction(isReplacement, isRemapping, actor, action)
<a name="1163"></a>{
<a name="1164"></a>    /* prepare the nested action */
<a name="1165"></a>    prepareNestedAction(isReplacement, isRemapping, action);
<a name="1166"></a>
<a name="1167"></a>    /* execute the new action in the actor's sense context */
<a name="1168"></a>    callWithSenseContext(
<a name="1169"></a>        actor.isPlayerChar() ? nil : actor, sight,
<a name="1170"></a>        {: action.doAction(gIssuingActor, actor, nil, nil) });
<a name="1171"></a>}
<a name="1172"></a>
<a name="1173"></a>/*
<a name="1174"></a> *   Prepare a nested or replacement action for execution.
<a name="1175"></a> */
<a name="1176"></a>prepareNestedAction(isReplacement, isRemapping, action)
<a name="1177"></a>{
<a name="1178"></a>    /*
<a name="1179"></a>     *   if the original action is an implicit command, make the new
<a name="1180"></a>     *   command implicit as well
<a name="1181"></a>     */
<a name="1182"></a>    if (gAction.isImplicit)
<a name="1183"></a>    {
<a name="1184"></a>        /*
<a name="1185"></a>         *   make the new action implicit, but don't describe it as a
<a name="1186"></a>         *   separate implicit command - it's effectively part of the
<a name="1187"></a>         *   original implicit command
<a name="1188"></a>         */
<a name="1189"></a>        action.setImplicit(nil);
<a name="1190"></a>    }
<a name="1191"></a>
<a name="1192"></a>    /* mark the new action as nested */
<a name="1193"></a>    action.setNested();
<a name="1194"></a>
<a name="1195"></a>    /* a nested action is part of the enclosing action */
<a name="1196"></a>    action.setOriginalAction(gAction);
<a name="1197"></a>
<a name="1198"></a>    /* if this is a remapping, mark it as such */
<a name="1199"></a>    if (isRemapping)
<a name="1200"></a>        action.setRemapped(gAction);
<a name="1201"></a>
<a name="1202"></a>    /*
<a name="1203"></a>     *   Set either the nested action's time or the enclosing (current)
<a name="1204"></a>     *   action's time to zero - we want to count only the time of one
<a name="1205"></a>     *   command or the other.
<a name="1206"></a>     *
<a name="1207"></a>     *   If we're running an ordinary nested command, set the nested
<a name="1208"></a>     *   command's time to zero, since we want to consider it just a part
<a name="1209"></a>     *   of the enclosing command and thus to take no time of its own.
<a name="1210"></a>     *
<a name="1211"></a>     *   If we're running a full replacement command, and we're replacing
<a name="1212"></a>     *   something other than an implied command, don't consider the
<a name="1213"></a>     *   enclosing command to take any time, since the enclosing command is
<a name="1214"></a>     *   carrying out its entire function via the replacement and thus
<a name="1215"></a>     *   requires no time of its own.  If we're replacing an implied
<a name="1216"></a>     *   command, this doesn't apply, since the implied command defers to
<a name="1217"></a>     *   its enclosing command for timing.  If we're replacing a command
<a name="1218"></a>     *   that already has zero action time, this also doesn't apply, since
<a name="1219"></a>     *   we're presumably replacing a command that's itself nested.
<a name="1220"></a>     */
<a name="1221"></a>    if (isReplacement &amp;&amp; !gAction.isImplicit &amp;&amp; gAction.actionTime != 0)
<a name="1222"></a>        gAction.zeroActionTime();
<a name="1223"></a>    else
<a name="1224"></a>        action.actionTime = 0;
<a name="1225"></a>}
<a name="1226"></a>
<a name="1227"></a>/* ------------------------------------------------------------------------ */
<a name="1228"></a>/*
<a name="1229"></a> *   Run a previously-executed command as a nested action, re-resolving
<a name="1230"></a> *   all of its objects to ensure they are still valid.
<a name="1231"></a> */
<a name="1232"></a>nestedActionAgain(action)
<a name="1233"></a>{
<a name="1234"></a>    /* reset the any cached information for the new command context */
<a name="1235"></a>    action.resetAction();
<a name="1236"></a>
<a name="1237"></a>    /* mark the action as nested */
<a name="1238"></a>    action.setNested();
<a name="1239"></a>    action.setOriginalAction(gAction);
<a name="1240"></a>
<a name="1241"></a>    /*
<a name="1242"></a>     *   do not count any time for the nested action, since it's merely
<a name="1243"></a>     *   part of the main turn and doesn't count as a separate turn of its
<a name="1244"></a>     *   own
<a name="1245"></a>     */
<a name="1246"></a>    action.actionTime = 0;
<a name="1247"></a>
<a name="1248"></a>    /* execute the command */
<a name="1249"></a>    executeAction(gActor, nil, gIssuingActor, nil, action);
<a name="1250"></a>}
<a name="1251"></a>
<a name="1252"></a>
<a name="1253"></a>/* ------------------------------------------------------------------------ */
<a name="1254"></a>/*
<a name="1255"></a> *   Run some code in a simulated Action environment.  We'll create a dummy
<a name="1256"></a> *   instance of the given Action class, and set up a command transcript,
<a name="1257"></a> *   then invoke the function.  This is useful for writing daemon code that
<a name="1258"></a> *   needs to invoke other code that's set up to expect a normal action
<a name="1259"></a> *   processing environment.
<a name="1260"></a> */
<a name="1261"></a>withActionEnv(actionClass, actor, func)
<a name="1262"></a>{
<a name="1263"></a>    local oldAction, oldActor;
<a name="1264"></a>
<a name="1265"></a>    /* remember the old globals */
<a name="1266"></a>    oldAction = gAction;
<a name="1267"></a>    oldActor = gActor;
<a name="1268"></a>
<a name="1269"></a>    try
<a name="1270"></a>    {
<a name="1271"></a>        /* set up a dummy action */
<a name="1272"></a>        gAction = actionClass.createInstance();
<a name="1273"></a>
<a name="1274"></a>        /* use the player character as the actor */
<a name="1275"></a>        gActor = actor;
<a name="1276"></a>
<a name="1277"></a>        /*
<a name="1278"></a>         *   execute the function with a command transcript active; obtain
<a name="1279"></a>         *   and return the return value of the function
<a name="1280"></a>         */
<a name="1281"></a>        return withCommandTranscript(CommandTranscript, func);
<a name="1282"></a>    }
<a name="1283"></a>    finally
<a name="1284"></a>    {
<a name="1285"></a>        /* restore globals on the way out */
<a name="1286"></a>        gAction = oldAction;
<a name="1287"></a>        gActor = oldActor;
<a name="1288"></a>    }
<a name="1289"></a>}
<a name="1290"></a>
<a name="1291"></a>
<a name="1292"></a>/* ------------------------------------------------------------------------ */
<a name="1293"></a>/*
<a name="1294"></a> *   Exit signal.  This signal indicates that we're finished with the
<a name="1295"></a> *   entire command execution sequence for an action; the remainder of the
<a name="1296"></a> *   command execution sequence is to be skipped for the action.  Throw
<a name="1297"></a> *   this from within the command execution sequence in order to skip
<a name="1298"></a> *   directly to the end-of-turn processing.  This skips everything
<a name="1299"></a> *   remaining in the action, including after-action notification and the
<a name="1300"></a> *   like.  This signal skips directly past the 'afterAction' phase of the
<a name="1301"></a> *   command.
<a name="1302"></a> *
<a name="1303"></a> *   Note that this doesn't prevent further processing of the same command
<a name="1304"></a> *   if there are multiple objects involved, and it doesn't affect
<a name="1305"></a> *   processing of additional commands on the same command line.  If you
<a name="1306"></a> *   want to cancel further iteration of the same command for additional
<a name="1307"></a> *   objects, call gAction.cancelIteration().
<a name="1308"></a> */
<a name="1309"></a>class ExitSignal: Exception
<a name="1310"></a>;
<a name="1311"></a>
<a name="1312"></a>/*
<a name="1313"></a> *   Exit Action signal.  This signal indicates that we're finished with
<a name="1314"></a> *   the execAction portion of processing the command, but we still want
<a name="1315"></a> *   to proceed with the rest of the command as normal.  This can be used
<a name="1316"></a> *   when a step in the action processing wants to preempt any of the more
<a name="1317"></a> *   default processing that would normally follow.  This skips directly
<a name="1318"></a> *   to the 'afterAction' phase of the command.
<a name="1319"></a> *
<a name="1320"></a> *   Note that this doesn't prevent further processing of the same command
<a name="1321"></a> *   if there are multiple objects involved, and it doesn't affect
<a name="1322"></a> *   processing of additional commands on the same command line.  If you
<a name="1323"></a> *   want to cancel further iteration of the same command for additional
<a name="1324"></a> *   objects, call gAction.cancelIteration().
<a name="1325"></a> */
<a name="1326"></a>class ExitActionSignal: Exception
<a name="1327"></a>;
<a name="1328"></a>
<a name="1329"></a>/*
<a name="1330"></a> *   Abort implicit command signal.  This exception indicates that we are
<a name="1331"></a> *   aborting an implicit command without having tried to execute the
<a name="1332"></a> *   command at all.  This is thrown when an implied command is to be
<a name="1333"></a> *   aborted before it's even attempted, such as when verification shows
<a name="1334"></a> *   the command is obviously dangerous and thus should never be attempted
<a name="1335"></a> *   without the player having explicitly requesting it.
<a name="1336"></a> */
<a name="1337"></a>class AbortImplicitSignal: Exception
<a name="1338"></a>;
<a name="1339"></a>
<a name="1340"></a>/* ------------------------------------------------------------------------ */
<a name="1341"></a>/*
<a name="1342"></a> *   Action Remap signal.  This signal can be thrown only during the noun
<a name="1343"></a> *   phrase resolution phase of execution, and indicates that we want to
<a name="1344"></a> *   remap the action to a different action, specified in the signal.
<a name="1345"></a> *
<a name="1346"></a> *   This is useful when an object is always used in a special way, so
<a name="1347"></a> *   that a generic verb used with the object must be mapped to a more
<a name="1348"></a> *   specific verb on the object.  For example, a game with a generic USE
<a name="1349"></a> *   verb might convert USE PAINTBRUSH ON WALL to PAINT WALL WITH
<a name="1350"></a> *   PAINTBRUSH by remapping the UseWith action to a PaintWith action
<a name="1351"></a> *   instead.
<a name="1352"></a> */
<a name="1353"></a>class RemapActionSignal: Exception
<a name="1354"></a>    construct(action)
<a name="1355"></a>    {
<a name="1356"></a>        /* remember the new action */
<a name="1357"></a>        action_ = action;
<a name="1358"></a>    }
<a name="1359"></a>
<a name="1360"></a>    /* the new action that should replace the original action */
<a name="1361"></a>    action_ = nil
<a name="1362"></a>;
<a name="1363"></a>
<a name="1364"></a>/*
<a name="1365"></a> *   Remap a 'verify' method for a remapped action.  This is normally
<a name="1366"></a> *   invoked through the remapTo() macro.
<a name="1367"></a> */
<a name="1368"></a>remapVerify(oldRole, resultSoFar, remapInfo)
<a name="1369"></a>{
<a name="1370"></a>    local newAction;
<a name="1371"></a>    local objs;
<a name="1372"></a>    local idx;
<a name="1373"></a>    local newRole;
<a name="1374"></a>
<a name="1375"></a>    /* extract new action's object list from the remapping info list */
<a name="1376"></a>    objs = remapInfo.sublist(2);
<a name="1377"></a>
<a name="1378"></a>    /*
<a name="1379"></a>     *   Create a new action object.  We only perform verification
<a name="1380"></a>     *   remapping during the resolution phase of the command processing,
<a name="1381"></a>     *   because once we've finished resolving, we'll actually replace the
<a name="1382"></a>     *   action with the remapped action and thus won't have to remap
<a name="1383"></a>     *   verification (or anything else) at that point.  So, pass true for
<a name="1384"></a>     *   the in-resolve flag to the action creation routine.
<a name="1385"></a>     */
<a name="1386"></a>    newAction = remapActionCreate(true, oldRole, remapInfo);
<a name="1387"></a>
<a name="1388"></a>    /*
<a name="1389"></a>     *   Find the object that's given as a resolved object, rather than as
<a name="1390"></a>     *   a DirectObject (etc) identifier - the one given as a specific
<a name="1391"></a>     *   object is the one that corresponds to the original object.
<a name="1392"></a>     */
<a name="1393"></a>    idx = objs.indexWhich({x: dataType(x) == TypeObject});
<a name="1394"></a>
<a name="1395"></a>    /* get the role identifier (DirectObject, etc) for the slot position */
<a name="1396"></a>    newRole = newAction.getRoleFromIndex(idx);
<a name="1397"></a>
<a name="1398"></a>    /* if we don't yet have a result list object, create one */
<a name="1399"></a>    if (resultSoFar == nil)
<a name="1400"></a>        resultSoFar = new VerifyResultList();
<a name="1401"></a>
<a name="1402"></a>    /* if we found a remapping, verify it */
<a name="1403"></a>    if (idx != nil)
<a name="1404"></a>    {
<a name="1405"></a>        /*
<a name="1406"></a>         *   Remember the remapped object in the result list.  Note that we
<a name="1407"></a>         *   do this first, before calling the remapped verification
<a name="1408"></a>         *   property, so that our call to the remapped verification
<a name="1409"></a>         *   property will overwrite this setting if it does further
<a name="1410"></a>         *   remapping.  We want the ultimate target object represented
<a name="1411"></a>         *   here, after all remappings are finished.
<a name="1412"></a>         */
<a name="1413"></a>        resultSoFar.remapAction_ = newAction;
<a name="1414"></a>        resultSoFar.remapTarget_ = objs[idx];
<a name="1415"></a>        resultSoFar.remapRole_ = newRole;
<a name="1416"></a>
<a name="1417"></a>        /* install the new action as the current action while verifying */
<a name="1418"></a>        local oldAction = gAction;
<a name="1419"></a>        gAction = newAction;
<a name="1420"></a>
<a name="1421"></a>        try
<a name="1422"></a>        {
<a name="1423"></a>            /* call verification on the new object in the new role */
<a name="1424"></a>            return newAction.callVerifyProp(
<a name="1425"></a>                objs[idx],
<a name="1426"></a>                newAction.getVerifyPropForRole(newRole),
<a name="1427"></a>                newAction.getPreCondPropForRole(newRole),
<a name="1428"></a>                newAction.getRemapPropForRole(newRole),
<a name="1429"></a>                resultSoFar, newRole);
<a name="1430"></a>        }
<a name="1431"></a>        finally
<a name="1432"></a>        {
<a name="1433"></a>            /* restore the old gAction on the way out */
<a name="1434"></a>            gAction = oldAction;
<a name="1435"></a>        }
<a name="1436"></a>    }
<a name="1437"></a>    else
<a name="1438"></a>    {
<a name="1439"></a>        /* there's no remapping, so there's nothing to verify */
<a name="1440"></a>        return resultSoFar;
<a name="1441"></a>    }
<a name="1442"></a>}
<a name="1443"></a>
<a name="1444"></a>/*
<a name="1445"></a> *   Perform a remapping to a new action.  This is normally invoked
<a name="1446"></a> *   through the remapTo() macro.
<a name="1447"></a> */
<a name="1448"></a>remapAction(inResolve, oldRole, remapInfo)
<a name="1449"></a>{
<a name="1450"></a>    local newAction;
<a name="1451"></a>
<a name="1452"></a>    /* get the new action */
<a name="1453"></a>    newAction = remapActionCreate(inResolve, oldRole, remapInfo);
<a name="1454"></a>
<a name="1455"></a>    /*
<a name="1456"></a>     *   replace the current action, using the appropriate mechanism
<a name="1457"></a>     *   depending on the current processing phase
<a name="1458"></a>     */
<a name="1459"></a>    if (inResolve)
<a name="1460"></a>    {
<a name="1461"></a>        /*
<a name="1462"></a>         *   we're still resolving the objects, so we must use a signal to
<a name="1463"></a>         *   start the resolution process over for the new action
<a name="1464"></a>         */
<a name="1465"></a>        throw new RemapActionSignal(newAction);
<a name="1466"></a>    }
<a name="1467"></a>    else
<a name="1468"></a>    {
<a name="1469"></a>        /*
<a name="1470"></a>         *   We've finished resolving everything, so we can simply use the
<a name="1471"></a>         *   new action as a replacement action.
<a name="1472"></a>         */
<a name="1473"></a>        execNestedAction(true, true, gActor, newAction);
<a name="1474"></a>
<a name="1475"></a>        /*
<a name="1476"></a>         *   the remapped action replaces the original action, so
<a name="1477"></a>         *   terminate the original action
<a name="1478"></a>         */
<a name="1479"></a>        exit;
<a name="1480"></a>    }
<a name="1481"></a>}
<a name="1482"></a>
<a name="1483"></a>/*
<a name="1484"></a> *   Create a new action object for the given remapped action.
<a name="1485"></a> */
<a name="1486"></a>remapActionCreate(inResolve, oldRole, remapInfo)
<a name="1487"></a>{
<a name="1488"></a>    local newAction;
<a name="1489"></a>    local newObjs;
<a name="1490"></a>    local newActionClass;
<a name="1491"></a>    local objs;
<a name="1492"></a>
<a name="1493"></a>    /* get the new action class and object list from the remap info */
<a name="1494"></a>    newActionClass = remapInfo[1];
<a name="1495"></a>    objs = remapInfo.sublist(2);
<a name="1496"></a>
<a name="1497"></a>    /*
<a name="1498"></a>     *   create a new instance of the replacement action, carrying forward
<a name="1499"></a>     *   the properties of the original (current) action
<a name="1500"></a>     */
<a name="1501"></a>    newAction = newActionClass.createActionFrom(gAction);
<a name="1502"></a>
<a name="1503"></a>    /* remember the original action we're remapping */
<a name="1504"></a>    newAction.setOriginalAction(gAction);
<a name="1505"></a>
<a name="1506"></a>    /* set up an empty vector for the match trees for the new action */
<a name="1507"></a>    newObjs = new Vector(objs.length());
<a name="1508"></a>
<a name="1509"></a>    /* remap according to the phase of the execution */
<a name="1510"></a>    if (inResolve)
<a name="1511"></a>    {
<a name="1512"></a>        /* translate the object mappings */
<a name="1513"></a>        foreach (local cur in objs)
<a name="1514"></a>        {
<a name="1515"></a>            /* check what we have to translate */
<a name="1516"></a>            if (dataType(cur) == TypeEnum)
<a name="1517"></a>            {
<a name="1518"></a>                /*
<a name="1519"></a>                 *   it's an object role - if it's the special OtherObject
<a name="1520"></a>                 *   designator, get the other role of a two-object
<a name="1521"></a>                 *   command
<a name="1522"></a>                 */
<a name="1523"></a>                if (cur == OtherObject)
<a name="1524"></a>                    cur = gAction.getOtherObjectRole(oldRole);
<a name="1525"></a>
<a name="1526"></a>                /*
<a name="1527"></a>                 *   get the match tree for this role from the old action
<a name="1528"></a>                 *   and add it to our list
<a name="1529"></a>                 */
<a name="1530"></a>                newObjs.append(gAction.getMatchForRole(cur));
<a name="1531"></a>            }
<a name="1532"></a>            else
<a name="1533"></a>            {
<a name="1534"></a>                /* append the new ResolveInfo to the new object list */
<a name="1535"></a>                newObjs.append(gAction.getResolveInfo(cur, oldRole));
<a name="1536"></a>            }
<a name="1537"></a>        }
<a name="1538"></a>
<a name="1539"></a>        /* set the object matches in the new action */
<a name="1540"></a>        newAction.setObjectMatches(newObjs.toList()...);
<a name="1541"></a>    }
<a name="1542"></a>    else
<a name="1543"></a>    {
<a name="1544"></a>        /* translate the object mappings */
<a name="1545"></a>        foreach (local cur in objs)
<a name="1546"></a>        {
<a name="1547"></a>            /* check what we have to translate */
<a name="1548"></a>            if (dataType(cur) != TypeEnum)
<a name="1549"></a>            {
<a name="1550"></a>                /* it's an explicit object - use it directly */
<a name="1551"></a>                newObjs.append(cur);
<a name="1552"></a>            }
<a name="1553"></a>            else
<a name="1554"></a>            {
<a name="1555"></a>                /* it's a role - translate OtherObject if needed */
<a name="1556"></a>                if (cur == OtherObject)
<a name="1557"></a>                    cur = gAction.getOtherObjectRole(oldRole);
<a name="1558"></a>
<a name="1559"></a>                /* get the resolved object for this role */
<a name="1560"></a>                newObjs.append(gAction.getObjectForRole(cur));
<a name="1561"></a>            }
<a name="1562"></a>        }
<a name="1563"></a>
<a name="1564"></a>        /* set the resolved objects in the new action */
<a name="1565"></a>        newAction.setResolvedObjects(newObjs.toList()...);
<a name="1566"></a>    }
<a name="1567"></a>
<a name="1568"></a>    /* return the new action */
<a name="1569"></a>    return newAction;
<a name="1570"></a>}
<a name="1571"></a>
<a name="1572"></a>/* ------------------------------------------------------------------------ */
<a name="1573"></a>/*
<a name="1574"></a> *   Result message object.  This is used for verification results and
<a name="1575"></a> *   main command reports, which must keep track of messages to display.
<a name="1576"></a> */
<a name="1577"></a>class MessageResult: object
<a name="1578"></a>    /*
<a name="1579"></a>     *   Construct given literal message text, or alternatively a property
<a name="1580"></a>     *   of the current actor's verb messages object.  In either case,
<a name="1581"></a>     *   we'll expand the message immediately to allow the message to be
<a name="1582"></a>     *   displayed later with any parameters fixed at the time the message
<a name="1583"></a>     *   is constructed.
<a name="1584"></a>     */
<a name="1585"></a>    construct(msg, [params])
<a name="1586"></a>    {
<a name="1587"></a>        /* if we're based on an existing object, copy its characteristics */
<a name="1588"></a>        if (dataType(msg) == TypeObject &amp;&amp; msg.ofKind(MessageResult))
<a name="1589"></a>        {
<a name="1590"></a>            /* base it on the existing object */
<a name="1591"></a>            messageText_ = msg.messageText_;
<a name="1592"></a>            messageProp_ = msg.messageProp_;
<a name="1593"></a>            return;
<a name="1594"></a>        }
<a name="1595"></a>
<a name="1596"></a>        /*
<a name="1597"></a>         *   if the message was given as a property, remember the property
<a name="1598"></a>         *   for identification purposes
<a name="1599"></a>         */
<a name="1600"></a>        if (dataType(msg) == TypeProp)
<a name="1601"></a>            messageProp_ = msg;
<a name="1602"></a>
<a name="1603"></a>        /*
<a name="1604"></a>         *   Resolve the message and store the text.  Use the action's
<a name="1605"></a>         *   objects (the direct object, indirect object, etc) as the
<a name="1606"></a>         *   sources for message overrides - this makes it easy to override
<a name="1607"></a>         *   messages on a per-object basis without having to rewrite the
<a name="1608"></a>         *   whole verify/check/action routines.
<a name="1609"></a>         */
<a name="1610"></a>        messageText_ = resolveMessageText(gAction.getCurrentObjects(),
<a name="1611"></a>                                          msg, params);
<a name="1612"></a>    }
<a name="1613"></a>
<a name="1614"></a>    /*
<a name="1615"></a>     *   Static method: resolve a message.  If the message is given as a
<a name="1616"></a>     *   property, we'll look up the message in the given source objects
<a name="1617"></a>     *   and in the actor's "action messages" object.  We'll return the
<a name="1618"></a>     *   resolved message string.
<a name="1619"></a>     */
<a name="1620"></a>    resolveMessageText(sources, msg, params)
<a name="1621"></a>    {
<a name="1622"></a>        /*
<a name="1623"></a>         *   If we have more than one source object, it means that the
<a name="1624"></a>         *   command has more than one object slot (such as a TIAction,
<a name="1625"></a>         *   which has direct and indirect objects).  Rearrange the list so
<a name="1626"></a>         *   that the nearest caller is the first object in the list.  If
<a name="1627"></a>         *   one of these source objects provides an override, we generally
<a name="1628"></a>         *   want to get the message from the immediate caller rather than
<a name="1629"></a>         *   the other object.  Note that we only care about the *first*
<a name="1630"></a>         *   source object we find in the stack trace, because we only care
<a name="1631"></a>         *   about the actual message generator call; enclosing calls
<a name="1632"></a>         *   aren't relevant to the message priority because they don't
<a name="1633"></a>         *   necessarily have anything to do with the messaging.
<a name="1634"></a>         */
<a name="1635"></a>        if (sources.length() &gt; 1)
<a name="1636"></a>        {
<a name="1637"></a>            /* look through the stack trace for a 'self' in the source list */
<a name="1638"></a>            local tr = t3GetStackTrace();
<a name="1639"></a>            for (local i = 1, local trCnt = tr.length() ; i &lt;= trCnt ; ++i)
<a name="1640"></a>            {
<a name="1641"></a>                /* check this 'self' */
<a name="1642"></a>                local s = tr[i].self_;
<a name="1643"></a>                local sIdx = sources.indexOf(s);
<a name="1644"></a>                if (sIdx != nil)
<a name="1645"></a>                {
<a name="1646"></a>                    /*
<a name="1647"></a>                     *   it's a match - move this object to the head of the
<a name="1648"></a>                     *   list so that we give its message bindings priority
<a name="1649"></a>                     */
<a name="1650"></a>                    if (sIdx != 1)
<a name="1651"></a>                        sources = [s] + (sources - s);
<a name="1652"></a>
<a name="1653"></a>                    /* no need to look any further */
<a name="1654"></a>                    break;
<a name="1655"></a>                }
<a name="1656"></a>            }
<a name="1657"></a>        }
<a name="1658"></a>
<a name="1659"></a>        /*
<a name="1660"></a>         *   The message can be given either as a string or as a property
<a name="1661"></a>         *   of the actor's verb message object.  If it's the latter, look
<a name="1662"></a>         *   up the text of the property from the appropriate object.
<a name="1663"></a>         */
<a name="1664"></a>    findTextSource:
<a name="1665"></a>        if (dataType(msg) == TypeProp)
<a name="1666"></a>        {
<a name="1667"></a>            local msgObj;
<a name="1668"></a>
<a name="1669"></a>            /*
<a name="1670"></a>             *   Presume that we'll read the message from the current
<a name="1671"></a>             *   actor's "action message object."  This is typically
<a name="1672"></a>             *   playerActionMessages or npcActionMessages, but it's up to
<a name="1673"></a>             *   the actor to specify which object we get our messages
<a name="1674"></a>             *   from.
<a name="1675"></a>             */
<a name="1676"></a>            msgObj = gActor.getActionMessageObj();
<a name="1677"></a>
<a name="1678"></a>            /*
<a name="1679"></a>             *   First, look up the message property in the action's
<a name="1680"></a>             *   objects (the direct object, indirect object, etc).  This
<a name="1681"></a>             *   makes it easy to override messages on a per-object basis
<a name="1682"></a>             *   without having to rewrite the whole verify/check/action
<a name="1683"></a>             *   routine.
<a name="1684"></a>             */
<a name="1685"></a>            foreach (local cur in sources)
<a name="1686"></a>            {
<a name="1687"></a>                /* check to see if this object defines the message property */
<a name="1688"></a>                if (cur != nil &amp;&amp; cur.propDefined(msg))
<a name="1689"></a>                {
<a name="1690"></a>                    local res;
<a name="1691"></a>
<a name="1692"></a>                    /*
<a name="1693"></a>                     *   This object defines the property, so check what
<a name="1694"></a>                     *   we have.
<a name="1695"></a>                     */
<a name="1696"></a>                    switch (cur.propType(msg))
<a name="1697"></a>                    {
<a name="1698"></a>                    case TypeProp:
<a name="1699"></a>                        /*
<a name="1700"></a>                         *   It's another property, so we're being
<a name="1701"></a>                         *   directed back to the player action message
<a name="1702"></a>                         *   object.  The object does override the
<a name="1703"></a>                         *   message, but the override points to another
<a name="1704"></a>                         *   message property in the action object message
<a name="1705"></a>                         *   set.  Simply redirect 'msg' to point to the
<a name="1706"></a>                         *   new property, and use the same action message
<a name="1707"></a>                         *   object we already assumed we'd use.
<a name="1708"></a>                         */
<a name="1709"></a>                        msg = cur.(msg);
<a name="1710"></a>                        break;
<a name="1711"></a>
<a name="1712"></a>                    case TypeSString:
<a name="1713"></a>                        /* it's a simple string - retrieve it */
<a name="1714"></a>                        msg = cur.(msg);
<a name="1715"></a>
<a name="1716"></a>                        /*
<a name="1717"></a>                         *   since it's just a string, we're done finding
<a name="1718"></a>                         *   the message text - there's no need to do any
<a name="1719"></a>                         *   further property lookup, since we've obviously
<a name="1720"></a>                         *   reached the end of that particular line
<a name="1721"></a>                         */
<a name="1722"></a>                        break findTextSource;
<a name="1723"></a>
<a name="1724"></a>                    case TypeCode:
<a name="1725"></a>                        /*
<a name="1726"></a>                         *   Check the parameter count - we'll allow this
<a name="1727"></a>                         *   method to take the full set of parameters, or
<a name="1728"></a>                         *   no parameters at all.  We allow the no-param
<a name="1729"></a>                         *   case for convenience in cases where the method
<a name="1730"></a>                         *   simply wants to return a string or property ID
<a name="1731"></a>                         *   from a short method that doesn't need to know
<a name="1732"></a>                         *   the parameters; in these cases, it's
<a name="1733"></a>                         *   syntactically a lot nicer looking to write it
<a name="1734"></a>                         *   as a "prop = (expresion)" than to write the
<a name="1735"></a>                         *   full method-with-params syntax.
<a name="1736"></a>                         */
<a name="1737"></a>                        if (cur.getPropParams(msg) == [0, 0, nil])
<a name="1738"></a>                            res = cur.(msg);
<a name="1739"></a>                        else
<a name="1740"></a>                            res = cur.(msg)(params...);
<a name="1741"></a>
<a name="1742"></a>                        /*
<a name="1743"></a>                         *   If that returned nil, ignore it entirely and
<a name="1744"></a>                         *   keep scanning the remaining source objects.
<a name="1745"></a>                         *   The object must have decided it didn't want to
<a name="1746"></a>                         *   provide the message override in this case
<a name="1747"></a>                         *   after all.
<a name="1748"></a>                         */
<a name="1749"></a>                        if (res == nil)
<a name="1750"></a>                            continue;
<a name="1751"></a>
<a name="1752"></a>                        /* we didn't get nil, so use the result */
<a name="1753"></a>                        msg = res;
<a name="1754"></a>
<a name="1755"></a>                        /*
<a name="1756"></a>                         *   if we got a string, we've fully resolved the
<a name="1757"></a>                         *   message text, so we can stop searching for it
<a name="1758"></a>                         */
<a name="1759"></a>                        if (dataType(msg) == TypeSString)
<a name="1760"></a>                            break findTextSource;
<a name="1761"></a>
<a name="1762"></a>                        /*
<a name="1763"></a>                         *   It's not nil and it's not a string, so it must
<a name="1764"></a>                         *   be a property ID.  In this case, the property
<a name="1765"></a>                         *   ID is a property to evaluate in the normal
<a name="1766"></a>                         *   action message object.  Simply proceed to
<a name="1767"></a>                         *   evaluate the new message property as normal.
<a name="1768"></a>                         */
<a name="1769"></a>                        break;
<a name="1770"></a>
<a name="1771"></a>                    case TypeNil:
<a name="1772"></a>                        /*
<a name="1773"></a>                         *   it's explicitly nil, which simply means to
<a name="1774"></a>                         *   ignore this definition; keep scanning other
<a name="1775"></a>                         *   source objects
<a name="1776"></a>                         */
<a name="1777"></a>                        continue;
<a name="1778"></a>
<a name="1779"></a>                    default:
<a name="1780"></a>                        /*
<a name="1781"></a>                         *   In any other case, this must simply be the
<a name="1782"></a>                         *   message we're to use.  For this case, the
<a name="1783"></a>                         *   source of the message is this object, so
<a name="1784"></a>                         *   forget about the normal action message object
<a name="1785"></a>                         *   and instead use the current object.  Then
<a name="1786"></a>                         *   proceed to evaluate the message property as
<a name="1787"></a>                         *   normal, which will fetch it from the current
<a name="1788"></a>                         *   object.
<a name="1789"></a>                         */
<a name="1790"></a>                        msgObj = cur;
<a name="1791"></a>                        break;
<a name="1792"></a>                    }
<a name="1793"></a>
<a name="1794"></a>                    /*
<a name="1795"></a>                     *   we found a definition, so we don't need to look
<a name="1796"></a>                     *   at any of the other objects involved in the
<a name="1797"></a>                     *   action - we just use the first override we find
<a name="1798"></a>                     */
<a name="1799"></a>                    break;
<a name="1800"></a>                }
<a name="1801"></a>            }
<a name="1802"></a>
<a name="1803"></a>            /* look up the message in the actor's message generator */
<a name="1804"></a>            msg = msgObj.(msg)(params...);
<a name="1805"></a>        }
<a name="1806"></a>
<a name="1807"></a>        /*
<a name="1808"></a>         *   format the string and remember the result - do the formatting
<a name="1809"></a>         *   immediately, because we want to make sure we expand any
<a name="1810"></a>         *   substitution parameters in the context of the current
<a name="1811"></a>         *   command, since the parameters might change (and thus alter
<a name="1812"></a>         *   the meaning of the message) by the time it's displayed
<a name="1813"></a>         */
<a name="1814"></a>        msg = langMessageBuilder.generateMessage(msg);
<a name="1815"></a>
<a name="1816"></a>        /*
<a name="1817"></a>         *   "quote" the message text - it's fully expanded now, so
<a name="1818"></a>         *   there's no need to further expand anything that might by
<a name="1819"></a>         *   coincidence look like substitution parameters in its text
<a name="1820"></a>         */
<a name="1821"></a>        msg = langMessageBuilder.quoteMessage(msg);
<a name="1822"></a>
<a name="1823"></a>        /* return the resolved message string */
<a name="1824"></a>        return msg;
<a name="1825"></a>    }
<a name="1826"></a>
<a name="1827"></a>    /*
<a name="1828"></a>     *   set a new message, given the same type of information as we'd use
<a name="1829"></a>     *   to construct the object
<a name="1830"></a>     */
<a name="1831"></a>    setMessage(msg, [params])
<a name="1832"></a>    {
<a name="1833"></a>        /* simply invoke the constructor to re-fill the message data */
<a name="1834"></a>        construct(msg, params...);
<a name="1835"></a>    }
<a name="1836"></a>
<a name="1837"></a>    /*
<a name="1838"></a>     *   Display a message describing why the command isn't allowed.
<a name="1839"></a>     */
<a name="1840"></a>    showMessage()
<a name="1841"></a>    {
<a name="1842"></a>        /* show our message string */
<a name="1843"></a>        say(messageText_);
<a name="1844"></a>    }
<a name="1845"></a>
<a name="1846"></a>    /* the text of our result message */
<a name="1847"></a>    messageText_ = nil
<a name="1848"></a>
<a name="1849"></a>    /* the message property, if we have one */
<a name="1850"></a>    messageProp_ = nil
<a name="1851"></a>;
<a name="1852"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
