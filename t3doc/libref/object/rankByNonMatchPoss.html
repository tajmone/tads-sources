<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>rankByNonMatchPoss</title></head><body>
<table class=ban><tr><td align=left><span class=title>rankByNonMatchPoss</span><span class=type>object</span><td align=right><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#5947">5947</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   Rank by unmatched possessive-qualified phrases.  If we have two   unknown phrases, one with a possessive qualifier and one without, and   other things being equal, prefer the one with the possessive   qualifier. <p>   We prefer the qualified version because it lets us report a smaller   phrase that we can't match.  For example, in X BOB'S WALLET, if we   can't match WALLET all by itself, it's more useful to report that "you   see no wallet" than to report that you see no "bob's wallet", because   the latter incorrectly implies that there might still be a wallet in   scope as long as it's not Bob's we're looking for.
<p>
<code><b>rankByNonMatchPoss</b> :  &nbsp; <a href="../object/CommandRankingCriterion.html">CommandRankingCriterion</a></code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>rankByNonMatchPoss</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/CommandRankingCriterion.html">CommandRankingCriterion</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
</code><p>
<code>
</code><p>
<i>(none)</i>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#comparePass1">comparePass1</a>&nbsp;
<a href="#comparePass2">comparePass2</a>&nbsp;
</code><p>
<code>
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="comparePass1"></a>
<table class=decl><tr><td><code>comparePass1 (a, b)</code><span class=rem>OVERRIDDEN</span><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#5953">5953</a>]</table><div class=desc>   ignore on pass 1 - this only counts if other factors are equal, so   we want to consider all of the other factors on pass 1 before   taking this criterion into account <p>
</div>
<a name="comparePass2"></a>
<table class=decl><tr><td><code>comparePass2 (a, b)</code><span class=rem>OVERRIDDEN</span><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#5956">5956</a>]</table><div class=desc>pass 2 - more possessives are better<p>
</div>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
