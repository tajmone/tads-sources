<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>EmptyNounPhraseProd</title></head><body>
<table class=ban><tr><td align=left><span class=title>EmptyNounPhraseProd</span><span class=type>class</span><td align=right><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4028">4028</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   An empty noun phrase production is one that matches, typically with   non-zero badness value, as a placeholder when a command is missing a   noun phrase where one is required. <p>   Each grammar rule instance of this rule class must define the   property 'responseProd' to be the production that should be used to   parse any response to an interactive prompt for the missing object.
<p>
<code>class
<b>EmptyNounPhraseProd</b> :  &nbsp; <a href="../object/NounPhraseProd.html">NounPhraseProd</a></code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>EmptyNounPhraseProd</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/NounPhraseProd.html">NounPhraseProd</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/BasicProd.html">BasicProd</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<code><b>EmptyNounPhraseProd</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/ImpliedActorNounPhraseProd.html">ImpliedActorNounPhraseProd</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/nounList(empty).html">nounList(empty)</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/singleNoun(empty).html">singleNoun(empty)</a></code><br>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
<a href="#asker_">asker_</a>&nbsp;
<a href="#fallbackResponseProd">fallbackResponseProd</a>&nbsp;
<a href="#newMatch">newMatch</a>&nbsp;
<a href="#responseProd">responseProd</a>&nbsp;
</code><p>
<p>Inherited from <code>NounPhraseProd</code> :<br>
<code>
<a href="../object/NounPhraseProd.html#filterForCollectives">filterForCollectives</a>&nbsp;
</code><p>
<p>Inherited from <code>BasicProd</code> :<br>
<code>
<a href="../object/BasicProd.html#firstTokenIndex">firstTokenIndex</a>&nbsp;
<a href="../object/BasicProd.html#isSpecialResponseMatch">isSpecialResponseMatch</a>&nbsp;
<a href="../object/BasicProd.html#lastTokenIndex">lastTokenIndex</a>&nbsp;
</code><p>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#getImpliedObject">getImpliedObject</a>&nbsp;
<a href="#getOrigText">getOrigText</a>&nbsp;
<a href="#getOrigTokenList">getOrigTokenList</a>&nbsp;
<a href="#isEmptyPhrase">isEmptyPhrase</a>&nbsp;
<a href="#resolveNouns">resolveNouns</a>&nbsp;
<a href="#setPrompt">setPrompt</a>&nbsp;
</code><p>
<p>Inherited from <code>NounPhraseProd</code> :<br>
<code>
<a href="../object/NounPhraseProd.html#filterTruncations">filterTruncations</a>&nbsp;
<a href="../object/NounPhraseProd.html#getVerifyKeepers">getVerifyKeepers</a>&nbsp;
</code><p>
<p>Inherited from <code>BasicProd</code> :<br>
<code>
<a href="../object/BasicProd.html#canResolveTo">canResolveTo</a>&nbsp;
<a href="../object/BasicProd.html#setOrigTokenList">setOrigTokenList</a>&nbsp;
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<a name="asker_"></a>
<table class=decl><tr><td><code>asker_</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4152">4152</a>]</table><div class=desc>   The ResolveAsker we use to generate our prompt.  Use the base   ResolveAsker by default; this can be overridden when the prompt   is to be customized. <p>
</div>
<a name="fallbackResponseProd"></a>
<table class=decl><tr><td><code>fallbackResponseProd</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4145">4145</a>]</table><div class=desc>   Our fallback response production - if responseProd is nil, this   must be supplied for cases where we can't get the production from   the action.  This is ignored if responseProd is non-nil. <p>
</div>
<a name="newMatch"></a>
<table class=decl><tr><td><code>newMatch</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4130">4130</a>]</table><div class=desc>   the new match, when we get an interactive response to a query for   the missing object <p>
</div>
<a name="responseProd"></a>
<table class=decl><tr><td><code>responseProd</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4138">4138</a>]</table><div class=desc>   Our "response" production - this is the production we use to parse   the player's input in response to our disambiguation prompt.  A   subclass can leave this as nil, in which case we'll attempt to get   the appropriate response production from the action. <p>
</div>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="getImpliedObject"></a>
<table class=decl><tr><td><code>getImpliedObject (resolver, results)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4094">4094</a>]</table><div class=desc>   Get an implied object to automatically fill in for the missing   noun phrase.  By default, we simply ask the 'results' object for   the missing object. <p>
</div>
<a name="getOrigText"></a>
<table class=decl><tr><td><code>getOrigText ( )</code><span class=rem>OVERRIDDEN</span><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4115">4115</a>]</table><div class=desc>   Get my original text.  If I have a new match tree, return the   text from the new match tree.  Otherwise, we have no original   text, since we're an empty phrase. <p>
</div>
<a name="getOrigTokenList"></a>
<table class=decl><tr><td><code>getOrigTokenList ( )</code><span class=rem>OVERRIDDEN</span><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4105">4105</a>]</table><div class=desc>   Get my tokens.  If I have a new match tree, return the tokens   from the new match tree.  Otherwise, we don't have any tokens,   since we're empty. <p>
</div>
<a name="isEmptyPhrase"></a>
<table class=decl><tr><td><code>isEmptyPhrase ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4124">4124</a>]</table><div class=desc>   I'm an empty noun phrase, unless I already have a new match   object. <p>
</div>
<a name="resolveNouns"></a>
<table class=decl><tr><td><code>resolveNouns (resolver, results)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4038">4038</a>]</table><div class=desc>resolve the empty phrase<p>
</div>
<a name="setPrompt"></a>
<table class=decl><tr><td><code>setPrompt (response, asker)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4030">4030</a>]</table><div class=desc>customize the way we generate the prompt and parse the response<p>
</div>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
