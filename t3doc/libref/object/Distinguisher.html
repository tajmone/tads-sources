<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>Distinguisher</title></head><body>
<table class=ban><tr><td align=left><span class=title>Distinguisher</span><span class=type>class</span><td align=right><a href="../file/disambig.t.html">disambig.t</a>[<a href="../source/disambig.t.html#25">25</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   Distinguisher.  This object encapsulates logic that determines   whether or not we can tell two objects apart. <p>   Each game object has a list of distinguishers.  For most objects, the   distinguisher list contains only BasicDistinguisher, since most game   objects are unique and thus are inherently distinguishable from all   other objects.
<p>
<code>class
<b>Distinguisher</b> :  &nbsp; object</code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>Distinguisher</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<code>
<a href="../object/basicDistinguisher.html">basicDistinguisher</a>&nbsp;
<a href="../object/litUnlitDistinguisher.html">litUnlitDistinguisher</a>&nbsp;
<a href="../object/locationDistinguisher.html">locationDistinguisher</a>&nbsp;
<a href="../object/nullDistinguisher.html">nullDistinguisher</a>&nbsp;
<a href="../object/ownershipDistinguisher.html">ownershipDistinguisher</a>&nbsp;
</code>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
</code><p>
<i>(none)</i>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#canDistinguish">canDistinguish</a>&nbsp;
<a href="#matchName">matchName</a>&nbsp;
<a href="#notePrompt">notePrompt</a>&nbsp;
<a href="#objInScope">objInScope</a>&nbsp;
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="canDistinguish"></a>
<table class=decl><tr><td><code>canDistinguish (a, b)</code><td align=right><code><a href="../file/disambig.t.html">disambig.t</a>[<a href="../source/disambig.t.html#27">27</a>]</table><div class=desc>can we distinguish the given two objects?<p>
</div>
<a name="matchName"></a>
<table class=decl><tr><td><code>matchName (obj, origTokens, adjustedTokens, matchList, fullMatchList)</code><td align=right><code><a href="../file/disambig.t.html">disambig.t</a>[<a href="../source/disambig.t.html#79">79</a>]</table><div class=desc>   Try matching an object to a noun phrase in a disambiguation reply   from the player (that is, the player's response to a "Which foo   did you mean" question).  By default, we call the object's   matchNameDisambig() method to let it try to match its   disambiguation name. <p>   Subclasses can override this to check for additional phrasing   specific to the subclass.  For example, the locational   distinguisher checks for a match to the container or owner name,   so that the player can simply respond to the question with the   location name rather than typing in a whole locational phrase.   Note that subclasses will usually want to inherit the default   handling if they don't find a match to their own special phrasing,   because the player might respond with a simple adjective   pertaining to the base object even if there's some external   distinguishing characteristic handled by the subclass. <p>
</div>
<a name="notePrompt"></a>
<table class=decl><tr><td><code>notePrompt (lst)</code><td align=right><code><a href="../file/disambig.t.html">disambig.t</a>[<a href="../source/disambig.t.html#42">42</a>]</table><div class=desc>   Note that we're showing a prompt to the player asking for help in   narrowing the object list, based on this distinguisher.  'lst' is   the list of ResolveInfo objects which we're mentioning in the   prompt. <p>   By default, we do nothing.  Some types of distinguishers might   want to do something special here.  For example, an ownership   distinguisher might want to set pronoun antecedents based on the   owners mentioned in the disambiguation prompt, so that the   player's response can refer anaphorically to the nouns in the   prompt. <p>
</div>
<a name="objInScope"></a>
<table class=decl><tr><td><code>objInScope (obj, matchList, fullMatchList)</code><td align=right><code><a href="../file/disambig.t.html">disambig.t</a>[<a href="../source/disambig.t.html#55">55</a>]</table><div class=desc>   Is the object in scope for the purposes of the disambiguation   reply from the player?  By default, any object in the full match   list is in scope. <p>   Distinguishers that can use related objects to qualify the name   should add those related objects to the scope by returning true   here.  For example, the locational distinguisher can use the   location name as a qualifying phrase, so the location name is in   scope. <p>
</div>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/16/2013 from TADS version 3.1.3</div>
</body>
</html>
